/*
               Банковская интегрированная система БИСквит
    copyright: (c) 1992-2001 ТОО "Банковские информационные системы"
     filename: kautools.lib
      comment: Библиотека инструментов для работы с картотеками
      comment:
   parameters:
         uses:
      used by:
      created: 15/12/2001 kostik
     modified: 08/05/2002 kostik  0006764 отбор внебалансовых
                                          счетов с учетом прав пользователя
     modified: 19/08/2002 kraw    0002516 добавлены setKauDocSysConf, getKauDocSysConf - мои (kraw)
                                                    SelectKau, REFORMAT_Proc, REFORMAT_Param, CALL-Proc - kostik
     Modified: 06/03/2003 kraw (0012006) Карт(x)ВНСчет может содержать валюту
     Modified: 24/09/2004 Kostik (0038217) инструмент для поиска внебалансового счета,балансового по kau
     Modified: 27/02/2008 kraw (0089583) Если удален внебалансовый, с которым установлена жесткая связь, то ищем не жесткую
     Modified: 28.03.2008 muta  0088445  Процедура fnd_acct_op перенесена в pp-crd.p.      
     Modified: 10/04/2009 kraw (0106231) в fdbacct - in-cod-val EQ "КартБлСч"
*/
{intrface.get crd}   /* Библиотека инструментов работы с картотекой */
{intrface.get db2l}


&IF DEFINED(Noacctread) = 0 &THEN
{acctread.i
   &bufacct    = bfAcct
   &class-code = "'acct' + bfacct.acct-cat "
}
&ENDIF

&IF DEFINED(KauToolsFun) = 0 &THEN
&GLOBAL-DEFINE KauToolsFun YES

&IF DEFINED(NumAcct) = 0 &THEN
&GLOBAL-DEFINE NumAcct YES
DEFINE VARIABLE vNumAcct AS INTEGER NO-UNDO.
&ENDIF



DEFINE TEMP-TABLE ttKau NO-UNDO
        FIELD fTbName  AS CHARACTER
        FIELD fRecId    AS RECID
INDEX TableName fTbName fRecId.

def buffer buf-ttkau for ttkau.
def var v-debug as log no-undo.
/*Выбор счетов привязанных к картотеке*/
PROCEDURE SelectAcctOfKauId:
        DEFINE INPUT PARAMETER ipKauId AS CHARACTER NO-UNDO.  /*Код шаблона КАУ*/
        DEFINE BUFFER bfAcct    FOR acct.
        DEFINE BUFFER bfBalAcct FOR bal-acct.

        DEFINE VARIABLE vCurrency AS CHARACTER  NO-UNDO.
        DEFINE VARIABLE vConf     AS CHARACTER  NO-UNDO.

        vConf = GetSysConf ("ПроцКауПар").
        vCurrency = ENTRY(2,vConf) NO-ERROR.

        FOR EACH ttKau WHERE ttKau.ftbName EQ "ACCT":
                DELETE ttKau.
        END.
   FOR EACH bfAcct WHERE bfacct.filial-id EQ shFilial
                     AND bfAcct.kau-id    EQ ipKauId
                    AND (({assigned vConf} AND bfacct.currency EQ vCurrency) OR NOT {assigned vConf})
&IF DEFINED(user-rights1) &THEN
                     AND {&user-rights1}
&ENDIF
                     AND {&user-rights}  NO-LOCK:
                CREATE ttKau.
                ASSIGN
                        ttKau.fTbName = "ACCT"
                        ttKau.fRecId  = RECID(bfAcct)
                .
        END.
        FOR EACH bfBalAcct WHERE bfBalAcct.kau-id EQ ipKauId NO-LOCK:
                FOR EACH bfAcct WHERE  bfacct.filial-id EQ shFilial
                        AND bfAcct.kau-id   EQ ""
                        AND bfAcct.acct-cat EQ bfBalAcct.acct-cat
                        AND bfAcct.bal-acct EQ bfBalAcct.bal-acct
                        AND (({assigned vConf} AND bfacct.currency EQ vCurrency) OR NOT {assigned vConf})
&IF DEFINED(user-rights1) &THEN
                        AND {&user-rights1}
&ENDIF
                        AND {&user-rights}  NO-LOCK:
                        CREATE ttKau.
                        ASSIGN
                                ttKau.fTbName = "ACCT"
                                ttKau.fRecId  = RECID(bfAcct)
                        .
                END.
                FOR EACH bfAcct WHERE  bfacct.filial-id EQ shFilial
                        AND bfAcct.kau-id   EQ ?
                        AND bfAcct.acct-cat EQ bfBalAcct.acct-cat
                        AND bfAcct.bal-acct EQ bfBalAcct.bal-acct
                        AND (({assigned vConf} AND bfacct.currency EQ vCurrency) OR NOT {assigned vConf})
&IF DEFINED(user-rights1) &THEN
                        AND {&user-rights1}
&ENDIF
                        AND {&user-rights} NO-LOCK:
                        CREATE ttKau.
                        ASSIGN
                                ttKau.fTbName = "ACCT"
                                ttKau.fRecId  = RECID(bfAcct)
                        .
                END.
        END.
        RELEASE ttkau.
END PROCEDURE.

/*Отбор всех субсчетов по KauId*/
/*PROCEDURE SelectKauOfKauId:*/
/*def param buffer oacct for acct.*/
/*def ourput param*/

/*END PROCEDURE.*/

/* поиск балансовых счетов по внебалансовому
ссылки помещаем в вр таблицу */
procedure fdbacct :
def param buffer oacct for acct.
def input param search-b as char no-undo.
def input param in-cod-val like code.code no-undo.

def buffer bfacct for acct.

DEFINE BUFFER o1acct FOR acct.

def var tmp-acct as char no-undo.
DEF VAR tmp-curr AS CHAR NO-UNDO.

DEFINE VARIABLE vCurrency AS CHARACTER  NO-UNDO.
DEFINE VARIABLE vConf     AS CHARACTER  NO-UNDO.

  vConf = GetSysConf ("ПроцКауПар").
  vCurrency = ENTRY(1,vConf) NO-ERROR.

  FOR EACH ttKau WHERE ttKau.ftbName EQ "ACCTB":
                DELETE ttKau.
        END.

  IF in-cod-val EQ "КартБлСч" THEN
  DO:

    FOR EACH bfacct WHERE  bfacct.cust-cat EQ oacct.cust-cat
                    AND bfacct.cust-id  EQ oacct.cust-id
                    AND bfacct.acct-cat EQ "b"
                    AND bfacct.currency = oacct.currency
                    and bfacct.close-date = ?
                    AND (IF ShMode 
                         THEN bfacct.filial-id EQ shFilial
                         ELSE TRUE 
                        )
                    AND {&user-rights}
                    AND LOOKUP(bfacct.contract,mAcctContCrd2) NE 0
                    NO-LOCK:
      tmp-acct = GetXattrvalue("acct",bfacct.acct + "," + bfacct.currency,"КартБВНСчет").


      IF NUM-ENTRIES(tmp-acct) < 2 THEN
         ASSIGN
            tmp-curr = ""
            tmp-acct = ""
         .
      ELSE 
      DO:
         ASSIGN
            tmp-curr = ENTRY(2,tmp-acct)
            tmp-acct = ENTRY(1,tmp-acct)
         .

         FIND FIRST o1acct WHERE o1acct.acct     EQ tmp-acct
                             AND o1acct.currency EQ tmp-curr
            NO-LOCK NO-ERROR.

         IF NOT AVAILABLE o1acct THEN
            ASSIGN
               tmp-curr = ""
               tmp-acct = ""
            .
            
      END.
         
      IF     tmp-acct = oacct.acct
         AND tmp-curr = oacct.currency THEN DO:
        CREATE ttkau.
        ASSIGN
          ttkau.ftbname = "ACCTB"
          ttkau.frecid = RECID(bfacct).

        vNumAcct = vNumAcct + 1.
        STATUS DEFAULT "Записей обработано : " + STRING(vNumAcct,"ZZZ9").

      END.
      ELSE IF search-b EQ "Да" THEN
      DO: /* все таки поищем документы на картотеке */

        FOR EACH op-entry WHERE op-entry.acct-db  EQ oacct.acct
                            AND op-entry.currency EQ oacct.currency NO-LOCK,
            FIRST op OF op-entry WHERE GetXAttrValue("op", STRING(op.op) ,"acct-send") EQ bfacct.acct NO-LOCK :
            LEAVE.
        END.

        IF AVAILABLE op THEN
        DO:
          CREATE ttkau.
          ASSIGN
            ttkau.ftbname = "ACCTB"
            ttkau.frecid = RECID(bfacct).

          vNumAcct = vNumAcct + 1.
          STATUS DEFAULT "Записей обработано : " + STRING(vNumAcct,"ZZZ9").
        END.
      END.
    END.
  END.

  if in-cod-val = "Карт-ка2" then do:
    FOR EACH bfacct WHERE  bfacct.cust-cat EQ oacct.cust-cat
                    AND bfacct.cust-id  EQ oacct.cust-id
                    AND bfacct.acct-cat EQ "b"
                    AND bfacct.close-date = ?
                    /* AND (({assigned vConf} AND bfacct.currency EQ vCurrency) OR (NOT {assigned vConf} AND bfacct.currency = oacct.currency)) */  
                    AND (IF ShMode 
                         THEN bfacct.filial-id EQ shFilial
                         ELSE TRUE 
                        )
                    AND {&user-rights}
                    AND LOOKUP(bfacct.contract,mAcctContCrd2) NE 0
                    USE-INDEX acct-cust
                    NO-LOCK:
      tmp-acct = GetXattrvalue("acct",bfacct.acct + "," + bfacct.currency,"Карт2ВНСчет").


      IF NUM-ENTRIES(tmp-acct) < 2 THEN
         ASSIGN
            tmp-curr = ""
            tmp-acct = ""
         .
      ELSE 
      DO:
         ASSIGN
            tmp-curr = ENTRY(2,tmp-acct)
            tmp-acct = ENTRY(1,tmp-acct)
         .

         FIND FIRST o1acct WHERE o1acct.acct     EQ tmp-acct
                             AND o1acct.currency EQ tmp-curr
            NO-LOCK NO-ERROR.

         IF NOT AVAILABLE o1acct THEN
            ASSIGN
               tmp-curr = ""
               tmp-acct = ""
            .
            
      END.
         
      IF     tmp-acct = oacct.acct
         AND tmp-curr = oacct.currency THEN DO:
        create ttkau.
        assign
          ttkau.ftbname = "ACCTB"
          ttkau.frecid = recid(bfacct).

        vNumAcct = vNumAcct + 1.
        STATUS DEFAULT "Записей обработано : " + STRING(vNumAcct,"ZZZ9").

      END.
      else if search-b = "Да" then do: /* все таки поищем документы на картотеке */
        for each op-entry where op-entry.acct-db = oacct.acct and
                                op-entry.currency = oacct.currency no-lock,
            first op of op-entry where GetXAttrValue("op", string(op.op) ,"acct-send") = bfacct.acct no-lock :
            leave.
        end.
        if avail op then do:
          create ttkau.
          assign
            ttkau.ftbname = "ACCTB"
            ttkau.frecid = recid(bfacct).

          vNumAcct = vNumAcct + 1.
          STATUS DEFAULT "Записей обработано : " + STRING(vNumAcct,"ZZZ9").

        end.
      end.
    end.
  end.
  if in-cod-val = "Карт-ка1" then do:
    FOR EACH bfacct WHERE bfacct.cust-cat EQ oacct.cust-cat
                    AND bfacct.cust-id  EQ oacct.cust-id
                    AND bfacct.acct-cat EQ "b"
                    and bfacct.currency = oacct.currency
                    and bfacct.close-date = ?
                    AND (IF ShMode 
                         THEN bfacct.filial-id EQ shFilial
                         ELSE TRUE
                        )
                    AND {&user-rights}
                    AND LOOKUP(bfacct.contract,mAcctContCrd2) NE 0
                    NO-LOCK:

      tmp-acct = GetXattrvalue("acct",bfacct.acct + "," + bfacct.currency,"Карт1ВНСчет").
       

      IF NUM-ENTRIES(tmp-acct) < 2 THEN
         ASSIGN
            tmp-curr = ""
            tmp-acct = ""
         .
      ELSE 
      DO:
         ASSIGN
            tmp-curr = ENTRY(2,tmp-acct)
            tmp-acct = ENTRY(1,tmp-acct)
         .

         FIND FIRST o1acct WHERE o1acct.acct     EQ tmp-acct
                             AND o1acct.currency EQ tmp-curr
            NO-LOCK NO-ERROR.

         IF NOT AVAILABLE o1acct THEN
            ASSIGN
               tmp-curr = ""
               tmp-acct = ""
            .
            
      END.
         
      IF     tmp-acct = oacct.acct
         AND tmp-curr = oacct.currency THEN DO:
        create ttkau.
        assign
          ttkau.ftbname = "ACCTB"
          ttkau.frecid = recid(bfacct).

        vNumAcct = vNumAcct + 1.
        STATUS DEFAULT "Записей обработано : " + STRING(vNumAcct,"ZZZ9").

      END.
    end.
  end.
  if not can-find(first ttkau where ttkau.ftbname = "acctb") then do: /* не нашли ничего */
    for each bfacct where  bfacct.cust-cat EQ oacct.cust-cat
                    AND bfacct.cust-id    EQ oacct.cust-id
                    AND bfacct.acct-cat   EQ "b"
                    AND (({assigned vConf} AND bfacct.currency EQ vCurrency) OR (NOT {assigned vConf} AND bfacct.currency = oacct.currency))  
                    and bfacct.close-date EQ ?
                    AND (IF ShMode 
                         THEN bfacct.filial-id EQ shFilial
                         ELSE TRUE 
                        )
                    AND {&user-rights}
                    AND LOOKUP(bfacct.contract,mAcctContCrd2) NE 0
                    USE-INDEX acct-cust
                    no-lock:
        IF in-cod-val = "Карт-ка2" then do:
          tmp-acct = GetXattrvalue("acct", bfacct.acct + "," + bfacct.currency, "Карт2ВНСчет").
          if trim(tmp-acct) <> "" and tmp-acct <> ? THEN 
          DO:

            FIND FIRST o1acct WHERE o1acct.acct     EQ tmp-acct
                                AND o1acct.currency EQ tmp-curr
               NO-LOCK NO-ERROR.

            IF AVAILABLE o1acct THEN
               NEXT.
            ELSE
               LEAVE.
          END.
          else leave.
        end.
        ELSE do:
          IF in-cod-val = "Карт-ка1" then do:
            tmp-acct = GetXattrvalue("acct", bfacct.acct + "," + bfacct.currency, "Карт1ВНСчет").
            if trim(tmp-acct) <> "" and tmp-acct <> ? THEN
             DO:

               FIND FIRST o1acct WHERE o1acct.acct     EQ tmp-acct
                                   AND o1acct.currency EQ tmp-curr
                  NO-LOCK NO-ERROR.

               IF AVAILABLE o1acct THEN
                  NEXT.
               ELSE
                  LEAVE.
             END.
            else leave.
          end.
          ELSE LEAVE.
        end.
    END.
    if avail bfacct then do:
      create ttkau.
      assign
        ttkau.ftbname = "ACCTB"
        ttkau.frecid = recid(bfacct).
      
      vNumAcct = vNumAcct + 1.
      STATUS DEFAULT "Записей обработано : " + STRING(vNumAcct,"ZZZ9").

    end.
    else do:
        IF v-debug THEN
        MESSAGE "Внебалансовый счет" oacct.acct
                "не имеет соответствующего счета на балансе!"
        VIEW-AS ALERT-BOX ERROR.
    end.
  end.
end procedure. /* fdbacct */

/* расчет остатка на картотеке2, определенного по внебалансовому и балансовому счету */
procedure calc-crd2 :
  def input param in-oacct like acct.acct no-undo. /* внебаланс */
  def input param in-bacct like acct.acct no-undo. /* баланс */
  def input param in-curr  like currency.currency no-undo.
  def output param out-summ like op-entry.amt-rub no-undo.

  DEFINE VARIABLE vOpBalSurr AS CHARACTER NO-UNDO.

  def var s_code as char no-undo.
  def var summ-card like op-entry.amt-rub init 0 no-undo.
  def var summ-crd like op-entry.amt-rub no-undo.
  def buffer bop for op.

  s_code = FGetSetting("СтандТр", "КартСтат", "А") + ",А".

  for each kau where  kau.acct eq in-oacct and
                      kau.currency eq in-curr and
                      kau.zero-bal eq false no-lock:
    find first op-entry where op-entry.op eq INT64(entry(1,kau.kau)) and
                        op-entry.op-entry eq INT64(entry(2,kau.kau))
                        no-lock no-error.
    release op.
    release op-bank.
    release bop.
    if avail op-entry then do:
    find first op of op-entry no-lock no-error.
    find first op-bank of op where op-bank.op-bank-type eq "" no-lock no-error.
    end.
    else find first op where op.op eq INT64(entry(1,kau.kau)) no-lock no-error .
    IF NOT avail(op) THEN NEXT.

    vOpBalSurr = GetXAttrValue("op", Surrogate(BUFFER op:HANDLE), "op-bal").
    IF {assigned vOpBalSurr} THEN 
       FIND FIRST bop WHERE bop.op       EQ INT64(vOpBalSurr) 
                        AND bop.acct-cat EQ "b"
       NO-LOCK NO-ERROR.
    IF NOT AVAIL bop THEN
       find first bop where bop.op-transaction = op.op-transaction
                             and can-do(s_code, bop.op-status)
                             and bop.acct-cat eq "b"
       no-lock no-error.
    if avail bop then do:
      find op-entry of bop where op-entry.acct-db = in-bacct no-lock no-error.
      if avail op-entry then do:
        summ-crd = 0.
        run card-pos(recid(kau),gend-date, output summ-crd).
        summ-card = summ-card + summ-crd.
      end.
      else do:
        if GetXAttrValue("op", string(bop.op), "acctbal") = in-bacct then do:
          summ-crd = 0.
          run card-pos(recid(kau),gend-date, output summ-crd).
          summ-card = summ-card + summ-crd.
        end.
      end.
    end.
    ELSE DO:
        IF GetXAttrValue("op", vOpBalSurr, "acctbal") = in-bacct THEN DO:
        summ-crd = 0.
        RUN card-pos(RECID(kau),gend-date, OUTPUT summ-crd).
        summ-card = summ-card + summ-crd.
      END.
    END.
  end.
  out-summ = summ-card.
end procedure. /* calc-crd2 */

PROCEDURE card-pos:
def input  param in-kau as recid no-undo.
def input  param in-op-date like op.op-date no-undo.
def output param out-pos like op-entry.amt-rub no-undo.
def buffer buf-code     for code.
def buffer buf-acct     for acct.
def buffer buf-kau      for kau.
def buffer buf-op-entry for op-entry.
def var summ as decimal initial 0 no-undo.

find buf-kau where recid(buf-kau) eq in-kau no-lock no-error.
find buf-acct where buf-acct.acct eq buf-kau.acct
                and buf-acct.currency eq buf-kau.currency no-lock no-error.
if not avail buf-kau or not avail buf-acct then return.
FIND buf-code WHERE buf-code.class EQ "ШаблКау"
                AND buf-code.code  EQ buf-kau.kau-id
                                   NO-LOCK NO-ERROR.
IF NOT AVAIL buf-code THEN RETURN.

if buf-acct.side eq "А" then
 for each buf-op-entry where buf-op-entry.acct-cr   EQ     buf-kau.acct
                         AND buf-op-entry.op-date   LE     in-op-date
                         AND buf-op-entry.op-status GE     ENTRY(2,buf-code.misc[4])
                         AND buf-op-entry.currency  BEGINS buf-kau.currency
                         AND buf-op-entry.kau-cr    EQ     buf-kau.kau
                                                                NO-LOCK:
    accumulate buf-op-entry.amt-rub (total).
 end.
else
 for each buf-op-entry where buf-op-entry.acct-db   EQ     buf-kau.acct
                     AND buf-op-entry.op-date   LE     in-op-date
                     AND buf-op-entry.op-status GE     ENTRY(2,buf-code.misc[4])
                     AND buf-op-entry.currency  BEGINS buf-kau.currency
                     AND buf-op-entry.kau-db    EQ     buf-kau.kau
                                                                NO-LOCK:
    accumulate buf-op-entry.amt-rub (total).
 end.

summ = accum total buf-op-entry.amt-rub.

find first buf-op-entry where buf-op-entry.op eq INT64(entry(1,buf-kau.kau))
                          and buf-op-entry.op-entry eq INT64(entry(2,buf-kau.kau))
                                                                no-lock no-error.
IF avail(buf-op-entry) THEN
   out-pos = buf-op-entry.amt-rub - summ.
ELSE
   out-pos = 0.

END PROCEDURE.

FUNCTION GetStatCard RETURNS CHAR.
   DEF BUFFER b-op-t for op-templ.
   FIND FIRST b-op-t WHERE b-op-t.op-kind = "981" AND
                           b-op-t.acct-cat EQ 'b'
                           NO-LOCK NO-ERROR.
   RETURN (IF AVAIL b-op-t THEN b-op-t.op-status ELSE "А").
END.

/*
PROCEDURE GetKauTemplateFields:
        DEFINE INPUT  PARAMETER ipKauIdChar AS CHARACTER NO-UNDO.  /*Код шаблона КАУ*/
        DEFINE OUTPUT PARAMETER opErrChar   AS CHARACTER NO-UNDO.
        FIND FIRST ttKau WHERE ttKau.ftbName BEGINS ("ШаблКау-" + ipKauId)
                                                                                                       NO-LOCK NO-ERROR.

END PROCEDURE.

PROCEDURE CrKauTemplateFields:
        DEFINE INPUT  PARAMETER ipKauIdChar AS CHARACTER NO-UNDO.  /*Код шаблона КАУ*/
        DEFINE OUTPUT PARAMETER opErrChar   AS CHARACTER NO-UNDO.
        DEFINE BUFFER bfCode FOR code.
        opErrChar = "".
        FIND FIRST ttKau WHERE ttKau.ftbName EQ ("ШаблКау-" + ipKauId)
                                                                                    NO-LOCK NO-ERROR.
        IF NOT AVAIL ttKau THEN DO:
                FIND FIRST bfCode WHERE bfcode.class EQ "ШаблКау"
                                                                  AND bfcode.code  EQ ipKauIdChar
                                                                                                          NO-LOCK NO-ERROR.
                IF NOT AVAIL bfcode THEN RETURN.
                ipKauId = "ШаблКау-".
                CREATE ttKau.
                ASSIGN
                        ttKau.ftbName = ipKauId + ""
        END.

END PROCEDURE.
*/

/*
Сохранение номера kau вместе с идентифицирующими признаками (op.op-kind, recid(op-entry)).
Извлекается при помощи getKauDocSysConf
*/

PROCEDURE setKauDocSysConf:
   DEFINE INPUT  PARAMETER prefString AS CHARACTER NO-UNDO.  /*Префикс (op.op-kind)*/
   DEFINE INPUT  PARAMETER rid as char NO-UNDO.  /* recid(op-entry)*/
   DEFINE INPUT  PARAMETER cKau as recid NO-UNDO.  /*recid(kau)*/
   run setsysconf in h_base ("СубСчетКАУ" , prefString + ";" + string(rid) + ";" + string(ckau)).
END PROCEDURE.


/*  Находит субаналитический счет по проводке постановки и счету

*/
PROCEDURE GetKauOfDoc:
   DEFINE INPUT  PARAMETER ipOpEnRecId AS RECID     NO-UNDO. /*Проводка постановки*/
   DEFINE INPUT  PARAMETER ipAcct      AS CHARACTER NO-UNDO. /*Счет*/
   DEFINE INPUT  PARAMETER ipCurr      AS CHARACTER NO-UNDO. /*Валюта*/
   DEFINE OUTPUT PARAMETER oKauId      AS RECID     NO-UNDO. /*RECID (kau)*/
   DEFINE BUFFER bfOpentry FOR op-entry.
   DEFINE BUFFER bfKau     FOR kau.
   oKauId = 0.

   FIND bfOpentry WHERE RECID(bfOpentry) EQ ipOpEnRecId NO-LOCK NO-ERROR.
   IF AVAIL bfOpentry THEN
   FIND FIRST bfKau WHERE bfKau.acct     EQ ipAcct
                      AND bfKau.currency EQ ipCurr
                      AND bfKau.kau      EQ STRING(bfOpentry.op) + "," +
                                            STRING(bfOpentry.op-entry)
   NO-LOCK NO-ERROR.

   IF AVAIL bfKau THEN
   oKauId = RECID(bfKau).

END PROCEDURE.

/*
Извлечение номера kau по идентифицирующим признакам (op.op-kind, recid(op-entry)),
сохраненного при помощи setKauDocSysConf
*/

PROCEDURE getKauDocSysConf:
   DEFINE INPUT  PARAMETER prefString AS CHARACTER NO-UNDO.  /*Префикс (op.op-kind)*/
   def param buffer bop-entry for op-entry.
   def param buffer bkau for kau.

   def var bstr as char no-undo.
   release bkau.

   bstr = GetSysConf("СубСчетКАУ").

   if bstr = ? or num-entries(bstr,";") < 3 or entry(1, bstr,";") <> prefString then
      return.

   if recid(bop-entry) <> INT64(entry(2, bstr,";")) then
      return.
   find first bkau where recid(bkau) = INT64(entry(3, bstr,";")) no-lock no-error.
END PROCEDURE.

PROCEDURE SelectKau:
   DEFINE PARAMETER BUFFER ipBufOpKind FOR op-kind.
   DEFINE OUTPUT PARAMETER rid AS recid NO-UNDO.

   DEFINE VARIABLE in-str AS CHARACTER NO-UNDO.
   DEFINE VARIABLE out-str AS CHARACTER NO-UNDO.
   DEFINE BUFFER b_kau FOR kau.
   DEFINE BUFFER b_op-template for op-template.
   rid = ?.
   FIND FIRST b_op-template OF ipBufOpKind NO-LOCK NO-ERROR.
   in-str = GetXAttrValueEx("op-template",
                             b_op-template.op-kind + "," + STRING(b_op-template.op-template),
                             "ПроцКАУ",
                             "").
   IF in-str NE "" THEN DO TRANSACTION:
      RUN CALL-Proc(INPUT in-str,OUTPUT out-str).
   END.
   rid = INT64(out-str).
END PROCEDURE.

PROCEDURE CALL-Proc:
   DEFINE INPUT  PARAMETER in-str  AS CHARACTER NO-UNDO.
   DEFINE OUTPUT PARAMETER out-str AS CHARACTER NO-UNDO.

   DEFINE VAR l-sk                 AS INT64   NO-UNDO.
   DEFINE VAR r-sk                 AS INT64   NO-UNDO.
   DEFINE VAR name-proc            AS CHARACTER NO-UNDO.
   DEFINE VAR param-proc           AS CHARACTER NO-UNDO.
   out-str = ?.
   ASSIGN
      l-sk = INDEX(in-str,"[")
      r-sk = R-INDEX(in-str,"]")
   .
   IF l-sk NE 0 AND r-sk NE 0 THEN DO:
      ASSIGN
         name-proc  = TRIM(SUBSTRING(in-str,1,l-sk - 1))
         param-proc = TRIM(SUBSTRING(in-str,l-sk + 1,r-sk - l-sk - 1))
      .
      RUN CALL-Proc(INPUT param-proc,OUTPUT param-proc).
      IF param-proc EQ ? THEN RETURN.
      RUN REFORMAT_Proc(INPUT-OUTPUT name-proc).
      pick-value = "".
      IF SEARCH(name-proc + ".p") EQ ? AND SEARCH(name-proc + ".r") EQ ? THEN DO:
         MESSAGE "Не могу найти процедуру '" name-proc "'! " SKIP
         VIEW-AS ALERT-BOX ERROR BUTTONS OK.
      END.
      ELSE DO:
         IF NUM-ENTRIES(param-proc) EQ 1
         THEN RUN VALUE(name-proc + ".p") (TRIM(ENTRY(1,param-proc),"'~""),8).
         ELSE IF NUM-ENTRIES(param-proc) EQ 2 THEN DO:
            RUN VALUE(name-proc + ".p") (TRIM(ENTRY(1,param-proc),"'~""),
                                         TRIM(ENTRY(2,param-proc),"'~""),8).
         END.
         IF pick-value NE ? AND pick-value NE "" THEN DO:
            out-str = pick-value.
            RUN REFORMAT_Param(INPUT-OUTPUT out-str).
         END.
      END.
   END.
   ELSE out-str = in-str.
END PROCEDURE.

PROCEDURE REFORMAT_Proc:
   DEFINE INPUT-OUTPUT  PARAMETER ipProcNameChar AS CHARACTER NO-UNDO.  /**/
   IF ipProcNameChar = "ПросмотрДок" THEN
   ipProcNameChar = "kauacctv".
END PROCEDURE.

PROCEDURE REFORMAT_Param:
   DEFINE INPUT-OUTPUT  PARAMETER ipParamNameChar AS CHARACTER NO-UNDO.  /**/
   DEFINE BUFFER b_acct FOR acct.
   DEFINE BUFFER b_kau  FOR kau.

   IF ipParamNameChar BEGINS "ACCT," THEN DO:
      FIND FIRST b_acct WHERE RECID(b_acct) EQ INT64(ENTRY(2,ipParamNameChar))
                                                            NO-LOCK NO-ERROR.
      IF AVAIL b_acct THEN ipParamNameChar = b_acct.acct + "," + b_acct.currency.
   END.
   IF ipParamNameChar BEGINS "KAU," THEN DO:
      FIND FIRST b_kau WHERE RECID(b_kau) EQ INT64(ENTRY(2,ipParamNameChar))
                                                          NO-LOCK NO-ERROR.
      IF AVAIL b_kau THEN ipParamNameChar = STRING(RECID(b_kau)).
   END.
END PROCEDURE.

/* Поиск счета картотеки по балансовому счету */
PROCEDURE card-acct :
   DEFINE INPUT  PARAM iacct-id AS RECID NO-UNDO. /* балансовый счет */
   DEFINE OUTPUT PARAM oAcct-id AS RECID NO-UNDO. /* счет картотеки */
   DEFINE INPUT  PARAM iCrd     AS CHAR  NO-UNDO. /* доп.рек. Карт1/2ВнСчет */
   
   DEFINE VARIABLE acct-c     AS CHAR NO-UNDO.
   DEFINE VARIABLE currency-c AS CHAR NO-UNDO.
   DEFINE VARIABLE customer   AS INT64 NO-UNDO.
   DEFINE VARIABLE customer-category AS CHAR NO-UNDO.
   
   DEF BUFFER vacct FOR acct.  

   FIND vacct WHERE RECID(vacct) = iacct-id NO-LOCK NO-ERROR.
   
   ASSIGN
      acct-c = GetXattrValue("acct",
                             string(vacct.acct + "," + vacct.currency),
                             iCrd)
      currency-c = ?
      customer = vacct.cust-id          /* параметры текущего счета */
      customer-category = vacct.cust-cat
   .

   IF num-entries(acct-c) = 2 THEN
      ASSIGN
         currency-c = ENTRY(2,acct-c) /* валюта картотечного счета */
         acct-c     = ENTRY(1,acct-c) /* счет картотеки            */
      .
   RELEASE vacct.
   IF (acct-c NE ?) AND (acct-c NE '') THEN     /* счет картотеки задан */
      FIND FIRST vacct WHERE vacct.acct EQ acct-c    /* Поиск счета Картотеки */
                         AND (currency-c EQ ? OR vacct.currency EQ currency-c)
                         AND vacct.cust-cat EQ customer-category
                         AND vacct.cust-id EQ customer         
                NO-LOCK NO-ERROR.
                         
   oAcct-id = IF AVAIL vacct THEN RECID(vacct) ELSE ?.             
      
END PROCEDURE.
/*-поиск даты первого списания с картотеки -*/
PROCEDURE DATE-KAU:
   DEF INPUT  PARAMETER in-recid   AS RECID NO-UNDO.
   DEF INPUT  PARAMETER in-op-date AS DATE  NO-UNDO.
   DEF OUTPUT PARAMETER oResult    AS DATE  NO-UNDO.

   DEF VAR    in-op-status  AS CHARACTER NO-UNDO.
   DEF VAR    vDateBuf      AS DATE      NO-UNDO.
   DEF BUFFER buf-kau       FOR kau.
   DEF BUFFER buf-code      FOR code.
   DEF BUFFER buf1-op-entry FOR op-entry.
   DEF BUFFER buf2-op-entry FOR op-entry.

   FIND FIRST buf-kau WHERE 
              RECID(buf-kau) EQ in-recid 
              NO-LOCK NO-ERROR.
   FIND FIRST buf-code WHERE
              buf-code.class EQ "ШаблКау"
          AND buf-code.code  EQ buf-kau.kau-id 
              NO-LOCK NO-ERROR.
   in-op-status = IF     AVAIL buf-code 
                     AND NUM-ENTRIES(buf-code.misc[4]) GT 1 
                  THEN ENTRY(2,buf-code.misc[4])
                  ELSE gop-status.

   FIND FIRST buf1-op-entry WHERE
              buf1-op-entry.op       EQ INT64(ENTRY(1,buf-kau.kau))
          AND buf1-op-entry.op-entry EQ INT64(ENTRY(2,buf-kau.kau))
              NO-LOCK NO-ERROR.
   IF NOT AVAIL buf1-op-entry THEN
      RETURN.
   vDateBuf = IF     in-op-date NE ?
                 AND in-op-date GE buf1-op-entry.op-date 
              THEN in-op-date 
              ELSE buf1-op-entry.op-date
   .

   FOR 
      EACH buf2-op-entry WHERE 
           buf2-op-entry.acct-cr   EQ buf-kau.acct
       AND buf2-op-entry.op-date   LE vDateBuf
       AND buf2-op-entry.op-status GE in-op-status
       AND buf2-op-entry.currency  EQ buf-kau.currency
       AND buf2-op-entry.kau-cr    EQ buf1-op-entry.kau-db
           NO-LOCK
     BREAK BY buf2-op-entry.op-date 
   :
      IF FIRST-OF(buf2-op-entry.op-date) THEN 
         oResult = buf2-op-entry.op-date.
   END.
END PROCEDURE.
/* - поиск балансового документа и счетов дебета/кредита для внебалансового документа - */
PROCEDURE FindBalOp:
   DEF INPUT  PARAMETER in-recid   AS RECID NO-UNDO.
   DEF OUTPUT PARAMETER oResult    AS CHAR  NO-UNDO.
   DEF OUTPUT PARAMETER oAcc1      AS CHAR  NO-UNDO.
   DEF OUTPUT PARAMETER oAcc2      AS CHAR  NO-UNDO.

   DEF BUFFER buf-kop   FOR op.
   DEF BUFFER buf-bop   FOR op.
   DEF BUFFER buf-entry FOR op-entry.
   
   FIND FIRST buf-kop WHERE RECID(buf-kop) EQ in-recid NO-LOCK NO-ERROR.

   oResult = GetXattrValueEx("op",STRING(buf-kop.op),"op-bal","").
   IF oResult EQ "" THEN
      FIND FIRST buf-bop WHERE buf-bop.op-transaction EQ buf-kop.op-transaction
                           AND buf-bop.acct-cat       EQ "b"
                                                        NO-LOCK NO-ERROR.
   ELSE
      FIND FIRST buf-bop WHERE buf-bop.op EQ INT64(oResult) NO-LOCK NO-ERROR.
   IF NOT AVAIL buf-bop THEN
      ASSIGN
         oResult = "0"
         oAcc1   = ""
         oAcc2   = ""
      .
   ELSE DO:
      oResult = STRING(buf-bop.op).
      FIND FIRST buf-entry OF buf-bop NO-LOCK NO-ERROR.
      IF AVAIL buf-entry THEN
         ASSIGN
            oAcc1 = buf-entry.acct-db
            oAcc2 = buf-entry.acct-cr
         .
      ELSE
         ASSIGN
            oAcc1 = GetXAttrValueEx("op", STRING(buf-bop.op), "acctbal","")
            oAcc2 = GetXAttrValueEx("op", STRING(buf-bop.op), "acctcorr","")
         .
   END.
END PROCEDURE.

/****************************************
 Для балансового счета по acct и currency
 находит внебалансовый счет (возвращает его RECID)
 если у клиента более одного счета, то oAmbig = TRUE,
 а RECID - указатель на последний из счетов.
****************************************/
PROCEDURE GetCard2:

   DEFINE INPUT  PARAM iAcct      AS CHAR NO-UNDO. /* Счет */
   DEFINE INPUT  PARAM iCurrency  AS CHAR NO-UNDO. /* Валюта */
   DEFINE INPUT  PARAM iOpDate    AS DATE NO-UNDO. /*дата проводки*/
   DEFINE OUTPUT PARAM oRecid     AS RECID NO-UNDO. /*на внебалансовый счет*/
   DEFINE OUTPUT PARAM oAmbig     AS LOG   NO-UNDO. /*Много счетов*/

   DEFINE VAR vChkOwner AS LOGICAL         NO-UNDO.
   DEFINE VAR vChkBrnch AS LOGICAL         NO-UNDO.
   DEFINE VAR vOacct    LIKE acct.acct     NO-UNDO.
   DEFINE VAR vOcurr    LIKE acct.currency NO-UNDO.

   DEFINE BUFFER oacct FOR acct.
   
   ASSIGN
      oRecid = 0
      oAmbig = FALSE
   .
   
   FIND FIRST acct WHERE
              acct.acct EQ     iAcct
          AND iCurrency BEGINS acct.currency NO-LOCK NO-ERROR.

   IF NOT AVAIL acct THEN RETURN.

   vChkOwner = FGetSetting("СтандТр","Карт2Влад","Да") = "Да".
/* проверять принадлежность к одному подразделению бал. и карт. счетов */
   vChkBrnch = FGetSetting("СтандТр","Карт2Подр", "Нет") = "Да".

   IF CAN-DO(mAcctContCrd2,acct.contract) AND
      (NOT vChkOwner            OR
       CAN-DO(USERID('bisquit')+ "," + GetSlaves(), acct.user-id)) THEN
   DO:
      /*  вначале поищем жестко связанный счет */
      vOacct = GetXattrValue("acct",
                             acct.acct + "," + acct.currency,
                             "Карт2ВНСчет").
      IF vOacct <> ? AND vOacct <> "" THEN
      DO:      

         ASSIGN
            vOcurr = ENTRY(2,vOacct)
            vOacct = ENTRY(1,vOacct)
         .

         FIND FIRST oacct where
                    oacct.acct     = vOacct
                AND oacct.currency = vOcurr
                AND
                &IF DEFINED(USE_KAU) <> 0
                &THEN
                    oacct.contract = "Карт2"
                AND ( oAcct.kau-id   = "Карт-ка2" OR
                     (oAcct.Kau-id   <> "Карт-ка2"  AND
                      CAN-FIND(FIRST bal-acct WHERE
                                     bal-acct.bal-acct  = oAcct.bal-acct
                                 AND bal-acct.kau-id    = "Карт-ка2" )
                    ))
                AND oacct.cust-cat   EQ acct.cust-cat
                AND oacct.cust-id    EQ acct.cust-id
                AND
                &ENDIF
                &IF DEFINED(ChkDate)
                &THEN
                    oacct.open-date  LE iOpDate
                AND
                &ENDIF
                    CAN-FIND(FIRST kau WHERE
                                   kau.acct     EQ oacct.acct
                               AND kau.currency EQ oacct.currency
                               AND NOT kau.zero-bal)
         NO-LOCK NO-ERROR.
      END.
      ELSE
         FIND oacct
              WHERE oacct.contract   EQ 'Карт2'
                AND oacct.cust-cat   EQ acct.cust-cat
                AND oacct.cust-id    EQ acct.cust-id
                AND oacct.close-date EQ ?
                AND oacct.currency   EQ acct.currency
                AND
                &IF DEFINED(USE_KAU) <> 0
                &THEN
                  (  oAcct.kau-id   = "Карт-ка2" OR
                   ( oAcct.Kau-id   <> "Карт-ка2"  AND
                    CAN-FIND(FIRST bal-acct WHERE
                                   bal-acct.bal-acct  = oAcct.bal-acct
                               AND bal-acct.kau-id    = "Карт-ка2"    )
                  ))
                AND
                &ENDIF
                &IF DEFINED(ChkDate)
                &THEN
                    oacct.open-date LE iOpDate
                AND
                &ENDIF
                    CAN-FIND(FIRST kau WHERE
                                   kau.acct     EQ oacct.acct
                               AND kau.currency EQ oacct.currency
                               AND NOT kau.zero-bal)
                AND (   NOT vChkBrnch /* или не проверяем подразделение */
                     OR oacct.branch-id EQ acct.branch-id) /*или оно совпадает */
         NO-LOCK NO-ERROR.

      IF AVAIL oacct THEN
         oRecid = RECID(oacct).
      IF AMBIGUOUS oacct THEN
      DO:
         FIND LAST oacct
              WHERE oacct.contract   EQ 'Карт2'
                AND oacct.cust-cat   EQ acct.cust-cat
                AND oacct.cust-id    EQ acct.cust-id
                AND oacct.close-date EQ ?
                AND oacct.currency   EQ acct.currency
                AND
                &IF DEFINED(USE_KAU) <> 0
                &THEN
                  (  oAcct.kau-id   = "Карт-ка2" OR
                   ( oAcct.Kau-id   <> "Карт-ка2"  AND
                    CAN-FIND(FIRST bal-acct WHERE
                                   bal-acct.bal-acct  = oAcct.bal-acct
                               AND bal-acct.kau-id    = "Карт-ка2"    )
                  ))
                AND
                &ENDIF
                &IF DEFINED(ChkDate)
                &THEN
                    oacct.open-date LE iOpDate
                AND
                &ENDIF
                    CAN-FIND(FIRST kau WHERE
                                   kau.acct     EQ oacct.acct
                               AND kau.currency EQ oacct.currency
                               AND NOT kau.zero-bal)
                AND (   NOT vChkBrnch /* или не проверяем подразделение */
                     OR oacct.branch-id EQ acct.branch-id) /*или оно совпадает */
         NO-LOCK NO-ERROR.
         ASSIGN
            oAmbig = TRUE
            oRecid = RECID(oacct)
         .
      END.
      IF AVAIL oacct THEN
         RETURN 'У  клиента счета ' + iAcct + '/' + iCurrency +
                ' есть картотека!'.
   END.

   RETURN.   /* Обнуляет содержимое return-value */

END PROCEDURE.

&ENDIF
/* $LINTUSER='BIS' */
/* $LINTENV ='energo' */
/* $LINTVSS ='$/ws3-dpl/energo/bq/' */
/* $LINTDATE='27/02/2015 16:51:57.444+04:00' */
/* $LINTFILE='kautools.lib' */
/*prosignINXRExI1+zkd6TVhekjE7Q*/