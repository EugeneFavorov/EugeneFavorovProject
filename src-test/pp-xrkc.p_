/*
               Банковская интегрированная система БИСквит
    Copyright: (C) 1992-2017 ЗАО "Банковские информационные системы"
     Filename: pp-xrkc.p
      Comment: Выполняет импорт одного файла в формате XML
               Является методом "Import" класса "ExchXML" и унаследованных
               от него.
   Parameters: iClass
               iInstance
         Uses:
   Parameters: NO parametrs
   Procedures:
         XRKCInstanceCreate
         XRKCPacketCheck
         XRKCPacketEnd
         XRKCPacketEndStatus
         XRKCRunOpKind

         RKCPacketOur
         RKCGetRecvID
         RKCGetSendID
      Used BY:
      Created: 31.04.2005 NIK
     Modified: 20.10.2005 NIK Позиционирование после удаления буферов
     Modified: 26.04.2006 NIK PROGRESS v10.
     Modified: 04.05.2006 NIK Удаление экземпляров в
                              XRKCPacketCheck и XRKCPacketEnd.
     Modified: 17/05/2006 NIK Реструктуризация pp-pack.p
     Modified: 23/05/2006 NIK Импорт одиночных платежей
     Modified: 24/05/2006 NIK Управление контролем EDDate
                              Импорт ED207, ED209
     Modified: 27/06/2006 NIK Получение правильного номера Сообщения
     Modified: 19/07/2006 NIK Использование ExchOpenQuery
                              Использование собственного буфера
     Modified: 17/08/2006 NIK Импорт полноформатных и неполноформатных
                              документов в одном пакете.
     Modified: 25/09/2006 MUTA 0064461  Вывод предупреждения для сообщений
                               с датой, отличной от даты опердня
     Modified: 15.01.2007 NIK Пополнение корсчета/кассы
     Modified: 17.01.2007 NIK Квитование почтовых документов
     Modified: 24.06.2008 MUTA 0093494  БЭСП. Сохранение сообщения импорта ED207 
     Modified:
*/

{globals.i}

{form.def}
{g-trans.equ}
{exchange.equ}

{intrface.get strng}
{intrface.get xclass}

{intrface.get tmess}
{intrface.get pbase}
{intrface.get trans}

{intrface.get exch}
{intrface.get pack}
{intrface.get rfrnc}
{intrface.get wchck}

{intrface.get bank}

{pfuncdef  
&DefLib="xrkc"
&Description="Библиотека функций обмена документами c РКЦ по формату XML"}


DEFINE VAR mBankAcct     AS CHAR              NO-UNDO.
DEFINE VAR mBankCode     AS CHAR              NO-UNDO.
DEFINE VAR mContrAcct    AS CHAR              NO-UNDO.
DEFINE VAR mOpDate       AS DATE              NO-UNDO.
DEFINE VAR mFake         AS INT64             NO-UNDO.
DEFINE VAR mClsChkDate   AS CHAR              NO-UNDO.
DEFINE VAR mExchMsg      AS CHAR              NO-UNDO.
DEFINE VAR mSetDiffAcct  AS LOGICAL           NO-UNDO.
DEFINE VAR mSetStmtAcct  AS LOGICAL           NO-UNDO.

ASSIGN
   mBankAcct   = FGetSetting("БалСчИНН",?,?)
   mContrAcct  = FGetSetting("НазнСчМБР",?,?)
   mBankCode   = FGetSetting("БанкМФО",?,?)
   mClsChkDate = "ExchRKC"
   mExchMsg    = TRNSettingValue("","CodeEXCHMSG","EXCH-MSG")
   mSetDiffAcct = FGetSetting("УФЭБС","CheckDiffAcct","Нет") EQ "Да"
   mSetStmtAcct = FGetSetting("УФЭБС","CheckStmtAcct","Нет") EQ "Да"
.

RUN ParsFunc-Дата IN h_pbase (OUTPUT mOpDate, OUTPUT mFake).

{xrkc.def}
FUNCTION RKCPacketOur LOGICAL (INPUT hPack AS handle) forward.
FUNCTION RKCGetSendID CHAR                            forward.
FUNCTION RKCGetRecvID CHAR                            forward.
/*----------------------------------------------------------------------------*/
/*  Создает очередной экземпляр WOP                                           */
/*                                                                            */
/* iClass   - класс XML принимаемого сообщения (поле EXCH-MSG.Code)           */
/* iInsnace - сущность, соответствующая указанному классу (EXCH-MSG.Misc[1])  */
/* Процедура обычно является методом CREATE класcа iFormat                    */
/*----------------------------------------------------------------------------*/
PROCEDURE XRKCInstanceCreate:
   DEFINE INPUT PARAMETER iFormat   AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iInstance AS handle   NO-UNDO.

   DEFINE VAR vFlagSet  AS LOGICAL  INIT ?   NO-UNDO.
   DEFINE VAR hWOPKeep  AS handle            NO-UNDO.
   DEFINE VAR hWOPWork  AS handle            NO-UNDO.
   DEFINE VAR vSeanceID AS INT64           NO-UNDO.
   DEFINE VAR vOpKind   AS CHAR              NO-UNDO.
   DEFINE BUFFER Seance FOR Seance.

   {profile XR001}

MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      ASSIGN
         hWOPWork  = iInstance:default-buffer-handle
         vSeanceID = hWOPWork:buffer-field("SeanceID"):buffer-value
      NO-ERROR. {&ON-ERROR}

      CREATE BUFFER hWOPKeep FOR TABLE hWOPWork.

      RUN InstanceCreate (hWOPKeep,hWOPWork).

      ASSIGN
         hWOPWork:buffer-field("mail-format"):buffer-value = iFormat
      NO-ERROR. {&ON-ERROR}
      {profile XR005}
      vOpKind = GetEXCHOpKind(vSeanceID,{&DIR-IMPORT}, BUFFER mail-user).
      {profile XR006}
      ASSIGN
         hWOPWork:buffer-field("op-kind"):buffer-value     = vOpKind
      NO-ERROR. {&ON-ERROR}

      IF NOT {assigned vOpKind} THEN DO:
         FIND FIRST Seance WHERE Seance.SeanceID EQ vSeanceID NO-LOCK NO-ERROR.
         {&ON-ERROR}
         RUN Fill-SysMes("","ExchRKC21","","%s=" + Seance.Op-Kind +
                                           "%s=" + iFormat).
      END.

      vFlagSet = YES.
   END.

   IF valid-handle(hWOPKeep) THEN DELETE object hWOPKeep.
   {profile XR010}
   {doreturn.i vFlagSet}
END PROCEDURE.

PROCEDURE XRKCInstanceCreate243:
   DEFINE INPUT PARAMETER iFormat   AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iInstance AS handle   NO-UNDO.

   DEFINE VAR vFlagSet  AS LOGICAL  INIT ?   NO-UNDO.
   DEFINE VAR hWOPKeep  AS handle            NO-UNDO.
   DEFINE VAR hWOPWork  AS handle            NO-UNDO.
   DEFINE VAR hExchRKCDoc AS handle            NO-UNDO.


   DEFINE VAR vSeanceID AS INT64           NO-UNDO.
   DEFINE VAR vOpKind   AS CHAR              NO-UNDO.
   DEFINE BUFFER Seance FOR Seance.

   {profile XR001}

MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      ASSIGN
         hWOPWork  = iInstance:default-buffer-handle
         vSeanceID = hWOPWork:buffer-field("SeanceID"):buffer-value
      NO-ERROR. {&ON-ERROR}

      CREATE BUFFER hWOPKeep FOR TABLE hWOPWork.

      RUN InstanceCreate (hWOPKeep,hWOPWork).

      ASSIGN
         hWOPWork:buffer-field("mail-format"):buffer-value = iFormat
      NO-ERROR. {&ON-ERROR}
      {profile XR005}
      vOpKind = GetEXCHOpKind(vSeanceID,{&DIR-IMPORT}, BUFFER mail-user).
      {profile XR006}
      ASSIGN
         hWOPWork:buffer-field("op-kind"):buffer-value     = vOpKind
      NO-ERROR. {&ON-ERROR}

      IF NOT {assigned vOpKind} THEN DO:
         FIND FIRST Seance WHERE Seance.SeanceID EQ vSeanceID NO-LOCK NO-ERROR.
         {&ON-ERROR}
         RUN Fill-SysMes("","ExchRKC21","","%s=" + Seance.Op-Kind +
                                           "%s=" + iFormat).
      END.

      hExchRKCDoc = ObjectValueHandle("ExchRKCDoc")
      NO-ERROR. {&ON-ERROR}
      RUN InstanceCreateEx(?, hExchRKCDoc, 0).


      vFlagSet = YES.
   END.

   IF valid-handle(hWOPKeep) THEN DELETE object hWOPKeep.
   {profile XR010}
   {doreturn.i vFlagSet}
END PROCEDURE.

/*----------------------------------------------------------------------------*/
/* Создает копию WOP с текущего экземпляра                                    */
/*----------------------------------------------------------------------------*/
PROCEDURE XRKCServiceCreate:
   DEFINE INPUT PARAMETER iFormat   AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iInstance AS handle   NO-UNDO.

   DEFINE VAR vFlagSet  AS LOGICAL  INIT ?   NO-UNDO.
   DEFINE VAR hExch     AS handle            NO-UNDO.
   DEFINE VAR v__ID     AS INT64           NO-UNDO.
   {profile XR011}
MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      ASSIGN
         hExch  = iInstance:default-buffer-handle
         v__ID  = hExch:buffer-field("__ID"):buffer-value
      NO-ERROR. {&ON-ERROR}

      RUN InstanceCreateEx (?, hExch, v__ID).

      ASSIGN
         hExch:buffer-field("__UpId"):buffer-value      = v__ID
         hExch:buffer-field("mail-format"):buffer-value = iFormat
      NO-ERROR. {&ON-ERROR}

      vFlagSet = YES.
   END.
   {profile XR020}
   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Удаляет текущий экземпляр. Позиционируется на предыдущий экземпляр         */
/*----------------------------------------------------------------------------*/
PROCEDURE XRKCServiceDelete:
   DEFINE INPUT PARAMETER iClass    AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iInstance AS handle   NO-UNDO.

   DEFINE VAR vFlagSet  AS LOGICAL INIT ? NO-UNDO.
   DEFINE VAR hExch     AS handle         NO-UNDO.
   DEFINE VAR v__ID     AS INT64        NO-UNDO.
   DEFINE VAR hMain     AS handle         NO-UNDO.
   DEFINE VAR vPacketID AS INT64        NO-UNDO.
   DEFINE VAR vMain     AS CHAR           NO-UNDO.

   {profile XR021}
MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      ASSIGN
         hExch  = iInstance:default-buffer-handle
         v__ID  = hExch:buffer-field("__UpID"):buffer-value
      NO-ERROR. {&ON-ERROR}

      IF iClass EQ "XML-ED207BSP" AND NOT CAN-DO(TRNSettingValue("","MessagesNoSave",""),"ED207") THEN DO:

         ASSIGN
            vMain = hExch:buffer-field("ExchMain"):BUFFER-VALUE
            hMain = ObjectValueHandle(vMain)     
            vPacketID   = hMain:buffer-field("PacketID"):BUFFER-VALUE       
         NO-ERROR. {&ON-ERROR}

         RUN PacketBSPTextSave(vPacketID).

      END.

      RUN InstanceJunk (hExch, v__ID).

      vFlagSet = YES.
   END.
   {profile XR030}
   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Заглушка для пропуска необрабатываемых сообщений                           */
/*                                                                            */
/* iFormat  - формат XML принимаемого сообщения (поле EXCH-MSG.Code)          */
/* iInsnace - сущность, соответствующая указанному классу (EXCH-MSG.Misc[1])  */
/* Процедура обычно является методом INITIAL класcа iFormat                   */
/*----------------------------------------------------------------------------*/
PROCEDURE XRKCPacketSkip:
   DEFINE INPUT PARAMETER iFormat   AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iInstance AS handle   NO-UNDO.
   {profile XR031}
   RUN Fill-SysMes("","ComnExc61","","%s=" + GetNullStr(iFormat)).
   {profile XR040}
   RETURN "SKIP".
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Проверяет корректность принятого пакета                                    */
/*                                                                            */
/* iFormat  - формат XML принимаемого сообщения (поле EXCH-MSG.Code)          */
/* iInsnace - сущность, соответствующая указанному классу (EXCH-MSG.Misc[1])  */
/* Процедура обычно является методом INITIAL класcа iFormat                   */
/*----------------------------------------------------------------------------*/
PROCEDURE XRKCPacketCheck:
   DEFINE INPUT PARAMETER iFormat   AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iInstance AS handle   NO-UNDO.

   DEFINE VAR vFlagSet  AS LOGICAL INIT ?    NO-UNDO.
   DEFINE VAR hWOP      AS handle            NO-UNDO.

   DEFINE VAR vSendID      AS CHAR     NO-UNDO.
   DEFINE VAR vSendDate    AS DATE     NO-UNDO.
   DEFINE VAR vSendREF     AS INT64  NO-UNDO.
   DEFINE VAR vSendCls     AS CHAR     NO-UNDO.
   DEFINE VAR vPacketID    AS INT64  NO-UNDO.
   DEFINE VAR vRetValue    AS CHAR     NO-UNDO.
   DEFINE VAR vCancel      AS LOGICAL  NO-UNDO INITIAL YES.
   DEFINE VAR vErrorClass  AS CHAR     NO-UNDO.
   DEFINE VAR vErrorList   AS CHAR     NO-UNDO.
   DEFINE VAR hMain        AS handle   NO-UNDO.
   DEFINE VAR vMain        AS CHAR     NO-UNDO.


   &IF DEFINED(IS-DEBUG) &THEN
   RUN dbgprint.p ("XRKCPacketCheck","START.     iClass:" + iFormat +
                                           " Inst.TABLE:" + iInstance:Name).
   &ENDIF
   {profile XR041}
MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      ASSIGN
         mExchMsg    = TRNSettingValue("","CodeEXCHMSG","EXCH-MSG")
         hWOP        = iInstance:default-buffer-handle
         vSendID     = hWOP:buffer-field("SendID"):buffer-value
         vSendDate   = hWOP:buffer-field("SendDate"):buffer-value
         vSendREF    = hWOP:buffer-field("SendREF"):buffer-value
         hWOP:buffer-field("mail-format"):buffer-value = iFormat
         vSendCls    = GetCodeMisc(mExchMsg,iFormat,{&RKC-REPLY})
         vErrorClass = hWOP:buffer-field("ErrorClass"):buffer-value
      NO-ERROR. {&ON-ERROR}

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("XRKCFileEnd","mSetDiffAcct:" + STRING(mSetDiffAcct)).
      RUN dbgprint.p ("XRKCFileEnd","mSetStmtAcct:" + STRING(mSetStmtAcct)).
      &ENDIF

      IF iFormat BEGINS "XML-ED"  
      THEN DO:
         ASSIGN
            vMain       = hWop:buffer-field("ExchMain"):BUFFER-VALUE
            hMain       = ObjectValueHandle(vMain)
            vPacketID   = hMain:buffer-field("PacketID"):BUFFER-VALUE
         NO-ERROR.

         IF mSetDiffAcct THEN DO:
            RUN chdfacct.p (INPUT vPacketID, OUTPUT vCancel).
            IF vCancel THEN DO:
               ASSIGN
                  vRetValue = "SKIP"
                  vFlagSet  = YES.
               LEAVE MAIN.
            END.
         END.

         IF mSetStmtAcct THEN DO:
            RUN chstacct.p (INPUT vPacketID, OUTPUT vCancel).
            IF vCancel THEN DO:
               ASSIGN
                  vRetValue = "SKIP"
                  vFlagSet  = YES.
               LEAVE MAIN.
            END.
         END.
      END.


      RUN ParsFunc-Дата (OUTPUT mOpDate, OUTPUT mFake) NO-ERROR.
      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("XRKCPacketCheck"," Class:" + iInstance:Name        +
                                      " iFormat:" + GetNullStr(iFormat)   +
                                      " vSendID:" + GetNullStr(vSendID)   +
                                    " vSendDate:" + GetNullDat(vSendDate) +
                                     " vSendREF:" + GetNullInt(vSendREF)  +
                                     " vSendCls:" + GetNullStr(vSendCLS)).
      RUN DumpObject(hWOP).
      &ENDIF

/*------------------------------------------- Сообщение предназначено нам ? --*/
      IF NOT RKCPacketOur(hWOP) THEN DO:
         vRetValue = "SKIP".
         vFlagSet  = YES.
         LEAVE MAIN.
      END.

/*--------------------------------------- Сообщение имеет корректную дату ? --*/
      IF LOOKUP(iInstance:Name,mClsChkDate) GT 0       AND
         vSendDate                          NE mOpDate THEN DO:

         vCancel = YES.

         IF auto NE YES THEN
            RUN xrkc-date-req.p(INPUT hWOP,
                                INPUT vSendDate,
                                INPUT gend-date,
                                INPUT-OUTPUT vCancel).

         IF vCancel EQ YES THEN DO:
            RUN Fill-SysMes("","ExchRKC30","",
                            "%s=" + iFormat               +
                            "%s=" + GetNullInt(vSendRef)  +
                            "%s=" + GetNullDat(vSendDate) +
                            "%s=" + GetNullDat(gend-date)).
            vRetValue = "SKIP".
            vFlagSet  = YES.
            LEAVE MAIN.
         END.
      END.

/*------------------------------------------ Сообщение было принято ранее ? --*/
      IF PacketExist (INPUT  vSendDate,
                      INPUT  vSendCls,
                      INPUT  vSendID  + "|" +
                             ReferenceFormatValue(vSendCls,string(vSendREF)),
                      OUTPUT vPacketID)                  THEN DO:
         &IF DEFINED(IS-DEBUG) &THEN
         RUN dbgprint.p ("XRKCPacketCheck","vPacketID:" + string(vPacketID)).
         &ENDIF

         IF NOT (fGetSetting("УФЭБС","ДублЭСИД","NO") EQ "YES" AND
                 ((iFormat BEGINS "XML-ED201") OR 
                  (iFormat BEGINS "XML-ED205") OR 
                  (iFormat BEGINS "XML-ED206")) 
                 ) THEN DO:

            RUN Fill-SysMes("","ExchRKC02","","%s=" + iFormat               +
                                              "%s=" + GetNullStr(vSendID)   +
                                              "%i=" + GetNullInt(vSendREF)  +
                                              "%s=" + GetNullDat(vSendDate) +
                                              "%i=" + GetNullInt(vPacketID)).

            vErrorList =  (IF vErrorClass EQ "ErrorRKC"
                              THEN "doc71"
                              ELSE "b8070")  + CHR(1) +
                          "Сообщение "       + iFormat                      +
                          "("                + GetNullStr(vSendID)          +
                          "|"                + GetNullInt(vSendREF)   + ")" +
                          " от "             + GetNullDat(vSendDate)        +
                          " уже принято."    +
                          " Идентификатор в базе " + GetNullInt(vPacketID).

            ASSIGN
               vMain = hWop:buffer-field("ExchMain"):BUFFER-VALUE
               hMain = ObjectValueHandle(vMain)
               vPacketID   = hMain:buffer-field("PacketID"):BUFFER-VALUE
            NO-ERROR. {&ON-ERROR}

            FIND FIRST Packet WHERE Packet.PacketID EQ vPacketID
               EXCLUSIVE-LOCK NO-WAIT NO-ERROR.

            IF AVAIL Packet THEN
               ASSIGN
                  Packet.State         = {&STATE-ERR}
                  Packet.ClassError    = vErrorClass
                  Packet.PackError     = vErrorList     
                  Packet.mail-format   = hWop:buffer-field("mail-format"):BUFFER-VALUE
               .
            FIND FIRST Packet WHERE Packet.PacketID EQ vPacketID
               NO-LOCK NO-ERROR.
            vRetValue = "SKIP".
            vFlagSet  = YES.
            LEAVE MAIN.

         END.  /* ДублЭСИД */

      END.

      vRetValue = "".
      vFlagSet  = YES.
   END.

   IF vRetValue EQ "SKIP" AND INDEX(hWOP:Name,"PART") EQ 0 THEN DO:
      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("XRKCPacketCheck","Delete:" + hWOP:Name +
                                            " - " + GetNullStr(hWOP:buffer-field("__ID"):buffer-value)).
      &ENDIF
      hWOP:buffer-delete()               NO-ERROR.
      hWOP:find-first("WHERE __ID EQ 0") NO-ERROR.
   END.

   &IF DEFINED(IS-DEBUG) &THEN
   RUN dbgprint.p ("XRKCPacketCheck","vFlagSet:" + string(vFlagSet)).
   &ENDIF
   {profile XR050}
   {doreturn.i vFlagSet vRetValue}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Завершить прием пакета документов                                          */
/* Является методом, вызываемым из I-XMLONE.P                                 */
/* Параметры:                                                                 */
/*   iFormat   - класс XML (XML-PacketEPD или XML-PacketESID)                 */
/*   iInstance - объект класса, унаследованного от ExchRKC                    */
/*----------------------------------------------------------------------------*/
PROCEDURE XRKCPacketEnd:
   DEFINE INPUT PARAMETER iFormat   AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iInstance AS handle   NO-UNDO.

   DEFINE VAR vFlagSet  AS LOGICAL INIT ?    NO-UNDO.
   DEFINE VAR hExch     AS handle            NO-UNDO.

   DEFINE BUFFER bigPacket FOR Packet.

   DEFINE VAR vPacketID AS INT64  NO-UNDO.
   DEFINE VAR vSendID   AS CHAR     NO-UNDO.
   DEFINE VAR vSendDate AS DATE     NO-UNDO.
   DEFINE VAR vSendREF  AS INT64  NO-UNDO.
   DEFINE VAR vSendCls  AS CHAR     NO-UNDO.
   DEFINE VAR vRowID    AS ROWID    NO-UNDO.
   {profile XR051}
MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("XRKCPacketEnd","START. iClass:" + iFormat +
                                             " TABLE:" + iInstance:Name).
      &ENDIF

      ASSIGN
         hExch     = iInstance:default-buffer-handle
         vRowID    = hExch:rowid
         vSendID   = hExch:buffer-field("SendID"):buffer-value
         vSendDate = hExch:buffer-field("SendDate"):buffer-value
         vSendREF  = hExch:buffer-field("SendREF"):buffer-value
         vPacketID = hExch:buffer-field("PacketID"):buffer-value
         vSendCls  = GetCodeMisc(mExchMsg,iFormat,{&RKC-REPLY})
      NO-ERROR. {&ON-ERROR}

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("XRKCPacketEnd","vSendID:" + GetNullStr(vSendID)           +
                                   " vSendDate:" + GetNullStr(string(vSendDate)) +
                                    " vSendREF:" + GetNullStr(string(vSendREF))  +
                                   " vPacketID:" + GetNullStr(string(vPacketID)) +
                                    " vSendCls:" + GetNullStr(vSendCls)).
      &ENDIF

      RUN XRKCRunOpKind ("ExchRKCDoc").          /* Создать все документы     */
      RUN XRKCRunOpKind ("ExchRKCSrv").          /* Обработать все служебные  */

BIG:
      DO TRANSACTION ON ERROR UNDO BIG, RETRY BIG:
         IF RETRY THEN UNDO MAIN, RETRY MAIN.
         FIND FIRST bigPacket WHERE
                    bigPacket.PacketID EQ vPacketID
                    EXCLUSIVE-LOCK NO-ERROR no-wait.
         IF NOT AVAILABLE(bigPacket) THEN DO:
            vFlagSet = NO.
            LEAVE MAIN.
         END.
                                                 /* Класс сообщения           */
         ASSIGN bigPacket.mail-format = iFormat.

         UpdateSigns ("Packet", STRING(vPacketID), "SessionID", hExch::SessionID, ?).

/*----------------------------------------------- Создать уникальную ссылку --*/
         RUN PacketCreateRef (INPUT vSendDate,
                              INPUT vPacketID,
                              INPUT vSendCls,
                              INPUT vSendID + "|" +
                                    ReferenceFormatValue(vSendCls,
                                                         string(vSendREF))) NO-ERROR.
         IF ERROR-STATUS:ERROR THEN UNDO BIG, RETRY BIG.

/*------------------------------- Установить статус охватывающему сообщению --*/
         RUN XRKCPacketEndStatus (vPacketID).

      END.

      hExch:find-by-rowid(vRowID)          NO-ERROR. {&ON-ERROR}
      hExch:buffer-delete()                NO-ERROR. {&ON-ERROR}
      hExch:find-first("where __ID EQ 0")  NO-ERROR. {&ON-ERROR}

      vFlagSet = YES.
   END.
   {profile XR060}
   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Завершить прием файла документов                                           */
/* Является методом, вызываемым вместо I-XMLONE.P, если документы приходят    */
/* по одному файле, без охватывающего пакета                                  */
/* Параметры:                                                                 */
/*   iFormat   - класс XML (XML-PacketEPD или XML-PacketESID)                 */
/*   iInstance - объект класса, унаследованного от ExchRKC                    */
/*----------------------------------------------------------------------------*/
PROCEDURE XRKCFileEnd:
   DEFINE INPUT PARAMETER iFormat   AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iInstance AS handle   NO-UNDO.

   DEFINE VAR vFlagSet  AS LOGICAL INIT ?   NO-UNDO.
   DEFINE VAR vPacketID AS INT64 INIT ?     NO-UNDO.

   {profile XR061}
MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      ASSIGN
         iInstance = iInstance:default-buffer-handle
         vPacketID = iInstance:buffer-field("PacketID"):buffer-value
      NO-ERROR. {&ON-ERROR}

/*--------------------------------------- Вызвать процедуру обработки файла --*/
      RUN i-xmlone.p    (iInstance:Name, iInstance:table-handle).

/*------------------------------------------- Выполнить создание документов --*/

      IF iInstance:Name BEGINS "ExchRKC" OR
         iInstance:Name BEGINS "ExchBSP" THEN DO:
         RUN XRKCRunOpKind ("ExchRKCDoc").       /* Создать все документы     */
         RUN XRKCRunOpKind ("ExchRKCSrv").       /* Обработать все служебные  */
      END.

      FIND FIRST Packet WHERE Packet.PacketID EQ vPacketID NO-LOCK NO-ERROR.
      IF AVAIL Packet
         AND Packet.State NE {&STATE-ERR} THEN DO:
         RUN PacketSetState(vPacketID,{&STATE-IMP}).
      END.

      vFlagSet = YES.
   END.
   {profile XR070}
   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Выполнить контроль корреспонденции неполнформатных документов              */
/* Является методом, вызываемым из I-XMLONE.P                                 */
/* Параметры:                                                                 */
/*   iFormat   - класс XML (XML-PacketEPD или XML-PacketESID)                 */
/*   iInstance - объект класса, унаследованного от ExchRKCDoc                 */
/*----------------------------------------------------------------------------*/
PROCEDURE XRKCImportED110:
   DEFINE INPUT PARAMETER iFormat   AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iInstance AS handle   NO-UNDO.

   DEFINE VAR vFlagSet  AS LOGICAL INIT ?    NO-UNDO.
   DEFINE VAR hWOP      AS handle            NO-UNDO.
   DEFINE VAR vDocType  AS CHAR              NO-UNDO.
   DEFINE VAR vBankSnd  AS CHAR              NO-UNDO.
   DEFINE VAR vBankRec  AS CHAR              NO-UNDO.
   DEFINE VAR vType     AS CHAR              NO-UNDO.

MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      ASSIGN
         hWOP     = iInstance:default-buffer-handle

         vDocType = TRIM(hWOP:buffer-field("doc-type"):buffer-value)
         vBankSnd = TRIM(hWOP:buffer-field("bank-code-send"):buffer-value)
         vBankRec = TRIM(hWOP:buffer-field("bank-code-rec"):buffer-value)
         vType    = TRIM(hWOP:buffer-field("type"):buffer-value)
      NO-ERROR. {&ON-ERROR}

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("XRKCImportED110","1 vDocType:" + GetNullStr(vDocType) +
                                         " vBankSnd:" + GetNullStr(vBankSnd) +
                                         " vBankRec:" + GetNullStr(vBankRec) +
                                            " vType:" + GetNullStr(vType)).
      &ENDIF

      CASE vDocType:
/*--------------------------------------- Подкрепление корсчета через кассу --*/
         WHEN "04" THEN DO:
            ASSIGN
               hWOP:buffer-field("acct-send-out"):buffer-value       =
                              hWOP:buffer-field("acct-rec"):buffer-value
               hWOP:buffer-field("bank-code-rec"):buffer-value       = ""
               hWOP:buffer-field("bank-corr-acct-rec"):buffer-value  = ""
               hWOP:buffer-field("acct-rec"):buffer-value            = ""
            NO-ERROR. {&ON-ERROR}
         END.
/*------------------------------------------- Подкрепление кассы с корсчета --*/
         WHEN "03" THEN DO:
            ASSIGN
               hWOP:buffer-field("acct-rec"):buffer-value            =
                              hWOP:buffer-field("acct-send-out"):buffer-value
               hWOP:buffer-field("bank-code-send"):buffer-value      = ""
               hWOP:buffer-field("bank-corr-acct-send"):buffer-value = ""
               hWOP:buffer-field("acct-send-out"):buffer-value       = ""
               hWOP:buffer-field("AcctDbPos"):buffer-value           = YES
            NO-ERROR. {&ON-ERROR}
         END.
         OTHERWISE DO:
/*----------------------------- Начальный почтовый или телеграфный документ --*/
            &IF DEFINED (IS-DEBUG) &THEN
               RUN dbgprint.p ("XRKCImportED110","vBankSnd:" + GetNullStr(vBankSnd) + 
                                               " mBankCode:" + GetNullStr(mBankCode) +
                                                   " vType:" + GetNullStr(vType)).    
            &ENDIF
            IF vBankSnd EQ mBankCode   AND
               (GetCodeMisc ("Маршруты",vType,7) EQ "2"   OR
                GetCodeMisc ("Маршруты",vType,7) EQ "3")  THEN DO:
               RUN XRKCRestoreED110(iFormat, hWOP).

               vFlagSet = YES.
               LEAVE MAIN.
            END.
         END.
      END CASE.

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("XRKCImportED110","10 AFTER CORRECT").
      RUN DumpObject (hWOP).
      &ENDIF
      vFlagSet = YES.
   END.

   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Выполнить квитование почтового/телеграфного документа                      */
/*----------------------------------------------------------------------------*/
PROCEDURE XRKCRestoreED110:
   DEFINE INPUT  PARAMETER iFormat  AS CHAR     NO-UNDO.
   DEFINE INPUT  PARAMETER hWOP     AS handle   NO-UNDO.

   DEFINE BUFFER bCode     FOR Code.
   DEFINE BUFFER c-nostro  FOR c-nostro.
   DEFINE VAR vFlagSet  AS LOGICAL INIT ?    NO-UNDO.
   DEFINE VAR hBIG      AS HANDLE            NO-UNDO.
   DEFINE VAR vSendREF  AS CHAR              NO-UNDO.
   DEFINE VAR vSendID   AS CHAR              NO-UNDO.
   DEFINE VAR vAcctDB   AS CHAR              NO-UNDO.
   DEFINE VAR vAcctCR   AS CHAR              NO-UNDO.
   DEFINE VAR vDocNum   AS CHAR              NO-UNDO.
   DEFINE VAR vAmtRub   AS DECIMAL           NO-UNDO.
   DEFINE VAR vMCnt     AS INT64           NO-UNDO.
   DEFINE VAR vMOp      AS INT64           NO-UNDO.
   DEFINE VAR vMEntry   AS INT64           NO-UNDO.
   DEFINE VAR vParentID AS INT64           NO-UNDO.
   DEFINE VAR vSeanceID AS INT64           NO-UNDO.
   DEFINE VAR vMailID   AS INT64           NO-UNDO.
   DEFINE VAR vPacketID AS INT64           NO-UNDO.

MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      ASSIGN
         vAcctDB     = TRIM(hWOP:buffer-field("acct-send-out"):buffer-value)
         vAcctCR     = OURBankACCT()
         vDocNum     = TRIM(hWOP:buffer-field("doc-num"):buffer-value)
         vAmtRub     = hWOP:buffer-field("amt-rub"):buffer-value

         vSendREF    = hWOP:buffer-field("SendREF"):buffer-value
         vSendID     = hWOP:buffer-field("SendID"):buffer-value
         vMCnt       = 0

         hBIG        = ObjectValueHandle(hWOP:buffer-field("ExchMain"):buffer-value)
         vSeanceID   = hBIG:buffer-field("SeanceID"):buffer-value
         vParentID   = hBIG:buffer-field("PacketID"):buffer-value
         vMailID     = hBIG:buffer-field("mail-user-num"):buffer-value
      NO-ERROR. {&ON-ERROR}

      FOR FIRST c-nostro WHERE
                c-nostro.corr-acct EQ vAcctCR
                NO-LOCK:
         vAcctCR = c-nostro.acct.
      END.

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("XRKCRestoreED110","1 mOpDate:" + GetNullDat(mOpDate)   +
                                          " vAcctDB:" + GetNullStr(vAcctDB)   +
                                          " vAcctCR:" + GetNullStr(vAcctCR)   +
                                          " vAmtRub:" + GetNullNum(vAmtRub)   +
                                          " vDocNum:" + GetNullStr(vDocNum)   +
                                        " vSeanceID:" + GetNullInt(vSeanceID) +
                                        " vParentID:" + GetNullInt(vParentID) +
                                          " vMailID:" + GetNullInt(vMailID)   +
                                         " vSendREF:" + GetNullStr(vSendREF)).
      RUN DumpObject(hWOP).
      &ENDIF

      FOR EACH op-entry WHERE
               op-entry.op-date EQ mOpDate
           AND op-entry.acct-db EQ vAcctDB
           AND op-entry.acct-cr EQ vAcctCR
           AND op-entry.amt-rub EQ vAmtRub
               NO-LOCK,
         FIRST op OF op-entry
               NO-LOCK:

         &IF DEFINED(IS-DEBUG) &THEN
         RUN dbgprint.p ("XRKCRestoreED110","2 op.doc-num:" + GetNullStr(op.doc-num)).
         &ENDIF

         IF r-index(op.doc-num,vDocNum) EQ (length(op.doc-num) - length(vDocNum) + 1) THEN ASSIGN
            vMCnt   = vMCnt + 1
            vMOp    = op.op
            vMEntry = op-entry.op-entry
         .
      END.

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("XRKCRestoreED110","3 vMCnt:" + GetNullInt(vMCnt) +
                                           " vMOp:" + GetNullInt(vMOp)).
      &ENDIF

      CASE vMCnt:
         WHEN 0 THEN.
         WHEN 1 THEN DO:

            IF NOT EXCH-MSGBuff(iFormat, BUFFER bCode) THEN
               UNDO MAIN, RETRY MAIN.
BIND:
            DO TRANSACTION ON ERROR UNDO BIND, RETRY BIND:
               IF RETRY THEN UNDO MAIN, RETRY MAIN.

               {pack-crt.i
                  &Packet     = Packet
                  &PacketID   = vPacketID
                  &SeanceID   = vSeanceID
                  &AbonentID  = -1
                  &MailUserID = vMailID
                  &State      = "{&STATE-FIN}"
                  &Kind       = bCode.Misc[{&RKC-KIND}]
                  &Format     = iFormat
                  &ClassCode  = bCode.Misc[{&RKC-CLASS}]
                  &ParentID   = vParentID
               }

               RUN PacketCreateLink (vPacketID,
                                     "op-entry",
                                     string(vMOp) + "," + string(vMEntry),
                                     ENTRY(1,bCode.Description[1])).

               RUN PacketCreateRef  (mOpDate,
                                     vPacketID,
                                     bCode.Misc[{&RKC-REPLY}],
                                     vSendID + "|" +
                                     ReferenceFormatValue(bCode.Misc[{&RKC-REPLY}],
                                                          vSendREF)).

               RUN InstanceJunk(hWOP, 0).
            END.
         END.
         OTHERWISE
            RUN Fill-SysMes ("","ExchRKC46","",
                             "%s=" + GetNullStr(vDocNum)  +
                             "%s=" + GetNullStr(vSendREF) +
                             "%s=" + GetNullDat(mOpDate)  +
                             "%s=" + GetNullStr(vAcctDB)  +
                             "%s=" + GetNullStr(vAcctCR)  +
                             "%s=" + GetNullNum(vAmtRub)  +
                             "%s=" + GetNullInt(vMCnt)).
      END CASE.

      vFlagSet = YES.
   END.

   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Изменить статус охватывающего пакета                                       */
/*----------------------------------------------------------------------------*/
PROCEDURE XRKCPacketEndStatus:
   DEFINE INPUT PARAMETER iPacketID AS INT64 NO-UNDO.

   DEFINE BUFFER smlPacket FOR Packet.
   DEFINE BUFFER bigPacket FOR Packet.

   DEFINE VAR vFlagSet  AS LOGICAL INIT ?    NO-UNDO.
   DEFINE VAR vState    AS CHAR              NO-UNDO.
   {profile XR071}
MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      vState = "".
STT:
      FOR EACH smlPacket WHERE
               smlPacket.ParentID EQ iPacketID
               NO-LOCK
         break BY smlPacket.State:

         IF first-of(smlPacket.State) THEN DO:

            &IF DEFINED(IS-DEBUG) &THEN
            RUN dbgprint.p ("RKCPacketEndStatus","smlPacket.State:" + smlPacket.State +
                                                         " vState:" + GetNullStr(vState)).
            &ENDIF

            IF NOT {assigned vState} THEN
               vState = smlPacket.State.
            ELSE IF vState NE smlPacket.State THEN DO:
               vState = "".       /* Статусы вложенных сообщений отличаются   */
               LEAVE STT.
            END.
         END.
      END.                                       /* FOR EACH smlPacket WHERE  */

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("RKCPacketEndStatus","vState:" + GetNullStr(vState)).
      &ENDIF

      IF {assigned vState}       AND
         vState NE {&STATE-ERR}  THEN
         RUN PacketSetState (iPacketID, vState).

      vFlagSet = YES.
   END.
   {profile XR080}
   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Вызов создающих транзакций.                                                */
/* Параметры:                                                                 */
/*    iClass      - класс объекта                                             */
/*----------------------------------------------------------------------------*/
PROCEDURE XRKCRunOpKind:
   DEFINE INPUT PARAMETER iClass    AS CHAR     NO-UNDO.

   DEFINE VAR vFlagSet  AS LOGICAL  INIT ?   NO-UNDO.
   DEFINE VAR hQuery    AS handle            NO-UNDO.
   DEFINE VAR hExch     AS handle            NO-UNDO.
   DEFINE VAR hKeep     AS handle            NO-UNDO.
   DEFINE VAR vOpKind   AS CHAR              NO-UNDO.
   DEFINE VAR vExKind   AS CHAR              NO-UNDO.
   DEFINE VAR vTable    AS CHAR              NO-UNDO.
   DEFINE VAR vFirst    AS CHAR              NO-UNDO.
   DEFINE VAR vPrepare  AS CHAR              NO-UNDO.

   DEFINE VAR vDocNum   AS CHAR     NO-UNDO.
   DEFINE VAR vDocDate  AS DATE     NO-UNDO.
   DEFINE VAR vAmtRub   AS DECIMAL  NO-UNDO.
   DEFINE VAR vDocType  AS CHAR     NO-UNDO.
   DEFINE VAR vDocForm  AS CHAR     NO-UNDO.
   DEFINE VAR vAcctRecv AS CHAR     NO-UNDO.
   DEFINE VAR vAcctSend AS CHAR     NO-UNDO.
   {profile XR081}
/*============================================================================*/
MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      ASSIGN
         hExch  = ObjectValueHandle(iClass)

         vTable = hExch:Name
         vFirst = vTable + ".op-kind"
      NO-ERROR. {&ON-ERROR}

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("XRKCRunOpKind","iClass:" + GetNullStr(iClass) +
                                     " vTable:" + GetNullStr(vTable)).
      &ENDIF

      CREATE BUFFER hKeep FOR TABLE hExch.
      CASE ExchQueryOpen(INPUT  hKeep,
                         INPUT  "for EACH " + vTable + " WHERE "        +
                                              vTable + ".__id GT 0 "    +
                                    " AND " + vTable + ".op-kind NE ''" +
                                     " BY " + vFirst,
                         OUTPUT hQuery):
         WHEN ?   THEN UNDO MAIN, RETRY MAIN.
         WHEN NO  THEN DO:
            vFlagSet = YES.
            LEAVE MAIN.
         END.
         WHEN YES THEN.
      END CASE.

      vOpKind = ?.
WORK:
      DO WHILE NOT hQuery:query-off-end:
         ASSIGN vExKind = hKeep:buffer-field("op-kind"):buffer-value NO-ERROR.

         &IF DEFINED(IS-DEBUG) &THEN
         RUN dbgprint.p ("XRKCRunOpKind"," __id:" + GetNullStr(hKeep:buffer-field("__id"):buffer-value) +
                                      " op-kind:" + GetNullStr(vExKind)).
         &ENDIF

         IF {assigned vExKind}         AND
            vExKind NE GetBaseOpKind() THEN DO:

            IF vExKind NE vOpKind THEN DO:
               vOpKind = vExKind.
               RUN RunTransaction (vOpKind) NO-ERROR.
               {&ON-ERROR}
            END.
         END.

         hQuery:get-next(NO-LOCK)  NO-ERROR.
      END.
      hQuery:query-close().

/*------------------------------- Протоколирование необработанных сообщений --*/
      ASSIGN
         vFlagSet = hQuery:query-prepare("for EACH " + vTable + " WHERE "    +
                                                       vTable + ".__id NE 0" +
                                             " AND " + vTable + ".__id NE ?")
                AND hQuery:query-open()
      NO-ERROR.
      IF ERROR-STATUS:ERROR OR vFlagSet NE YES THEN UNDO MAIN,  RETRY MAIN.

      ASSIGN vFlagSet = hQuery:get-first(NO-LOCK) NO-ERROR. {&ON-ERROR}
      IF vFlagSet NE YES THEN DO:
         vFlagSet = YES.
         LEAVE MAIN.
      END.
      vFlagSet = ?.

      RUN Fill-SysMes ("","ExchRKC22","","%s=" + vTable +
                                         "%s=" + GetBaseOpKind()).
      DO WHILE NOT hQuery:query-off-end:
         ASSIGN
            vDocNum   = hKeep:buffer-field("doc-num"):buffer-value
            vDocDate  = hKeep:buffer-field("op-date"):buffer-value
            vAmtRub   = hKeep:buffer-field("amt-rub"):buffer-value
            vDocType  = hKeep:buffer-field("doc-type"):buffer-value
            vDocForm  = hKeep:buffer-field("mail-format"):buffer-value
            vAcctSend = hKeep:buffer-field("acct-send"):buffer-value
            vAcctRecv = hKeep:buffer-field("acct-rec"):buffer-value
         NO-ERROR.

         RUN Fill-SysMes("","ExchRKC23","",
                         "%s=" + string(vDocForm,"x(12)")          +
                         "%s=" + string(vDocNum,"x(7)")            +
                         "%s=" + string(vDocDate,"99/99/9999")     +
                         "%s=" + string(vDocType,"x(3)")           +
                         "%s=" + string(vAcctSend,"x(20)")         +
                         "%s=" + string(vAcctRecv,"x(20)")         +
                         "%s=" + string(vAmtRub,"->>>>,>>>,>>9.99")).
         hKeep:buffer-delete().
         hQuery:get-next().
      END.

      vFlagSet = YES.
   END.

   IF valid-handle(hQuery) THEN DELETE object hQuery.
   IF valid-handle(hKeep)  THEN DELETE object hKeep.

   hExch:find-first("where __id = 0") NO-ERROR.
   {profile XR090}
   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Выполнить контроль корреспонденции мемориальных ордеров                    */
/* Является методом, вызываемым из I-XMLONE.P                                 */
/* Параметры:                                                                 */
/*   iFormat   - класс XML (XML-PacketEPD или XML-PacketESID)                 */
/*   iInstance - объект класса, унаследованного от ExchRKCDoc                 */
/*----------------------------------------------------------------------------*/
PROCEDURE XRKCImportED111:
   DEFINE INPUT PARAMETER iFormat   AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iInstance AS handle   NO-UNDO.

   DEFINE VAR vFlagSet              AS LOGICAL INIT ?    NO-UNDO.
   DEFINE VAR hWOP                  AS handle            NO-UNDO.
   DEFINE VAR vBankSnd              AS CHAR              NO-UNDO.
   DEFINE VAR vBankRec              AS CHAR              NO-UNDO.
   DEFINE VAR vOpKind               AS CHAR              NO-UNDO.
   DEFINE VAR vSETClass             AS CHAR              NO-UNDO.
   DEFINE VAR vAcctUnkSnd           AS CHAR              NO-UNDO.
   DEFINE VAR vAcctUnkRec           AS CHAR              NO-UNDO.
   DEFINE VAR vBefFndOAcctS         AS CHAR              NO-UNDO.
   DEFINE VAR vAcctDb               AS CHAR              NO-UNDO.
   DEFINE VAR vAcctCr               AS CHAR              NO-UNDO.
   DEFINE VAR vBefFndOAcct          AS LOGICAL           NO-UNDO.

MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      ASSIGN
         hWOP          = iInstance:default-buffer-handle
                       
         vBankSnd      = TRIM(hWOP:buffer-field("bank-code-send"):buffer-value)
         vBankRec      = TRIM(hWOP:buffer-field("bank-code-rec"):buffer-value)
         vOpKind       = GetBaseOpKind()
         vSETClass     = GetXAttrValue("op-kind",vOpKind,"SETClass")
         vBefFndOAcctS = TRNSettingValue(vSETClass,"BefFindingOutAcct","НЕТ")
         vBefFndOAcct  = vBefFndOAcctS EQ "ДА" OR vBefFndOAcctS EQ "YES"
      NO-ERROR. {&ON-ERROR}
/*
      vAcctUnkSnd
 */
      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("XRKCImportED111","1 vBankSnd:"     + GetNullStr(vBankSnd)    +
                                         " vBankRec:"     + GetNullStr(vBankRec)    +
                                         " vBefFndOAcct:" + STRING(vBefFndOAcct)    +
                                         " vAcctUnkSnd:"  + GetNullStr(vAcctUnkSnd) +
                                         " vAcctUnkRec:"  + GetNullStr(vAcctUnkRec)
                                         ).
      &ENDIF



/*------------------------------------- Начальный документ -------------------*/
      IF vBankSnd EQ mBankCode THEN DO:
   
         vAcctDb =  hWOP:buffer-field("acct-send"):buffer-value.
         IF vBefFndOAcct THEN
            RUN PrepareAcctUnk(INPUT  SUBSTRING(vAcctDb,1,5),
                               INPUT  "Спис",
                               INPUT  "",
                               OUTPUT vAcctDb).
         ASSIGN 
            hWOP:buffer-field("acct-db"):buffer-value = vAcctDb
            hWOP:buffer-field("order-pay"):buffer-value  = "5"
         NO-ERROR. {&ON-ERROR}
      END.
/*------------------------------------- Ответный документ --------------------*/
      ELSE DO:
         vAcctCr =  hWOP:buffer-field("acct-rec"):buffer-value.
         IF vBefFndOAcct THEN
            RUN PrepareAcctUnk(INPUT  SUBSTRING(vAcctcr,1,5),
                               INPUT  "Пост",
                               INPUT  "",
                               OUTPUT vAcctCr).
         ASSIGN 
            hWOP:buffer-field("acct-cr"):buffer-value = vAcctCr
            hWOP:buffer-field("order-pay"):buffer-value  = "5"
         NO-ERROR. {&ON-ERROR}
      END.

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("XRKCImportED111","10 AFTER CORRECT").
      RUN DumpObject (hWOP).
      &ENDIF
      vFlagSet = YES.
   END.

   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Сообщение предназначено нам ?                                              */
/*----------------------------------------------------------------------------*/
FUNCTION RKCPacketOur LOGICAL (INPUT hExch AS handle):

   DEFINE VAR vRecvID   AS CHAR     NO-UNDO.
   DEFINE VAR vFileID   AS INT64  NO-UNDO.
   DEFINE VAR vPath     AS CHAR     NO-UNDO.

   DEFINE VAR vOur      AS LOGICAL  NO-UNDO.
   {profile XR091}
MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      ASSIGN
         vRecvID = hExch:buffer-field("RecvID"):buffer-value
         vFileID = hExch:buffer-field("FileExchID"):buffer-value
      NO-ERROR. {&ON-ERROR}
/*подмена БИК*/
      IF {assigned vRecvID} AND vRecvID eq "4599350000" THEN
	vRecvID = "4525129000".
/*подмена БИК*/
      IF {assigned vRecvID}        AND
         vRecvID NE RKCGetSendID() THEN DO:      /* Чужое сообщение           */
         vPath = "Не определен".
         FOR FIRST FileExch WHERE
                   FileExch.FileExchID EQ vFileID
                   NO-LOCK:
            vPath = FileExch.Path.
         END.
         RUN Fill-SysMes("","ExchRKC03","","%s=" + vPath          +
                                           "%s=" + vRecvID        +
                                           "%s=" + RKCGetSendID()).
         vOur = NO.
      END.
      ELSE
         vOur = YES.
   END.
   {profile XR100}
   RETURN vOur.
END FUNCTION.
/*----------------------------------------------------------------------------*/
/* Возвращает идентификатор РКЦ                                               */
/*----------------------------------------------------------------------------*/
FUNCTION RKCGetRecvID CHAR:
   DEFINE BUFFER banks FOR banks.
   {profile XR101}
   {getbank.i banks mBankCode 'МФО-9'}
   IF NOT AVAILABLE(banks) THEN DO:
      RUN Fill-SysMes("","ExchRKC04","","%s=МФО-9" + "%s=" + mBankCode).
      RETURN ?.
   END.
   IF NOT GetCorrRKC(BUFFER banks, BUFFER banks-corr) THEN DO:
      RUN Fill-SysMes("","ExchRKC05","","%s=" + banks.name).
      RETURN ?.
   END.

   FIND FIRST banks WHERE banks.bank-id EQ banks-corr.bank-id NO-LOCK NO-ERROR.
   {getcode.i banks МФО-9}
   IF NOT AVAILABLE(banks-code) THEN DO:
      RUN Fill-SysMes("","ExchRKC06","","%s=" + banks.name +
                                        "%s=" + "МФО-9").
      RETURN ?.
   END.
   {profile XR110}
   RETURN SUBSTRING(banks-code.bank-code,3,7) + "000".
END FUNCTION.
/*----------------------------------------------------------------------------*/
/* Возвращает идентификатор нашего банка                                      */
/*----------------------------------------------------------------------------*/
FUNCTION RKCGetSendID CHAR:
   RETURN SUBSTRING(mBankCode,3,7) + "000".
END FUNCTION.
/******************************************************************************/
/* $LINTENV ='1ut' */
/* $LINTVSS ='$/ws2-tst/bq/' */
/* $LINTDATE='21/12/2015 12:43:49.795+04:00' */
/* $LINTUSER='mike' */
/* $LINTMODE='1' */
/* $LINTFILE='pp-xrkc.p' */
/*prosign8MivlB1w2p2LNrXb4nnm5A*/