 /*
               Банковская интегрированная система БИСквит
    Copyright: (C) 1992-2004 ТОО "Банковские информационные системы"
     Filename: G-PFUNC.DEF
      Comment: (0033033) Сделана разводка на
               использование ряда процедур модуля КиД
               новым парсером.
   Parameters:
         Uses:
      Used by:
     Modified: 24.08.2004 19:16 KSV      (0033033) Сделана разводка на
                                         использование ряда процедур модуля КиД
                                         новым парсером.
     Modified: 29.09.2004 18:15 SAP
     Modified: 10.12.2004 16:34 Koag
     Modified: 15.12.2004 17:23 Koag
     Modified: 16.12.2004 15:09 Koag
     Modified: 31.03.2005 13:17 laav     (42861) Добавлен парсер СчетДох
     Modified: 30.01.2006 18:15 ZIAL     (37171) Парсерная функция ГрРиска()
                                         недоступна для расчета суммы шаблонов
                                         транзакций
     Modified: 14.03.2006 13:17 fEAk     Процедуры БазаНалог, БазаНалогД и ПереРасчБазаНалог
                                         были перенесены dpspars.p
     Modified: 31.08.2006 19:00 ZIAL     (47943) КиД: учет средств перечисленных в
                                         оплату в день выставления требования по %%
     Modified: 19/02/2007 kraw (0062107) ДБ и КР читаются из документов с нулевой суммой (т. е. у удаленных)
     Modified: 09/03/2007 kraw (0055582) СуммаБесплРасх
     Modified: 24.10.2007 MUTA  0082119  Добавлена функция КолНаДату
     Modified: 06.12.2007 jadv  0082485  Добавлена функция РольБал
     Modified: 22/02/2008 kraw (0088004) ИнфоКлиент, ТипСч
     Modified: 08.04.2008 MUTA 0090931 Доработка инструмента acct-qty.
     Modified: 09/04/2008 kraw (0091007) В ИнфоКлиент значение ИННв
     Modified: 23/05/2008 kraw (0049823) РЕЗИДЕНТ
     Modified: 01.02.2010 10:59 ksv      (0122687) Доработана ф-ция Вопрос
     Modified: 15/07/2010 kraw (0122236) ПервыйМО
     Modified: 08/12/2010 ches (0135430) ReFindLoan Попытка найти loan если LOAN_VALID_HANDLE невалидный
                                         ТипКлДог
     Modified: 24/01/2011 kraw (0134154) в "формат" обработка "дата" и "строка"
     Modified: 18/11/2012 ccc  (0182524) поправлена функция ПарныйСч()
     Modified: 26/11/2013 sasa (0196467) Подъем заявки 0164875
     Modified: 26/11/2015 gsbis исправлена процедура СуммаЭ, восстановлена корректность работы при нулевом значении.

*/

/*

  Если Вы решили расширить функциональность парсера, то найдите в  конце этого
  файла процедуру с именем "ПустойШаблон" и комментарием перед ним. Скопируйте
  и то, и другое и пишите себе на здоровье,  но не забудьте прокомментировать,
  что функция делает и как ее вызывать.
                                                                Peter I. Bach.

*/
DEFINE TEMP-TABLE ttParsOld  NO-UNDO
   FIELD id    AS INTEGER
   FIELD fChar AS CHARACTER
   FIELD fDec  AS DECIMAL
INDEX id IS PRIMARY UNIQUE id.
DEFINE VARIABLE mpjOld         AS INT64         NO-UNDO.
DEFINE VARIABLE mpnOld         AS INT64         NO-UNDO.
DEFINE VARIABLE mtCurOld       AS CHARACTER     NO-UNDO.
DEFINE VARIABLE mSerOld        AS CHARACTER     NO-UNDO.
DEFINE VARIABLE vKeepAnswer    AS CHARACTER     NO-UNDO. /* Для сохраненения последнего ответа на функцию Вопрос */

{intrface.get ovl}
{intrface.get prsfn}
{intrface.get db2l}     /* Инструмент для динамической работы с БД. */
{intrface.get date}     /* Инструменты для работы с датами. */
{intrface.get limit}
{intrface.get trans}
{intrface.get strng}
{intrface.get oldpr}
{intrface.get tmess}
{minimpor.i}
{typeclentbyacct.i}
{oldprdt.i}

&IF DEFINED(NEW_PARSER) &THEN
DEFINE VARIABLE pj         AS INT64 INIT 2       NO-UNDO.
DEFINE VARIABLE pn         AS INT64 INIT 1       NO-UNDO.
DEFINE VARIABLE mvar       AS CHARACTER EXTENT 10  NO-UNDO.
DEFINE VARIABLE result_l   AS DECIMAL   EXTENT 10  NO-UNDO.
{def-wf.i}

&IF DEFINED(PLOAN_LIB) &THEN
/*------------------------------------------------------------------------------
  Purpose:     Заглушка эмулирующая передачу идентификатора договора в парсерную
               функцию для нового парсера
  Parameters:  pH - возвращается хэндл текущей процедуры
  Notes:
------------------------------------------------------------------------------*/
PROCEDURE LOAN_VALID_HANDLE:
   DEFINE INPUT-OUTPUT PARAMETER pH AS HANDLE     NO-UNDO.
   pH = THIS-PROCEDURE.
END PROCEDURE.

&ENDIF
&ENDIF

DEFINE VARIABLE old-val     AS DECIMAL NO-UNDO.

&IF DEFINED(NEW_PARSER) = 0 &THEN
def buffer xacct1 for acct.
def buffer xacct2 for acct.

/* Поиск код национальной валюты */
DEFINE VARIABLE vNatCurrChar AS CHARACTER  NO-UNDO.
vNatCurrChar = FGetSetting("КодНацВал", ?, "{&in-NC-Code}").

{loan_sn.i} /* Процедуры разбора private-data по модулям:
            ** - "Кредиты и Депозиты",
            ** - "Частные вклады" */
{par_mass.i} /* Необходимо для кредитного модуля */
{repinfo.i}
{intrface.get xclass}
{intrface.get instrum}
{intrface.get comm}  /* Загрузка инструментов для роаботы с комиссиями. */
{intrface.get loan}  /* Инструменты по кредитам */
{intrface.get lv}
{intrface.get i254}
{intrface.get tmess}    /* Инструменты обработки сообщений. */
{intrface.get pint}
{intrface.get cust}
{intrface.get tparam}
{intrface.get sessions}
{intrface.get vok}
{intrface.get blkob}
{intrface.get data}
{pqvrn.fun}
{acct.pro}           /* Убрать, если будет грузиться интерефейс acct */
{loan.pro}
{savepars.i}

/* Функция запуска процедуры */
&ENDIF

/* Функция проверки числа параметров */

FUNCTION Pars-ValidParam RETURN LOGICAL (INPUT InCount AS INT64):
    &IF DEFINED(NEW_PARSER) &THEN
    RETURN YES.
    &ELSE
    {&type-er} = "".
    IF pn <> InCount THEN DO:
        {&type-er} = {&EGMBadParamCount}.
        RETURN FALSE.
    END.
    ELSE DO:
        pn = pn - 1.
        RETURN TRUE.
    END.
    &ENDIF
END FUNCTION.


/* Функция перепоиска Loan */

FUNCTION ReFindLoan RETURN RECID (
OUTPUT oGlc AS CHARACTER ,
OUTPUT oGl  AS CHARACTER ) :

DEF BUFFER loan FOR loan.

   ASSIGN
      oGlc = Get_Loan_contr()
      oGl  = Get_Loan()
   NO-ERROR.

   FIND FIRST loan WHERE loan.contract  EQ oGlc
                     AND loan.cont-code EQ oGl
                     NO-LOCK NO-ERROR.
   IF  AVAILABLE loan
     THEN RETURN RECID (loan) .
     ELSE RETURN ? .
END FUNCTION. /* ReFindLoan */


/*

  Следующие 4 функции можно ипользовать тогда, когда Вы не знаете и не хотите
  знать организацию стека, способ передачи параметров и возврат значения в
  парсере, но все это, наверное, замедляет обработку

*/

/* Получить строковый параметр */

FUNCTION Pars-GetString RETURN CHAR (INPUT InParamNum AS INT64):
    RETURN (IF mvar[pj - pn + InParamNum] EQ "" THEN STRING(result_l[pj - pn + InParamNum]) ELSE TRIM(mvar[pj - pn + InParamNum], """'")).
END.

FUNCTION Pars-GetStringFormatted RETURN CHAR (INPUT InParamNum AS INT64, INPUT ipFormat AS CHAR):
    RETURN (IF mvar[pj - pn + InParamNum] EQ "" THEN STRING(result_l[pj - pn + InParamNum], ipFormat) ELSE TRIM(mvar[pj - pn + InParamNum], """'")).
END.

/* Получить вещественный параметр */

FUNCTION Pars-GetDec RETURN DECIMAL (INPUT InParamNum AS INT64):
    RETURN DEC(result_l[pj - pn + InParamNum]).
END.

/* Получить целочисленный параметр */

FUNCTION Pars-GetInt RETURN INT64 (INPUT InParamNum AS INT64):
    RETURN INT64(result_l[pj - pn + InParamNum]).
END.

/* Возвратить результат (всегда число, но не строка) */

PROCEDURE Pars-SetResult:
    DEF INPUT PARAM Result AS DECIMAL NO-UNDO.
    ASSIGN
        result_l[pj - pn] = Result
        mvar[pj - pn]     = ""
    .
END.

PROCEDURE Pars-SetCHARResult:
    DEF INPUT PARAM Result AS CHARACTER NO-UNDO.
    mvar[pj - pn]     = RESULT.
    result_l[pj - pn] = dec(mvar[pj - pn]) NO-ERROR.
    IF ERROR-STATUS:ERROR
    THEN ASSIGN
        result_l[pj - pn]  = 0
        ERROR-STATUS:ERROR = NO
     .
END.

FUNCTION Pars-CheckDecResult RETURNS DECIMAL (INPUT iValue AS CHARACTER).

   DEFINE VARIABLE vResAct AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE vResDec AS DECIMAL     NO-UNDO.

   vResAct = iValue.
   IF shMode AND NUM-ENTRIES(iValue,"@") EQ 2 THEN
      IF ENTRY(2,iValue,"@") EQ shFilial THEN
         vResAct = DelFilFromAcct (iValue).

   vResDec = DECIMAL (vResAct) NO-ERROR.
   IF ERROR-STATUS:ERROR THEN
      ASSIGN
         vResDec = 0
         ERROR-STATUS:ERROR = NO.

   RETURN vResDec.
END FUNCTION.

PROCEDURE Pars-SetACCTResult:
    DEF INPUT PARAM Result AS CHARACTER NO-UNDO.

    mvar[pj - pn]     = Result.
    result_l[pj - pn] = Pars-CheckDecResult (Result).

END PROCEDURE.

PROCEDURE pMakeSummFormat:
   DEFINE INPUT  PARAMETER iEqu    AS LOGICAL    NO-UNDO. /* Как выводить */
   DEFINE INPUT  PARAMETER iSum    AS DECIMAL    NO-UNDO. /* Что выводить */
   DEFINE INPUT  PARAMETER iFormat AS CHARACTER  NO-UNDO. /* В каком формате выводить*/

   DEFINE VARIABLE mDec AS CHARACTER  NO-UNDO.

   IF iEqu AND iSum EQ TRUNC (iSum,0) THEN DO:
      mDec = STRING(iSum,iFormat) + "=" NO-ERROR.
      IF ERROR-STATUS:GET-MESSAGE(1) NE "" THEN
         mDec = STRING(iSum) + "=".
   END.
   ELSE DO:
      mDec = STRING(TRUNC(iSum,0),iFormat) + "-" +
                  STRING((iSum - TRUNC(iSum,0)) * 100,"99") NO-ERROR.
      IF ERROR-STATUS:GET-MESSAGE(1) NE "" THEN
         mDec = STRING (TRUNC(iSum,0)) + "-" +
                STRING ((iSum - TRUNC(iSum,0)) * 100,"99").
   END.
   RUN Pars-SetCHARresult(mDec).
END PROCEDURE.

&IF DEFINED(NEW_PARSER) = 0 &THEN

/*
  Что делает: Переводит Значение в строку с форматом Формат.
  Синтаксис : Формат(Значение,Формат,[Тип значения])

  По умолчанию Значение имеет числовой тип, при необходимости используя необязатальный
  параметр Тип значения его можно сменить:
  Тип значения может иметь следующие значения:
  - дата
  - строка
  Кроме стандартных строк форматов допускаются для форматирования чисел следующие
  специальные форматы:

  хх= если значение - целое число, то в виде xx=
                    - дробное число, то в виде xx-xx
  хх-хх значение в виде xx-xx
  При этом будет произведено форматирование целой части
  в соответствии с передаваемым форматом. При возникновении ошибка целая часть
  будет выведена  "как есть"
*/

PROCEDURE Формат:
   DEFINE OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE mValue  AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE mType   AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE mFormat AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE mBefZer AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE mMsg    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE mErr    AS LOGICAL    NO-UNDO.

   IF NOT (   pn EQ 2
           OR pn EQ 3) THEN
      RETURN.
   ASSIGN
      pn      = pn - 1
      mValue  = Pars-GetString(0)
      mType   = IF pn EQ 2
                THEN ( IF Pars-GetString(2) EQ "строка"
                       THEN "string"
                       ELSE "date" )
                ELSE "decimal"
      mFormat = Pars-GetString(1)
   .
   IF     mType EQ "decimal"             /* в случае форматирования числа в формате ЦБ*/
      AND (   INDEX(mFormat,"=") GT 0
           OR INDEX(mFormat,"-") GT 0) THEN DO:
      mBefZer = IF INDEX(mFormat,"=") GT 0  /* формат целой части*/
                THEN SUBSTRING(mFormat,1,INDEX(mFormat,"=") - 1)
                ELSE SUBSTRING(mFormat,1,INDEX(mFormat,"-") - 1).
      RUN pMakeSummFormat(IF TRIM(mFormat,"=") NE mFormat
                          THEN YES
                          ELSE NO,DECIMAL(mValue),mBefZer).
   END.
   ELSE DO:
      RUN SetValue IN h_base(INPUT-OUTPUT mValue,
                             mType,
                             mFormat,
                             INPUT-OUTPUT mMsg,
                             OUTPUT mErr).
      IF mErr THEN DO:
         MESSAGE mMsg
            VIEW-AS ALERT-BOX ERROR BUTTONS OK.
         RETURN.
      END.
      RUN Pars-SetCHARResult (mValue).
   END.

   is-ok = true.
END PROCEDURE.

/*
  Что делает: Сумма заданной проводки.
  Синтаксис : Сумма(Номер_Проводки) или Сумма(БД) или Сумма(БК)

*/

PROCEDURE Сумма:
   DEFINE OUTPUT PARAM is-ok AS LOGICAL NO-UNDO.

   DEFINE VARIABLE vResult AS DECIMAL NO-UNDO.
   DEFINE VARIABLE vTag    AS CHARACTER  NO-UNDO.

   IF NOT (Pars-ValidParam(1)) THEN RETURN.

   vTag = Pars-GetString(0).

   CASE vTag:
      WHEN "БД" THEN
         ASSIGN
            vResult = remove-amt
            tcur    = bcur-db.
      WHEN "БК" THEN
         ASSIGN
            vResult = send-amt
            tcur    = bcur-cr.

      WHEN "Э" THEN
      DO:
         RUN internal-parser-getdetails-form-ttable (?,"", "amt-cur", OUTPUT vTag).
         vResult = DEC (vTag).
      END.
      OTHERWISE DO:
         FIND FIRST xwop WHERE xwop.op-templ = INT64(vTag) NO-LOCK NO-ERROR.
         IF NOT AVAIL xwop
            THEN
               ASSIGN 
                  vResult = 0.
            ELSE
               ASSIGN
                  vResult = IF xwop.amt-cur = ? THEN 0 ELSE xwop.amt-cur
                  tcur    = xwop.currency.
      END.
   END CASE.

   ASSIGN
      result_l[pj] = vResult
      mvar[pj]     = ""
   .
   is-ok = TRUE.
END PROCEDURE.

/*
**    Что делает: Производит рассчет комисии.
**    Синтаксис : Ком(<база начисления>,
                      <код комиссии>,
                      <cчет>,
                      <валюта>,
                      [<период>],
                      [<тип даты>],
                      [<вид результата>],
                      [<филиал>])

   <вид результата> : %= - возвращается либо фикс.сумма либо % * Сумма
                       = - возвращает комиссию в случае фикс. ставки иначе 0
                       % - возвращает комиссию в случае % ставки иначе 0
                     ТИП - возвращает тип комиссии % или =
                     СТВ - возвращает либо фикс сумму либо %

*/
PROCEDURE Ком:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   IF NOT (Pars-ValidParam(4) OR
           Pars-ValidParam(5) OR
           Pars-ValidParam(6) OR
           Pars-ValidParam(7) OR
           Pars-ValidParam(8) OR
           Pars-ValidParam(9)
           )
      THEN RETURN.

   DEFINE VARIABLE vSumm     AS DECIMAL   NO-UNDO. /* База начисления. */
   DEFINE VARIABLE vCommName AS CHARACTER NO-UNDO. /* Код вида комиссии. */
   DEFINE VARIABLE vAcct     AS CHARACTER NO-UNDO. /* Счет. */
   DEFINE VARIABLE vCurrency AS CHARACTER NO-UNDO. /* Валюта. */
   DEFINE VARIABLE vPeriod   AS INT64     NO-UNDO. /* период нахождения остатка */
   DEFINE VARIABLE vDate     AS DATE      NO-UNDO. /* дата, на которую рассчитывается коммиссия */
   DEFINE VARIABLE vResType  AS CHARACTER NO-UNDO. /* тип результата */
   DEFINE VARIABLE vFilialId AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vBranchId AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vResult   AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE vD        AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE vS        AS CHARACTER NO-UNDO.

   DEF BUFFER op         FOR op.          /* Локализация буфера. */
   DEF BUFFER commission FOR commission.  /* Локализация буфера. */
   DEF BUFFER acct       FOR acct.        /* Локализация буфера. */

   ASSIGN
      vSumm     = result_l[pj - pn]
      vCommName = Pars-GetString ( 1 )
      vAcct     = Pars-GetString ( 2 )
      vCurrency = Pars-GetStringFormatted ( 3 , "999" )
      vCurrency = (IF vCurrency EQ vNatCurrChar THEN "" ELSE vCurrency)
      vPeriod   = (IF pn GE 4  THEN  Pars-GetDec(4)  ELSE 0)
      vDate     = (IF     pn EQ 5
                      AND Pars-GetString(5) NE ?
                   THEN DATE(Pars-GetString(5))
                   ELSE in-op-date)
      vResType  = (IF pn GE 6
                   THEN Pars-GetString(6)
                   ELSE '%=')
      vFilialId = (IF pn GE 7
                   THEN Pars-GetString(7)
                   ELSE ShFilial)
      vBranchId = (IF pn GE 8
                   THEN Pars-GetString(8)
                   ELSE "")
   .
   IF vResType = "" OR vResType = ? THEN vResType = '%=' .
   /* получение описания комиссии (pp-comm, comm.pro) */
   RUN GetCommDesc IN h_comm (vCommName, vAcct, vCurrency, vSumm, "",vPeriod, vDate, vFilialId, vBranchID, BUFFER comm-rate) NO-ERROR.
   IF ERROR-STATUS:ERROR THEN DO:
      RUN Fill-SysMes IN h_tmess ("", "", "-1", RETURN-VALUE).
      RETURN.
   END.

   CASE vResType:
      WHEN "%="  THEN
         vResult = IF AVAILABLE comm-rate THEN
                       (IF comm-rate.rate-fixed THEN
                            comm-rate.rate-comm
                        ELSE
                            comm-rate.rate-comm * vSumm / 100)
                   ELSE
                       0.
      WHEN "="   THEN
         vResult = IF AVAILABLE comm-rate THEN
                       (IF comm-rate.rate-fixed THEN
                            comm-rate.rate-comm
                        ELSE
                            0)
                   ELSE
                       0.
      WHEN "%"   THEN
         vResult = IF AVAILABLE comm-rate THEN
                       (IF comm-rate.rate-fixed THEN
                            0
                        ELSE
                            comm-rate.rate-comm * vSumm / 100)
                   ELSE
                       0.
      WHEN "ТИП" THEN
         RUN Pars-SetCHARResult(IF AVAILABLE comm-rate
                                THEN (IF comm-rate.rate-fixed
                                      THEN  "="
                                      ELSE "%"
                                     )
                                ELSE "%="
                                ).
      WHEN "СТВ"  THEN
         vResult = IF AVAILABLE comm-rate THEN
                       comm-rate.rate-comm
                   ELSE
                       0.
   END CASE.

   IF vResType <> "ТИП" THEN DO:
       IF AVAILABLE comm-rate THEN DO:
           vS = GetXAttrValueEx("comm-rate",
                                STRING(comm-rate.comm-rate-id),
                                "МинЗнач",
                                "").
           IF {assigned vS} THEN DO:
               vD = DECIMAL(vS) NO-ERROR.
               IF NOT (vD = ? OR ERROR-STATUS:ERROR) THEN
                   vResult = MAXIMUM(vResult, vD).
           END.
           vS = GetXAttrValueEx("comm-rate",
                                STRING(comm-rate.comm-rate-id),
                                "МаксЗнач",
                                "").
           IF {assigned vS} THEN DO:
               vD = DECIMAL(vS) NO-ERROR.
               IF NOT (vD = ? OR ERROR-STATUS:ERROR) THEN
                   vResult = MINIMUM(vResult, vD).
           END.
       END.
       RUN Pars-SetResult(vResult).
   END.

   is-ok = TRUE.
   RETURN.

END PROCEDURE.


/*
  Что делает: Количество в заданной проводке
  Синтаксис : Кол(Номер_Проводки)
*/

PROCEDURE Кол:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    IF NOT Pars-ValidParam(1) THEN RETURN.

    IF mvar[pj] = "Э"
    THEN DO:
        RUN internal-parser-getdetails-form-ttable (?,"", "qty", OUTPUT mvar[pj]).
        RUN Pars-SetResult ( DEC(mvar[pj]) ).
    END.

    ELSE
    DO:
        FIND FIRST xwop WHERE xwop.op-templ = INT64(result_l[pj]) NO-LOCK NO-ERROR.
        if AVAIL xwop then
            RUN Pars-SetResult ( xwop.qty ).
        ELSE RETURN.
    END.
/* --- */
    is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Остаток в р_у_блях или в валюте в зависимости от валюты счета
  Синтаксис : Ост(Номер_Счета) - Код валюты достается из счета, статус - основной
              Ост(Номер_Счета, Код_Валюты) - Статус основной
              Ост(Номер_Счета, Код_Валюты, Статус)
*/
PROCEDURE Ост:
    DEF OUTPUT PARAM oIsOk AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    IF NOT (    Pars-ValidParam(1)
             OR Pars-ValidParam(2)
             OR Pars-ValidParam(3) ) THEN
       RETURN.
    ASSIGN
       sh-bal = 0
       sh-val = 0
    .

    DEFINE VARIABLE vAcct     AS CHARACTER  NO-UNDO.
    DEFINE VARIABLE vCurrency AS CHARACTER  NO-UNDO.
    DEFINE VARIABLE vStatus   AS CHARACTER  NO-UNDO.

    vAcct = Pars-GetString ( 0 ).

    IF pn EQ 0 THEN
    DO:
       {find-act.i
           &bact   = acct
           &acct   = vAcct
       }
       vCurrency = IF   AVAIL acct
                   THEN acct.currency
                   ELSE ''.
    END.
    ELSE DO:
        vCurrency = Pars-GetStringFormatted ( 1 , "999" ).
        IF vCurrency EQ vNatCurrChar THEN
           vCurrency = "".
        {find-act.i
            &bact   = acct
            &acct   = vAcct
            &curr   = vCurrency
        }
    END.

    vStatus = IF   pn EQ 2
              THEN Pars-GetString ( 2 )
              ELSE gop-status.
    IF NOT AVAIL acct THEN
    DO: /* если счет не объявлен (?) или
                не существует то возвращаем ? */
        RUN Pars-SetResult ( 0 ).
    END.
    ELSE DO: /* иначе запускаем acct-pos */
        RUN acct-pos IN h_base ( acct.acct,
                                 acct.currency,
                                 in-op-date,
                                 in-op-date,
                                 vStatus ).
        IF RETURN-VALUE NE "" THEN  /* Om 22.12.00 */
           RETURN.

        IF vCurrency EQ ""
        THEN RUN Pars-SetResult ( sh-bal ).
        ELSE RUN Pars-SetResult ( sh-val ).
    END.
/* --- */
    oIsOk = TRUE.
END PROCEDURE.
/*
  Что делает: Остаток в р_у_блях
  Синтаксис : ОстР(Номер_Счета) - Код валюты достается из счета, статус - основной
              ОстР(Номер_Счета, Код_Валюты) - Статус основной
              ОстР(Номер_Счета, Код_Валюты, Статус)
*/

PROCEDURE ОстР:
   DEF OUTPUT PARAM oIsOk AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
   sh-bal = 0.
   RUN Ост ( OUTPUT oIsOk ).
   IF NOT oIsOk THEN
      RETURN.
   RUN Pars-SetResult ( sh-bal ).

END PROCEDURE.

/*
  Что делает: Остаток в валюте
  Синтаксис : ОстВ(Номер_Счета) - Код валюты достается из счета, статус - основной
              ОстВ(Номер_Счета, Код_Валюты) - Статус основной
              ОстВ(Номер_Счета, Код_Валюты, Статус)
*/

PROCEDURE ОстВ:
   DEF OUTPUT PARAM oIsOk AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   sh-val = 0.
   RUN Ост ( OUTPUT oIsOk ).
   IF NOT oIsOk THEN
      RETURN.
   RUN Pars-SetResult ( sh-val ).

END PROCEDURE.

/*
  Что делает: Остаток на дату
  Синтаксис : ОстНаДату(Номер_Счета) - остаток на дату операции, валюта из счета, статус основной
              ОстНаДату(Номер_Счета, "dd/mm/yy") - остаток на указанную дату,
                                                   валюта из счета, статус основной
              ОстНаДату(Номер_Счета, ?,"Ф") - остаток на дату операции,
                                              валюта из счета, статус > "Ф"
              ОстНаДату(Номер_Счета, "ППД1") - остаток на плановую дату начисления %% до даты операции,
                                                   валюта из счета, статус основной
*/

PROCEDURE ОстНаДату:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
    DEFINE VARIABLE vAcct     AS CHARACTER  NO-UNDO.
    DEFINE VARIABLE vCurrency AS CHARACTER  NO-UNDO.
    DEFINE VARIABLE vStatus   AS CHARACTER  NO-UNDO.
    DEFINE VARIABLE vData AS DATE NO-UNDO.
    DEFINE VARIABLE h_templ   AS HANDLE     NO-UNDO.
    DEFINE VARIABLE vtermtype AS INT64    NO-UNDO.
    DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
    DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

    DEFINE BUFFER bto FOR term-obl.

    if NOT (Pars-ValidParam(1) OR Pars-ValidParam(2) OR Pars-ValidParam(3)) THEN RETURN.
    vAcct = Pars-GetString (0).
    {find-act.i
        &bact   = acct
        &acct   = vAcct
     }
    vCurrency = if AVAIL acct THEN acct.currency ELSE ''.
    IF pn GT 0 AND Pars-GetString ( 1 ) BEGINS "ППД" THEN
    DO:
/* ППД1 и ППД2 можно использовать только с договором */

       vtermtype = IF Pars-GetString(1) EQ "ППД1"
                      THEN 1
                      ELSE 3.
       RUN LOAN_VALID_HANDLE (INPUT-OUTPUT h_templ).
       vGlc  = ENTRY(1,h_templ:PRIVATE-DATA) NO-ERROR.
       vGl   = ENTRY(2,h_templ:PRIVATE-DATA) NO-ERROR.
       IF NOT VALID-HANDLE(h_templ)
       THEN DO:
          IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
            RUN Pars-SetResult ( 0 ).
            is-ok = TRUE.
            RETURN.
          END.
       END.
       FIND LAST bto WHERE bto.contract  EQ vGlc
                       AND bto.cont-code EQ vGl
                       AND bto.idnt      EQ vtermtype
                       AND bto.end-date  LE in-op-date NO-LOCK NO-ERROR.
       vData = IF AVAIL bto THEN bto.end-date
                            ELSE in-op-date.

    END.
    ELSE
       vData = IF    pn EQ 0
                  OR (pn GT 0 AND Pars-GetString ( 1 ) EQ ?)
               THEN in-op-date
               ELSE DATE ( Pars-GetString ( 1 ) ).
    vStatus = IF pn EQ 2 THEN Pars-GetString ( 1 ) ELSE gop-status.
     /* если счет не объявлен (?) то возвращаем ? */
    if NOT AVAIL acct THEN RUN Pars-SetResult ( 0 ).
    ELSE DO: /* иначе запускаем acct-pos */
        RUN acct-pos in h_base (acct.acct,acct.currency,vData,vData,vStatus).
        if RETURN-VALUE NE "" /* Om 22.12.00 */
        THEN RETURN.
        result_l[pj - pn] = if vCurrency EQ '' THEN sh-bal ELSE sh-val.
        mvar[pj - pn] = "".
    END.
/* --- */
    is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Возвращает количество ценных бумаг по счету на дату
  Синтаксис : КолНаДату(Номер_Счета) - количество на дату операции, валюта из счета, статус основной
              КолНаДату(Номер_Счета, "dd/mm/yy") - количество на указанную дату,
                                                   валюта из счета, статус основной
*/

PROCEDURE КолНаДату:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
    DEFINE VARIABLE vAcct     AS CHARACTER  NO-UNDO.
    DEFINE VARIABLE vCurrency AS CHARACTER  NO-UNDO.
    DEFINE VARIABLE vStatus   AS CHARACTER  NO-UNDO.
    DEFINE VARIABLE vData AS DATE NO-UNDO.

    if NOT (Pars-ValidParam(1) OR Pars-ValidParam(2)) THEN RETURN.
    vAcct = Pars-GetString (0).
    {find-act.i
        &bact   = acct
        &acct   = vAcct
     }
    vCurrency = if AVAIL acct THEN acct.currency ELSE ''.
    vData = IF pn EQ 0 THEN in-op-date ELSE DATE ( Pars-GetString ( 1 ) ).
    vStatus = gop-status.
     /* если счет не объявлен (?) то возвращаем ? */
    if NOT AVAIL acct THEN RUN Pars-SetResult ( 0 ).
    ELSE DO: /* иначе запускаем acct-qty */
        RUN acct-qty in h_base (acct.acct,acct.currency,vData,vData,vStatus).
        if RETURN-VALUE NE ""
        THEN RETURN.
        result_l[pj - pn] = sh-qty.
        mvar[pj - pn] = "".
    END.
/* --- */
    is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Возвращает связанный с аннулированным документом
              счет доходов по номеру проводки соответствующего
              документа картотеки-2
  Синтаксис : СчетДох(Номер_Проводки)
*/

PROCEDURE СчетДох:
   DEFINE OUTPUT PARAMETER is-ok     AS LOGICAL   NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE mOpEntryNum       AS INT64   NO-UNDO. /* Номер проводки документа картотеки-2*/
   DEFINE VARIABLE mOp               AS INT64   NO-UNDO. /* Номер документа картотеки-2*/
   DEFINE VARIABLE mSrcOp            AS INT64   NO-UNDO. /* Номер исходного документа */
   DEFINE VARIABLE mOurBankCode      AS CHARACTER NO-UNDO. /* БИК банка */
   DEFINE VARIABLE mOurBankName      AS CHARACTER NO-UNDO. /* Наимен. банка */
   DEFINE VARIABLE mOurBankNameShort AS CHARACTER NO-UNDO. /* Краткое наимен. банка */

   DEFINE BUFFER bob FOR op-bank.
   DEFINE BUFFER bop FOR op.

   IF NOT pars-validparam(1) THEN RETURN.

   mOpEntryNum = pars-GetInt(0).

   FIND FIRST branch WHERE
              branch.branch-id EQ dept.branch NO-LOCK NO-ERROR.

   /* БИК банка берем из оргструктуры */
   mOurBankCode = getBranchXattrValue(dept.branch, "БанкМФО").

   /* короткое название банка берем из настроечного параметра */
   mOurBankNameShort = FGetSetting("БанкС", ?, "").

   IF AVAIL branch
      THEN mOurBankName = branch.name.
      ELSE mOurBankName = mOurBankNameShort.

   FIND FIRST xwop WHERE
              xwop.op-templ EQ mOpEntryNum NO-LOCK NO-ERROR.
   IF AVAIL xwop
      THEN mOp = xwop.op * (-1).
      ELSE RETURN.

   mSrcOp = INT64(GetXattrValue("op", STRING(mOp),"op-bal")) NO-ERROR.
   IF ERROR-STATUS:ERROR THEN RETURN.

   FIND FIRST bop WHERE
              bop.op = mSrcOp NO-LOCK NO-ERROR.

   IF NOT AVAIL bop THEN RETURN.

   /* ищем банк */
   FIND FIRST bob OF bop WHERE
              bob.op-bank-type = "" AND
              bob.bank-code-type = "МФО-9" NO-LOCK NO-ERROR.

   /* Если не найдены банковские реквизиты исходного документа,
   ** то считаем, что это внутренний документ */
   IF NOT AVAIL bob
      THEN RUN Pars-SetACCTResult (GetXattrValue("op",STRING(bop.op),"acctcorr")).

   /* Обрабатываем не внутренние документы */
   ELSE /* Проверка, что получатель - наш банк и расчетный счет удовлетворяет маске */
      IF (bop.name-ben <> mOurBankName AND
          bop.name-ben <> mOurBankNameShort) OR
         (bob.bank-code <> mOurBankCode)
         THEN RUN Pars-SetACCTResult (bop.ben-acct).

   is-ok = TRUE.

END PROCEDURE.

/*
  Что делает: Счет дебета из указанной проводки
  Синтаксис : Дб(Номер_Проводки)
*/

PROCEDURE Дб:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
/* --- */
   DEFINE VARIABLE vRes  AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vFlEr AS LOGICAL   NO-UNDO.
   DEFINE VARIABLE vNom  AS INT64     NO-UNDO.

    IF NOT Pars-ValidParam(1) THEN RETURN.
/* --- */
    vNom = INT64(result_l[pj]) NO-ERROR.
    FIND FIRST xwop WHERE xwop.op-templ EQ vNom NO-LOCK NO-ERROR.
    if AVAIL xwop
    THEN DO:
       IF INDEX(xwop.acct-db,"(") EQ 0
       THEN
          vRes = xwop.acct-db.
       ELSE IF GetSysConf("PARS_FUNC_DB_ALREADY_RUNNING_" + STRING(vNom)) NE "YES" THEN
       DO:
          RUN SetSysConf IN h_base ("PARS_FUNC_DB_ALREADY_RUNNING_" + STRING(vNom),"YES").
          /* получение контекста из персистентной библиотеки парсеных функций */
          /* Сохраняем стек резултатов */
          {empty ttParsOld}
          RUN GetEnv IN h_prsfn (OUTPUT mSerOld,
                                 OUTPUT mtCurOld,
                                 OUTPUT mpnOld,
                                 OUTPUT mpjOld,
                                 OUTPUT TABLE ttParsOld) NO-ERROR.
          RUN parsaccttempl.p (vNom,
                               YES,
                               gend-date,
                               OUTPUT vFlEr,
                               OUTPUT vRes) NO-ERROR.
          /* Востанавливаем стек результатов */
          RUN SetEnv IN h_prsfn (mSerOld,
                                 mtCurOld,
                                 in-op-date,
                                 rid,
                                 WopSurr,
                                 mpnOld,
                                 mpjOld,
                                 INPUT TABLE ttParsOld) NO-ERROR.
          RUN DeleteOldDataProtocol IN h_base ("PARS_FUNC_DB_ALREADY_RUNNING_" + STRING(vNom)).
       END.
       RUN Pars-SetACCTResult (vRes).
    END.
    ELSE IF wop.op-templ GE vNom THEN
    DO:
       RUN internal-parser-getdetails-form-ttable(vNom,"","acct-db",OUTPUT vRes).
       RUN Pars-SetACCTResult (vRes).
    END.
    ELSE
       RETURN.
/* --- */
    is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Счет кредита из указанной проводки
  Синтаксис : Кр(Номер_Проводки)
*/

PROCEDURE Кр:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
/* --- */
   DEFINE VARIABLE vRes  AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vFlEr AS LOGICAL   NO-UNDO.
   DEFINE VARIABLE vNom  AS INT64     NO-UNDO.

    IF NOT Pars-ValidParam(1) THEN RETURN.
/* --- */
    vNom = INT64(result_l[pj]) NO-ERROR.
    FIND FIRST xwop WHERE xwop.op-templ = vNom NO-LOCK NO-ERROR.
    IF AVAIL xwop
    THEN DO:
       IF INDEX(xwop.acct-cr,"(") EQ 0
       THEN
          vRes = xwop.acct-cr.
       ELSE IF GetSysConf("PARS_FUNC_CR_ALREADY_RUNNING_" + STRING(vNom)) NE "YES" THEN
       DO:
          RUN SetSysConf IN h_base ("PARS_FUNC_CR_ALREADY_RUNNING_" + STRING(vNom),"YES").
          /* сохраняем стек резултатов */
          {empty ttParsOld}
          RUN GetEnv IN h_prsfn (OUTPUT mSerOld,
                                 OUTPUT mtCurOld,
                                 OUTPUT mpnOld,
                                 OUTPUT mpjOld,
                                 OUTPUT TABLE ttParsOld) NO-ERROR.

          RUN parsaccttempl.p (vNom,
                               NO,
                               gend-date,
                               OUTPUT vFlEr,
                               OUTPUT vRes) NO-ERROR.
          /* Востанавливаем стек результатов */
          RUN SetEnv IN h_prsfn (mSerOld,
                                 mtCurOld,
                                 in-op-date,
                                 rid,
                                 WopSurr,
                                 mpnOld,
                                 mpjOld,
                                 INPUT TABLE ttParsOld) NO-ERROR.
          RUN DeleteOldDataProtocol IN h_base ("PARS_FUNC_CR_ALREADY_RUNNING_" + STRING(vNom)).
       END.
       RUN Pars-SetACCTResult (vRes).
    END.
    ELSE IF wop.op-templ GE vNom THEN
    DO:
       RUN internal-parser-getdetails-form-ttable(vNom,"","acct-cr",OUTPUT vRes).
       RUN Pars-SetACCTResult (vRes).
    END.
    ELSE
       RETURN.
  /* --- */
    is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Код валюты из заданной проводки
  Синтаксис : Вал(Номер_Проводки)
*/

PROCEDURE Вал:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
/* --- */
    IF NOT Pars-ValidParam(1) THEN RETURN.
/* --- */

    if result_l[pj] NE 0 THEN DO:
        FIND FIRST xwop WHERE xwop.op-templ = INT64(result_l[pj]) NO-LOCK NO-ERROR.
        if AVAIL xwop then
            RUN Pars-SetCHARResult ( if xwop.currency = "" THEN vNatCurrChar ELSE xwop.currency ).
        ELSE  RETURN.
    END.
    ELSE DO:  /* Sema 27/01/99 */
        case mvar[pj]:
            when "БД" THEN RUN Pars-SetCHARResult ( IF bcur-db = "" THEN vNatCurrChar ELSE bcur-db ).
            when "КР" THEN RUN Pars-SetCHARResult ( IF bcur-cr = "" THEN vNatCurrChar ELSE bcur-cr ).
        end case.
    END.
/* --- */
    is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Наименование валюты по коду валюты
  Синтаксис : Вал(код валюты)
*/

PROCEDURE ВалНаим:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE vCurChar  AS CHARACTER NO-UNDO.
    DEFINE VARIABLE vNameCurr AS CHARACTER NO-UNDO.

/* --- */
    IF NOT Pars-ValidParam(1) THEN RETURN.
/* --- */
    vCurChar = Pars-GetString (0).

    RUN GetCurrName(vCurChar,OUTPUT vNameCurr).
    RUN Pars-SetCHARResult ( IF vCurChar = "810" THEN
                               "Валюта РФ"
                             ELSE
                                vNameCurr).
/* --- */
    is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Сумма эквивалента заданной проводки
  Синтаксис : СуммаЭ(Номер_Проводки)
*/

PROCEDURE СуммаЭ:
   DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vResult AS DECIMAL    NO-UNDO.
   DEFINE VARIABLE vTag    AS CHARACTER  NO-UNDO.

   IF NOT (Pars-ValidParam(1)) THEN RETURN.

   vTag = Pars-GetString(0).

   IF vTag EQ "Э" THEN DO:
       RUN internal-parser-getdetails-form-ttable (?,"", "amt-rub", OUTPUT vTag).
       vResult = DEC(vTag).

   END.
   ELSE
   DO:
       FIND FIRST xwop WHERE xwop.op-templ EQ INT64(vTag) NO-LOCK NO-ERROR.
       if NOT AVAIL xwop
         THEN vResult = 0.
         ELSE vResult = xwOp.Amt-Rub.
   END.
   RUN Pars-SetResult (vResult).
   is-ok = TRUE.

END PROCEDURE.

/*
  Что делает: Возвращает курс
  Синтаксис : Курс(тип_курса)
              Курс(тип_курса, подразделение)
              Курс(валюта, тип_курса)
              Курс(валюта, дата, тип_курса)
              Курс(валюта, тип_курса, подразделение)
              Курс(валюта, дата, тип_курса, подразделение)

              Если указана дата, и курс на эту дату определить невозможно, курс
              берётся на дату опердня.
              Также вместо даты может быть передано одно из значений {"В",
              "Вал"}. В этом случае курс берется на дату валютирования. Дата
              валютирования определяется из временной таблицы. Если это
              невозможно, дата валютирования определяется из фрейма. Если
              невозможно и это, курс берётся на дату опердня.
*/

PROCEDURE Курс:
    DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE vCurrency AS CHARACTER NO-UNDO.
    DEFINE VARIABLE vDate     AS DATE      NO-UNDO.
    DEFINE VARIABLE vDateStr  AS CHARACTER NO-UNDO.
    DEFINE VARIABLE vRateType AS CHARACTER NO-UNDO.
    DEFINE VARIABLE vBranchId AS CHARACTER NO-UNDO.
    DEFINE VARIABLE vInstr    AS CHARACTER NO-UNDO.
    DEFINE VARIABLE vCourse   AS DECIMAL   NO-UNDO.

    is-ok = NO.
    CASE pn:
        WHEN 1 THEN DO:
            IF Pars-ValidParam(1) THEN
                /* тип_курса */
                vRateType = Pars-GetString(0).
            ELSE
                RETURN.
        END.
        WHEN 2 THEN DO:
            IF Pars-ValidParam(2) THEN DO:
                /* тип_курса, подразделение */
                ASSIGN
                    vRateType = Pars-GetString(0)
                    vBranchId = Pars-GetString(1)
                .
                IF NOT CAN-FIND(FIRST branch
                                WHERE
                                    branch.branch-id = vBranchId)
                THEN
                    /* валюта, тип_курса */
                    ASSIGN
                        vCurrency = STRING(vRateType, "999")
                        vRateType = vBranchId
                        vBranchId = ?
                    .
            END.
            ELSE
                RETURN.
        END.
        WHEN 3 THEN DO:
            IF Pars-ValidParam(3) THEN DO:
                /* валюта, дата, тип_курса */
                ASSIGN
                    vCurrency = Pars-GetStringFormatted(0, "999").
                    vDateStr  = Pars-GetString(1).
                    vRateType = Pars-GetString(2).
                .
                IF NOT CAN-DO("В,Вал", vDateStr) THEN DO:
                    vDate = DATE(vDateStr) NO-ERROR.
                    IF ERROR-STATUS:ERROR OR vDate = ? THEN
                        /* валюта, тип_курса, подразделение */
                        ASSIGN
                            vBranchId = vRateType
                            vRateType = vDateStr
                            vDateStr  = ""
                        .
                END.
            END.
            ELSE
                RETURN.
        END.
        WHEN 4 THEN DO:
            IF Pars-ValidParam(4) THEN
                /* валюта, дата, тип_курса, подразделение */
                ASSIGN
                    vCurrency = Pars-GetStringFormatted(0, "999")
                    vDateStr  = Pars-GetString(1)
                    vRateType = Pars-GetString(2)
                    vBranchId = Pars-GetString(3)
                .
            ELSE
                RETURN.
        END.
        OTHERWISE
            RETURN.
    END.

    IF CAN-DO("В,Вал", vDateStr) THEN DO:
        RUN internal-parser-getdetails-form-ttable(?,
                                                   "",
                                                   "value-date",
                                                   OUTPUT vDateStr).
        IF vDateStr = ? THEN DO:
            RUN internal-parser-getdetails-form-ttable(?,
                                                       "",
                                                       "op-value-date",
                                                       OUTPUT vDateStr).
            IF vDateStr = ? AND AVAIL wop THEN
                vDate = wop.value-date.
        END.
    END.
    ELSE DO:
        vDate = DATE(vDateStr) NO-ERROR.
        IF ERROR-STATUS:ERROR OR vDate = ? THEN
            vDate = in-op-date.
    END.

    vInstr = GetCode(IF {assigned vBranchId} THEN
                         "Курсы Подр"
                     ELSE
                         "Курсы",
                     vRateType).

    IF vInstr = ? THEN DO:
        MESSAGE "В шаблоне проводки N " +
                (IF AVAIL wop AND wop.op-templ <> ? THEN
                     STRING(wop.op-templ)
                 ELSE
                     "?") +
                " ссылка на несуществующий курс '" + STRING(vRateType) + "'"
        VIEW-AS ALERT-BOX ERROR.
        RETURN.
    END.

    IF {assigned vCurrency} THEN
        tcur = STRING(vCurrency, "999").
    ELSE IF AVAIL wop THEN
        tcur = wop.currency.
    ELSE
        tcur = "".

    IF {assigned vBranchId} THEN DO:
        IF ChkExistRateTime(?,
                            tcur,
                            vBranchId,
                            vDate,
                            TIME,
                            vRateType,
                            ?)
        THEN
            vCourse = FindRateTimeSimple(vRateType,
                                         tcur,
                                         vBranchId,
                                         vDate,
                                         TIME,
                                         ?).
    END.
    ELSE
        vCourse = FindRateSimple(vRateType, tcur, vDate).

    RUN Pars-SetResult(vCourse).

    ASSIGN
        tcur  = vInstr
        is-ok = YES
    .
END PROCEDURE.

/*
  Что делает: Возвращает котировку
  Синтаксис : Котировка(Тип_Котировки,Код_ЦБ)
  Тип_Котировки - код типа котировки из справочника ТипКот
  Код_ЦБ - код ценной бумаги, если не задан в фррмуле, то берется из проводки
*/

PROCEDURE Котировка:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
/* --- */
    IF NOT (Pars-ValidParam(1) OR Pars-ValidParam(2)) THEN RETURN.
/* --- */
    DEFINE VARIABLE vKotType AS CHARACTER  NO-UNDO.
    DEFINE VARIABLE vCodeCB AS CHARACTER  NO-UNDO.
    vKotType = Pars-GetString ( 0 ).
    FIND FIRST code WHERE code.class = "ТипКот" AND code.code =  vKotType NO-LOCK NO-ERROR.
    IF NOT AVAIL code THEN DO:
        MESSAGE "В шаблоне проводки N " + STRING(wop.op-templ) + " ссылка на несуществующую котировку '" + vKotType + "'" VIEW-AS ALERT-BOX ERROR.
        RETURN.
    END.
    vCodeCB = (IF pn = 0
               THEN wop.currency
               ELSE Pars-GetString ( 1 ) ).
    find sec-code where sec-code.sec-code EQ vCodeCB no-lock NO-ERROR.
    if NOT AVAIL sec-code
    THEN DO:
        message "В шаблоне проводки N " + STRING(wop.op-templ) + " ссылка на несуществующий код ЦБ '" + vCodeCB + "'"
            VIEW-AS ALERT-BOX ERROR.
        RETURN.
    END.
    FIND LAST instr-rate WHERE instr-rate.instr-cat = "sec-code" AND
                               instr-rate.rate-type = vKotType AND
                               instr-rate.instr-code = vCodeCB AND
                               instr-rate.since <= in-op-date SHARE-LOCK no-wait NO-ERROR.
    IF NOT AVAIL instr-rate THEN DO:
        MESSAGE "Котировка ' " + vKotType + "' ЦБ " + tcur + " не установлена или редактируется !" VIEW-AS ALERT-BOX ERROR.
        RETURN.
    END.
    RUN Pars-SetResult ( instr-rate.rate-instr / instr-rate.per ).
/* --- */
    is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Возвращает код ценной бумаги лицевого счета
  Если это депо счет, то код ЦБ берется из поля currency счета иначе из доп.
  реквизита к счету - КодЦб
  Синтаксис : Котировка(номер_счета,валюта_счета)
  параметр валюта может не передаваться, тогда ищется первый счет ы указанным номером
*/
PROCEDURE КодЦб:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
    DEFINE VARIABLE in-sur AS CHAR NO-UNDO.

/* --- */
    IF NOT (Pars-ValidParam(1) OR Pars-ValidParam(2)) THEN RETURN.
/* --- */

    DEFINE VARIABLE vAcct     AS CHARACTER  NO-UNDO.
    DEFINE VARIABLE vCurrency AS CHARACTER  NO-UNDO.
    ASSIGN
        vAcct     = Pars-GetString ( 0 )
        vCurrency = Pars-GetStringFormatted ( 1 , "999" )
        .
    IF pn = 0 THEN DO:
        {find-act.i
            &bact   = acct
            &acct   = vAcct
        }
    END.
    ELSE DO:
        {find-act.i
            &bact   = acct
            &acct   = vAcct
            &curr   = vCurrency
        }
    END.

    if NOT AVAIL acct THEN DO:
        message "В шаблоне проводки N " + STRING(wop.op-templ) + " ссылка на несуществующий счет "   view-as alert-box error.
        RETURN.
    END.
    if acct.acct-cat EQ 'd'  THEN RUN Pars-SetCHARResult ( acct.currency ).
    ELSE DO:
        in-sur = acct.acct + ',' + acct.currency .
        if NOT AvailXattr("acct",in-sur,"sec-code") THEN do :
            message 'Для счета ' + acct.acct  + ' не определен код ценной бумаги '  view-as alert-box error.
            RETURN.
        END.
        RUN Pars-SetCHARResult (GetXattrValue("acct",in-sur,"sec-code")).
    END.

/* --- */
    is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Возвращает накопленный купонный доход (НКД) для ЦБ на дату
  Синтаксис : НКД(КодЦБ,Дата расчета)
*/
PROCEDURE НКД:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEF BUFFER sec-code FOR sec-code. /* Локализация буфера. */

    DEFINE VARIABLE vSecCode  AS CHARACTER  NO-UNDO.
    DEFINE VARIABLE vDateCalc AS DATE       NO-UNDO.

    DEFINE VARIABLE mSecBeg     AS CHARACTER NO-UNDO.
    DEFINE VARIABLE mNominal    AS DECIMAL   NO-UNDO.
    DEFINE VARIABLE mCoupPeriod AS DECIMAL   NO-UNDO.
    DEFINE VARIABLE mCoupLife   AS DECIMAL   NO-UNDO.
    DEFINE VARIABLE vResult     AS DECIMAL   NO-UNDO.


    DEFINE BUFFER b-instr FOR instr-rate.
    /* Разбор входных параметров. */
    IF pn NE 2
    THEN RETURN.

    ASSIGN
       pn        = pn - 1
       vSecCode  = Pars-GetString(0)
    .
   FIND FIRST sec-code WHERE
       sec-code.sec-code EQ vSecCode
   NO-LOCK NO-ERROR.
   IF NOT AVAIL sec-code
      THEN RETURN.

   mSecBeg   = STRING (sec-code.issue-date).
   vDateCalc = DATE(Pars-GetString(1)) NO-ERROR.

    /* Поиск первого купона, непогашенного на дату */
    FIND FIRST instr-rate WHERE
               instr-rate.instr-code EQ vSecCode
           AND instr-rate.rate-type  EQ "Купон"
           AND instr-rate.instr-cat  EQ "sec-code"
           AND instr-rate.since      GE vDateCalc NO-LOCK NO-ERROR.
    IF AVAILABLE instr-rate THEN DO:
       FIND LAST b-instr WHERE /* Ищем предыдущий купон*/
                 b-instr.instr-code EQ vSecCode
             AND b-instr.rate-type  EQ "Купон"
             AND b-instr.instr-cat  EQ "sec-code"
             AND b-instr.since      LT instr-rate.since NO-LOCK NO-ERROR.
       ASSIGN
          mNominal    = FindRateSimpleCat("sec-code","Номинал",vSecCode,instr-rate.since,0.00)
          mCoupPeriod = instr-rate.since -
                        (IF AVAIL b-instr
                         THEN b-instr.since
                         ELSE DATE(mSecBeg))
          mCoupLife   = vDateCalc -
                        (IF AVAIL b-instr
                         THEN b-instr.since
                         ELSE DATE(mSecBeg))
          vResult = (instr-rate.rate-instr / 100 ) * mNominal * ( mCoupPeriod / 365)
          vResult = (vResult / mCoupPeriod) * mCoupLife.
    END.
    ELSE /* в случае отсутствия ищем последний погашенный*/
       FOR LAST instr-rate WHERE
                instr-rate.instr-code EQ vSecCode
            AND instr-rate.rate-type  EQ "Купон"
            AND instr-rate.instr-cat  EQ "sec-code"
            AND instr-rate.since      LE vDateCalc NO-LOCK:
          FIND LAST b-instr WHERE /* Ищем предыдущий купон*/
                    b-instr.instr-code EQ vSecCode
                AND b-instr.rate-type  EQ "Купон"
                AND b-instr.instr-cat  EQ "sec-code"
                AND b-instr.since      LT instr-rate.since NO-LOCK NO-ERROR.

          ASSIGN
             mNominal    = FindRateSimpleCat("sec-code","Номинал",vSecCode,instr-rate.since,0.00)
             mCoupPeriod = instr-rate.since -
                           (IF AVAIL b-instr
                            THEN b-instr.since
                            ELSE DATE(mSecBeg))
             vResult = (instr-rate.rate-instr / 100 ) * mNominal * ( mCoupPeriod / 365)
          .
       END.
    RUN Pars-SetResult (vResult).
    is-ok = TRUE.
END PROCEDURE.

/* Сумма оборотов по счету за день */
PROCEDURE СуммаКредОб.

    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
    def buffer t-entry for op-entry.
    DEFINE VARIABLE vAcct AS CHARACTER NO-UNDO.
    if NOT Pars-ValidParam(1)
    THEN RETURN.
    vAcct = (IF mvar[pj - pn] EQ "" THEN STRING(result_l[pj - pn])
                                    ELSE TRIM(mvar[pj - pn], """'")).
    {find-act.i
        &bact   = acct
        &acct   = vAcct
    }

    ASSIGN
        result_l[pj - pn] = 0
        mvar[pj - pn]     = ""
        is-ok             = true
    .

    if NOT AVAIL acct
    THEN RETURN.

    for each t-entry where
        t-entry.acct-cr = acct.acct and
        t-entry.op-date = in-op-date
    no-lock:
        result_l[pj - pn] = result_l[pj - pn] + (if acct.currency > ''
                                                 THEN t-entry.amt-cur
                                                 ELSE t-entry.amt-rub).
    END.

END PROCEDURE.

/* сумма оборотов за день по дебету */
PROCEDURE СуммаДебОб.

    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
    def buffer t-entry for op-entry.
    DEFINE VARIABLE vAcct AS CHARACTER NO-UNDO.
    if  NOT Pars-ValidParam(1)
    THEN RETURN.

    vAcct = (IF mvar[pj - pn] EQ "" THEN STRING(result_l[pj - pn])
                                    ELSE TRIM(mvar[pj - pn], """'")).
    {find-act.i
        &bact   = acct
        &acct   = vAcct
    }

    ASSIGN
        result_l[pj - pn] = 0
        mvar[pj - pn]     = ""
        is-ok             = true
    .

    if NOT AVAIL acct
    THEN RETURN.

    for each t-entry where
        t-entry.acct-db = acct.acct and
        t-entry.op-date = in-op-date
    no-lock:
        result_l[pj - pn] = result_l[pj - pn] + (if acct.currency > ''
                                                 THEN t-entry.amt-cur
                                                 ELSE t-entry.amt-rub).
    END.

END PROCEDURE.

/* Проверка резидентности владельца вклада */
PROCEDURE Клиент:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
    DEFINE VARIABLE h_templ AS handle NO-UNDO.

    IF NOT Pars-ValidParam(2)
    THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run DPS_VALID_HANDLE (input-output h_templ).

    if NOT valid-handle(h_templ)
    THEN DO:
        MESSAGE "Номер вклада не определен"
        VIEW-AS ALERT-BOX ERROR.
        RETURN.
    END.

    /* Поиск вклада */
    run RE_B_LOAN  in h_Loan (Pars-GetString(0),
                              entry(1,substring(h_templ:private-data,6)),
                              buffer loan).

    if NOT AVAIL loan
    THEN DO:
        MESSAGE "Нет вклада"
        VIEW-AS ALERT-BOX ERROR.
        RETURN.
    END.

    find person where
        person.person-id EQ loan.cust-id
    no-lock NO-ERROR.
    if NOT AVAIL person
    THEN DO:
        message 'Проводка по вкладу несуществующего клиента'
        view-as alert-box error.
        RETURN.
    END.

    RUN Pars-SetResult ( if person.country-id EQ 'RUS' THEN 1 ELSE 0 ).
    is-ok = TRUE.

END PROCEDURE.


/* Остаток по кау р_у_блевый */
/*Процедура КауОстР перенесена в dpspars.p*/

/* Остаток по кау валютный */
/*Процедура КауОстВ перенесена в dpspars.p*/

/* Определение счета по роли для обработки при расчете сумм */
PROCEDURE РольСчет:
   DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE h_templ     AS HANDLE NO-UNDO.
   DEFINE VARIABLE str1        AS CHAR   NO-UNDO.
   DEFINE VARIABLE vPrevResult AS CHAR   NO-UNDO.

   IF NOT Pars-ValidParam(2) THEN RETURN.

   /* Определение правильного применения функции, формат private-data */
   RUN GET_LOAN_VALID_HANDLE (INPUT Pars-GetString(0),INPUT-OUTPUT h_templ).

   IF NOT VALID-HANDLE(h_templ) THEN
   DO:
       RUN Pars-SetResult ( 0 ).
       is-ok = TRUE.
       RETURN.
   END.

   RUN RE_B_LOAN IN h_Loan (GET_LOAN_CONTRACT (Pars-GetString(0),h_templ),
                            GET_LOAN_CONT_CODE (Pars-GetString(0),h_templ),
                            BUFFER loan).

   IF NOT AVAIL loan THEN
   DO:
      RUN Pars-SetResult ( 0 ).
      is-ok = TRUE.
      RETURN.
   END.

   RUN FindLPResult(loan.contract,
                    loan.cont-code,
                    "РольСчет",
                    Pars-Getstring(1),
                    OUTPUT vPrevResult).

   IF vPrevResult EQ "" THEN
   DO:
      str1 = REPLACE(Pars-Getstring(1),"'","").
      FIND LAST loan-acct OF loan WHERE
                loan-acct.acct-type EQ TRIM(str1)
            AND loan-acct.since     LE in-op-date
      NO-LOCK NO-ERROR.

      RUN Pars-SetACCTResult ( IF AVAIL loan-acct THEN loan-acct.acct ELSE "" ).
      RUN SaveLPResult (loan.contract,
                        loan.cont-code,
                        "РольСчет",
                        Pars-Getstring(1),
                        IF AVAIL loan-acct THEN loan-acct.acct ELSE "").
      is-ok = TRUE.
   END.
   ELSE
   DO:
      RUN Pars-SetACCTResult ( vPrevResult ).
      is-ok = TRUE.
   END.

END PROCEDURE.

PROCEDURE РольСчетВал:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

  DEFINE VARIABLE h_templ     AS HANDLE NO-UNDO.
  DEFINE VARIABLE str1        AS CHAR   NO-UNDO.
  DEFINE VARIABLE vPrevResult AS CHAR   NO-UNDO.

  IF NOT Pars-ValidParam(2) THEN
     RETURN.

  /* Определение правильного применения функции, формат private-data */
  RUN GET_LOAN_VALID_HANDLE (INPUT Pars-GetString(0),INPUT-OUTPUT h_templ).

  IF NOT VALID-HANDLE(h_templ) THEN
  DO:
      RUN Pars-SetResult ( 0 ).
      is-ok = TRUE.
      RETURN.
  END.

  RUN RE_B_LOAN IN h_Loan (GET_LOAN_CONTRACT (Pars-GetString(0),h_templ),
                           GET_LOAN_CONT_CODE (Pars-GetString(0),h_templ),
                           BUFFER loan).

  IF NOT AVAIL loan THEN
  DO:
      RUN Pars-SetResult ( 0 ).
      is-ok = TRUE.
      RETURN.
  END.

   RUN FindLPResult(loan.contract,
                    loan.cont-code,
                    "РольСчетВал",
                    Pars-Getstring(1),
                    OUTPUT vPrevResult).

   IF vPrevResult EQ "" THEN
   DO:
      str1 = REPLACE(Pars-Getstring(1),"'","").
      FIND LAST loan-acct OF loan WHERE
                loan-acct.acct-type EQ TRIM(str1)
            AND loan-acct.since     LE in-op-date
      NO-LOCK NO-ERROR.

      IF AVAIL loan-acct THEN
      DO:
         RUN Pars-SetCHARResult ( IF loan-acct.currency EQ '' THEN vNatCurrChar ELSE loan-acct.currency ).
         RUN SaveLPResult (loan.contract,
                           loan.cont-code,
                           "РольСчетВал",
                           Pars-Getstring(1),
                           IF loan-acct.currency EQ '' THEN vNatCurrChar ELSE loan-acct.currency).
      END.
      ELSE
      DO:
         RUN Pars-SetResult ( 0 ).
         RUN SaveLPResult (loan.contract,
                           loan.cont-code,
                           "РольСчетВал",
                           Pars-Getstring(1),
                           "0").
      END.


      is-ok = TRUE.
   END.
   ELSE
   DO:
      RUN Pars-SetCHARResult ( vPrevResult ).
      is-ok = TRUE.
   END.
END PROCEDURE.


PROCEDURE truncate:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

  IF NOT Pars-ValidParam(2) THEN RETURN.

  RUN Pars-SetResult ( truncate(result_l[pj - 1], INT64(result_l[pj])) ).
  is-ok             = TRUE.

END PROCEDURE.
&ENDIF

&IF  DEFINED(NEW_PARSER) = 0 OR
    (DEFINED(NEW_PARSER) > 0 AND DEFINED(PLOAN_LIB) > 0) &THEN
/*  Что делает:
**  Синтаксис : НачКрДеп (<начзначение договора>, <маска типов для обработки>)
**  Автор     : ??? ??/??/????
**  Пример    : НачКрДеп ("Кредит","*")
*/
PROCEDURE НачКрДеп:

    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE h_templ     AS handle   NO-UNDO.
    DEFINE VARIABLE result      AS decimal  NO-UNDO.
    DEFINE VARIABLE ext         AS CHAR     NO-UNDO.
    DEFINE VARIABLE fl-r        AS logical  NO-UNDO.
    DEFINE VARIABLE summ_k      AS dec      NO-UNDO.
    DEFINE VARIABLE ind         AS INT64      NO-UNDO.
    DEFINE VARIABLE pick-var    AS INT64 extent 12 initial [4,8,9,11,12,14,15,17,18,20,81,82] NO-UNDO.
    DEFINE VARIABLE vPrmValDec  AS dec      NO-UNDO. /* Остаток параметра на дату. */
    DEFINE VARIABLE vDbSumDec   AS dec      NO-UNDO. /* Не используется. */
    DEFINE VARIABLE vCrSumDec   AS dec      NO-UNDO. /* Не используется. */
    DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
    DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.
    DEF VAR vDateCalc   AS DATE     NO-UNDO. /* Дата расчетов */
    DEF VAR vContract   AS CHAR     NO-UNDO.
    DEF VAR vContCode   AS CHAR     NO-UNDO.
    def buffer cacct for acct.
    DEF BUFFER loan      FOR loan.
    DEF BUFFER loan-cond FOR loan-cond.

    remove-amt = 0.

    IF NOT Pars-ValidParam(2)
    THEN RETURN.


    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).

    vGlc = entry(1,h_templ:PRIVATE-DATA) NO-ERROR.
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
        RUN Pars-SetResult ( 0 ).
        is-ok = TRUE.
        RETURN.
    END.
    END.


/*
    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer loan).
*/
   ASSIGN
       vContract  = ENTRY(1,h_templ:private-data)
       vContCode  = ENTRY(2,h_templ:private-data)
    .
    run RE_B_LOAN in h_Loan (vContract,
                             vContCode,
                             buffer loan).


    if NOT AVAIL loan
    THEN DO:

        RUN Pars-SetResult ( 0 ).

        is-ok = TRUE.

        RETURN.
    END.

    if NOT can-do (Pars-GetString(1), loan.cont-type)
    THEN DO:

        RUN Pars-SetResult ( 0 ).

        is-ok = TRUE.

        RETURN.
    END.



/* Определим дату расчетов */
   RUN RE_L_COND IN h_Loan(vContract,
                           vContCode,
                           wop.con-date,
                           BUFFER loan-cond).
   IF AVAIL loan-cond AND ((    loan-cond.disch-type < 0 
                            AND loan-cond.disch-type <> - 1) 
                        OR (    loan-cond.disch-type >= 10 
                            AND loan-cond.disch-type <  19) 
                        OR (loan-cond.disch-type = 36))
   THEN DO: /* в последний рабочий день начисляем до конца месяца */
      vDateCalc = GetFirstDayForLoan((BUFFER loan:HANDLE), /* следующий рабочий день для договора */
                                     wop.con-date,
                                     366).
      IF MONTH(vDateCalc) EQ MONTH(wop.con-date) THEN /* не последний рабочий день месяца */
         vDateCalc = wop.con-date.
      ELSE
         vDateCalc =  DATE(MONTH(vDateCalc), 1, YEAR(vDateCalc)) - 1.

   END.
   ELSE
      vDateCalc = wop.con-date.



    {round_l.i &fl=fl-r}

    /* Получение настроечного параметра. */
    ext = FGetSettingEx ("НачШтр", ?, "", No).

    result_l[pj - pn] = 0.

    do ind = 1 to 12:

        if lookup(string(pick-var[ind]), ext) NE 0
        THEN next.

        ASSIGN

            old-val           = IF ind le 10
                                THEN loan.interest[ind]
                                ELSE LoadPar (ind,loan.contract + ',' + loan.cont-code)

            result_l[pj - pn] =  result_l[pj - pn] + (if fl-r
                                                      THEN round(old-val ,0)
                                                      ELSE old-val)
        .

        find last loan-var
            {wh-t &f=loan-var &i=pick-var[ind]} and
            loan-var.since <= vDateCalc
        no-lock NO-ERROR.

        if AVAIL loan-var
        THEN result_l[pj - pn] =  result_l[pj - pn] + loan-var.balance.

        for each loan-int of loan where
            loan-int.id-d  EQ pick-var[ind] and
            loan-int.mdate GT (if AVAIL loan-var
                               THEN loan-var.since
                               ELSE loan.since - 1) and
            loan-int.mdate le vDateCalc
        no-lock:
            result_l[pj - pn] = result_l[pj - pn] + loan-int.amt.
        END.

        for each loan-int of loan where
            loan-int.id-k  EQ pick-var[ind] and
            loan-int.mdate GT (if AVAIL loan-var
                               THEN loan-var.since
                               ELSE loan.since - 1) and
            loan-int.mdate le vDateCalc
        no-lock:

            result_l[pj - pn] = result_l[pj - pn] - loan-int.amt.
        END.
    END.

    /* Необходимо для определения категории счетов. */
    find first op-template where
        op-template.op-kind     EQ wop.op-kind and
        op-template.op-template EQ wop.op-templ
    no-lock NO-ERROR.

    /* Проверка категрии счета */
    if (avail(op-template) and op-template.acct-cat EQ 'o')
    &IF DEFINED(NEW_PARSER) &THEN
    OR Pars-GetString(2) = 'o'
    &ENDIF
    THEN DO:

        find last loan-var
            {wh-t &f=loan-var &i=16} and
            loan-var.since <= vDateCalc
        no-lock NO-ERROR.

        if AVAIL loan-var
        THEN result_l[pj - pn] = result_l[pj - pn] + loan-var.balance.

        for each loan-int of loan where
            loan-int.id-d  EQ 16 and
            loan-int.mdate gt (if AVAIL loan-var
                               THEN loan-var.since
                               ELSE loan.since - 1) and
            loan-int.mdate le vDateCalc
        no-lock:

            result_l[pj - pn] = result_l[pj - pn] + loan-int.amt.
        END.

        for each loan-int of loan where
            loan-int.id-k  EQ 16 and
            loan-int.mdate gt (if AVAIL loan-var
                               THEN loan-var.since
                               ELSE loan.since - 1) and
            loan-int.mdate le vDateCalc
        no-lock:
            result_l[pj - pn] = result_l[pj - pn] - loan-int.amt.
        END.
    END.

    find last loan-var of loan where
        loan-var.amt-id EQ 32 and
        loan-var.since  le vDateCalc
    no-lock NO-ERROR.

    result_l[pj - pn] = result_l[pj - pn] + (if AVAIL loan-var and
                                                loan-var.balance lt 0
                                             THEN loan-var.balance
                                             ELSE 0).
    for each loan-int of loan where
        loan-int.id-d  EQ 33 and
        loan-int.id-k  EQ 32 and
        loan-int.mdate gt (if AVAIL loan-var
                           THEN loan-var.since
                           ELSE loan.since - 1) and
        loan-int.mdate le vDateCalc
    no-lock:

        result_l[pj - pn] = result_l[pj - pn] - loan-int.amt.
    END.

    for each loan-int of loan where
        loan-int.id-d EQ 32 and
        loan-int.id-k EQ 33 and
        loan-int.mdate gt (if AVAIL loan-var
                           THEN loan-var.since
                           ELSE loan.since - 1) and
        loan-int.mdate le vDateCalc
    no-lock:

        result_l[pj - pn] = result_l[pj - pn] + loan-int.amt.
    END.

    find last loan-var of loan where
        loan-var.amt-id EQ 31 and
        loan-var.since  le vDateCalc
    no-lock NO-ERROR.

    result_l[pj - pn] = result_l[pj - pn] + (if AVAIL loan-var and
                                                loan-var.balance lt 0
                                             THEN loan-var.balance
                                             ELSE 0).
    for each loan-int of loan where
        loan-int.id-d  EQ 29 and
        loan-int.id-k  EQ 31 and
        loan-int.mdate gt (if AVAIL loan-var
                           THEN loan-var.since
                           ELSE loan.since - 1) and
        loan-int.mdate le vDateCalc
    no-lock:

        result_l[pj - pn] = result_l[pj - pn] - loan-int.amt.
    END.

    FOR EACH loan-int OF loan WHERE
        loan-int.id-d  EQ 29 AND
        loan-int.id-k  EQ 30 AND
        loan-int.mdate EQ vDateCalc
    NO-LOCK:

        result_l[pj - pn] = result_l[pj - pn] - loan-int.amt.
    END.


    find last loan-var
        {wh-t &f=loan-var &i=6} and
        loan-var.since le vDateCalc
    no-lock NO-ERROR.

    summ_k = if AVAIL loan-var
             THEN - loan-var.balance
             ELSE 0.

    for each loan-int of loan where
        loan-int.id-k  EQ 6 and
        loan-int.id-d  EQ 5 and
        loan-int.mdate EQ vDateCalc
    no-lock:

        summ_k = summ_k + loan-int.amt.
    END.

    for each loan-int of loan where
        loan-int.id-k  EQ 6 and
        loan-int.id-d  EQ 352 and
        loan-int.mdate eq vDateCalc
    no-lock:

        summ_k = summ_k + loan-int.amt.
    END.

     /* Необходимо убедиться, что учтены все операции
       кредитующие 6 параметр. Оплата просроченных процентов - 36 операция
       может идти в паре и с 10 и с 375  */
    for each loan-int of loan where
        loan-int.id-k  EQ 6 and
        loan-int.id-d  EQ 93 and
        loan-int.mdate EQ vDateCalc
    no-lock:
        summ_k = summ_k + loan-int.amt.
    END.
    for each loan-int of loan where
        loan-int.id-d  EQ 30 and
        loan-int.id-k  EQ 29 and
        loan-int.mdate EQ vDateCalc
    no-lock:

        summ_k = summ_k - loan-int.amt.
    END.

    for each loan-int of loan where
        loan-int.id-d  EQ 6  and
        loan-int.id-k  EQ 35 and
        loan-int.mdate EQ vDateCalc
    no-lock:

        summ_k = summ_k - loan-int.amt.
    END.

    for each loan-int of loan where
        loan-int.id-d  EQ 6 and
        loan-int.id-k  EQ 10 and
        loan-int.mdate EQ vDateCalc
    no-lock:

        summ_k = summ_k - loan-int.amt.
    END.
    /*Вычитаем из оплаченных текущих %% 309 опер.*/
    FOR EACH loan-int of loan where
        loan-int.id-d  EQ 30 and
        loan-int.id-k  EQ 48 and
        loan-int.mdate EQ vDateCalc
    NO-LOCK:
        summ_k = summ_k - loan-int.amt.
    END.

    /* получение значения 352-го параметра по договору на дату операции*/
    run STNDRT_PARAM IN h_Loan (loan.contract,
                                loan.cont-code,
                                352,
                                vDateCalc,
                                output vPrmValDec,
                                output vDbSumDec,
                                output vCrSumDec).
    /* учет 352-го параметра в сумме погашенных %% */
    summ_k = summ_k - vPrmValDec.

    if summ_k gt 0
    THEN result_l[pj - pn] = result_l[pj - pn] - summ_k.

    if result_l[pj - pn] lt 0
    THEN result_l[pj - pn]  = 0.

    ASSIGN
        mvar[pj - pn] = ""
        is-ok         = TRUE
    .

    RETURN.

end PROCEDURE.

/* Оплата в срок, начисленных по балансу процентов by Om*/
PROCEDURE НачБалСрок:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
  DEFINE VARIABLE h_templ AS handle NO-UNDO.
  DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
  DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.


  IF NOT Pars-ValidParam(1) THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).
    vGlc = Pars-GetString(0).
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
      RUN Pars-SetResult ( 0 ).
      is-ok             = TRUE.
    RETURN.
  END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                           buffer loan).

/* Обнуление суммы проводки */
  result_l[pj - pn] = 0.

/* "+" По параметру 33 */
  find last loan-var of loan where
    loan-var.amt-id EQ 33 and
    loan-var.since  le wop.con-date
  no-lock NO-ERROR.
  if AVAIL loan-var then
    result_l[pj - pn] = result_l[pj - pn] + loan-var.balance.

/* "-" Операция 77 */
  for each loan-int of loan where
    loan-int.mdate EQ wop.con-date and
    loan-int.id-d  EQ 6 and
    loan-int.id-k  EQ 35
  no-lock:
        result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
  END.

/* "+" Операция 65  */
  for each loan-int of loan where
    loan-int.mdate EQ wop.con-date and
    loan-int.id-d  EQ 33 and
    loan-int.id-k  EQ 32
  no-lock:
    result_l[pj - pn] = result_l[pj - pn] + loan-int.amt-rub.
  END.

/* "-" Операция 81 */
  for each loan-int of loan where
    loan-int.mdate EQ wop.con-date and
    loan-int.id-d  EQ 24 and
    loan-int.id-k  EQ 33 no-lock:
  result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
  END.

/* "-" Операция 98 */
  for each loan-int of loan where
    loan-int.mdate EQ wop.con-date and
    loan-int.id-d  EQ 10 and
    loan-int.id-k  EQ 33
  no-lock:
    result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
  END.

/* Операция 114 - Простить требования*/
  for each loan-int of loan where
    loan-int.mdate EQ wop.con-date and
    loan-int.id-d  EQ 32 and
    loan-int.id-k  EQ 33
  no-lock:
    result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
  END.

/* "+" По параметру 34 */
  find last loan-var of loan where
    loan-var.amt-id EQ 34 and
    loan-var.since  le wop.con-date
  no-lock NO-ERROR.
  if AVAIL loan-var then
    result_l[pj - pn] = result_l[pj - pn] + loan-var.balance.

/* "-" Операция 82 */
  for each loan-int of loan where
    loan-int.mdate EQ wop.con-date and
    loan-int.id-d  EQ 24 and
    loan-int.id-k  EQ 34
  no-lock:
    result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
  END.

/* "-" Операция 99 */
  for each loan-int of loan where
    loan-int.mdate EQ wop.con-date and
    loan-int.id-d  EQ 10 and
    loan-int.id-k  EQ 34
  no-lock:
    result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
  END.

  mvar[pj - pn]     = "".
  is-ok = TRUE.
END PROCEDURE.

/* Списание просроченных процентов с баланса by Om */
PROCEDURE СпПросПр:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
  DEFINE VARIABLE h_templ AS handle NO-UNDO.
  DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
  DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

  IF NOT Pars-ValidParam(1) THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).
    vGlc = Pars-GetString(0).
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
      RUN Pars-SetResult ( 0 ).
      is-ok             = TRUE.
      RETURN.
  END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                           buffer loan).



  result_l[pj - pn] = 0.
/* По параметру 10 */
  find last loan-var of loan where
    loan-var.amt-id EQ 10 and
    loan-var.since  le wop.con-date
  no-lock NO-ERROR.
  if AVAIL loan-var then
    result_l[pj - pn] = result_l[pj - pn] + loan-var.balance.

/* Проводимые операции по параметру 10 */
  for each loan-int of loan where
    loan-int.mdate EQ wop.con-date and
    (loan-int.id-d EQ 10 or
     loan-int.id-k EQ 10)
  no-lock:
  if loan-int.id-d EQ 10 then
    result_l[pj - pn] = result_l[pj - pn] + loan-int.amt-rub.
  ELSE if loan-int.id-k EQ 10 then
    result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
  END.
  mvar[pj - pn]     = "".

  is-ok = TRUE.
END PROCEDURE.

/* Списание требований до выяснения и требований по процентам с баланса by Om */
PROCEDURE СписТрБал:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE h_templ AS handle NO-UNDO.
    DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
    DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

    IF NOT Pars-ValidParam(1) THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).
    vGlc = Pars-GetString(0).
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
        RUN Pars-SetResult ( 0 ).
        is-ok             = TRUE.
        RETURN.
    END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer loan).

    /* По параметру 34: требования по оплате %% на до выяснении */
    find last loan-var of loan where
        loan-var.amt-id EQ 34 and
        loan-var.since  le wop.con-date
    no-lock NO-ERROR.

    result_l[pj - pn] = if AVAIL loan-var
        THEN loan-var.balance
        ELSE 0.

    /* Списано требований до выяснения с баланса */
    for each loan-int of loan where
        loan-int.mdate EQ wop.con-date and
        loan-int.id-d  EQ 24 and
        loan-int.id-k  EQ 34
    no-lock:
        result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
    END.

    /* По параметру 33: требования по оплате %% */
    find last loan-var of loan where
        loan-var.amt-id EQ 33 and
        loan-var.since  le wop.con-date
    no-lock NO-ERROR.
    if AVAIL loan-var
        THEN result_l[pj - pn] = result_l[pj - pn] + loan-var.balance.

    /* Проводимые опреации по параметрам 33 & 34 */
    for each loan-int of loan where
        loan-int.mdate EQ wop.con-date and
        loan-int.id-d  EQ 24 and
        loan-int.id-k  EQ 33
    no-lock:
        result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
    END.

    /* Операция 114 - Простить требования*/
    for each loan-int of loan where
        loan-int.mdate EQ wop.con-date and
        loan-int.id-d  EQ 32 and
        loan-int.id-k  EQ 33
    no-lock:
        result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
    END.

    /* 77 Операция: средства по оплате требований по %% */
    for each loan-int of loan where
        loan-int.mdate EQ wop.con-date and
        loan-int.id-d  EQ 6 and
        loan-int.id-k  EQ 35
    no-lock:
        result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
    END.

    /* 115 Операция: Прощение требований + сред. нач. на бал. */
    if loan.since = wop.con-date
    THEN DO:
        for each loan-int of loan where
            loan-int.mdate EQ wop.con-date and
            loan-int.id-d  EQ 33 and
            loan-int.id-k  EQ 32
        no-lock:
            result_l[pj - pn] = result_l[pj - pn] + loan-int.amt-rub.
        END.
    END.

    mvar[pj - pn]     = "".
    is-ok = TRUE.
END PROCEDURE.

/*  Что делает: Получение "свободных процентов", т.е. процентов,
**              которые должен клиент, за исключением тех,
**              которые вынесены на требование.
**  Синтаксис : ЗачВнеБал (<начзначение договора>)
**  Автор     : Om 07/06/2002
**  Пример    : ЗачВнеБал ("Кредит")
*/
PROCEDURE ЗачВнеБал:

    def output param is-ok AS logical NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE h_templ     AS handle  NO-UNDO.
    DEFINE VARIABLE ost-count   AS INT64     NO-UNDO.
    DEFINE VARIABLE ost         AS INT64 extent 12 initial [4,8,9,11,12,14,15,17,18,20,81,82] NO-UNDO.
    DEFINE VARIABLE fl-r        AS logical NO-UNDO.
    DEFINE VARIABLE summ_k      AS decimal NO-UNDO.
    DEFINE VARIABLE vSetValChar AS CHAR    NO-UNDO. /* Значение настроечного параметра. */
    DEFINE VARIABLE vPrmValDec  AS dec     NO-UNDO. /* Остаток параметра на дату. */
    DEFINE VARIABLE vDbSumDec   AS dec     NO-UNDO. /* Не используется. */
    DEFINE VARIABLE vCrSumDec   AS dec     NO-UNDO. /* Не используется. */
    DEFINE VARIABLE ext AS CHAR no-undo .
    DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
    DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

    if NOT pars-validparam(1)
    THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).
    vGlc = Pars-GetString(0).
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
          RETURN.
        END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer loan).

    {zachvnebal.calc
       &result = "result_l[pj - pn]"
       &op-date = "wop.con-date"
       }

    ASSIGN
        mvar[pj - pn]   = ""
        is-ok           = TRUE
    .
    RETURN.

END PROCEDURE.
&ENDIF

&IF DEFINED(NEW_PARSER) = 0 &THEN
/* Доначисленные проценты на балансе */
PROCEDURE БалД:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
  DEFINE VARIABLE h_templ AS handle NO-UNDO.
  DEFINE VARIABLE fl-r AS logical NO-UNDO.
  DEFINE VARIABLE summ_k AS decimal NO-UNDO.
  DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
  DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.


    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).
    vGlc = Pars-GetString(0).
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
        END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer loan).


  IF NOT Pars-ValidParam(1) THEN RETURN.


  {round_l.i &fl=fl-r}{round_l.i &fl=fl-r}
/* Добавка к сумме предыдущих проводок */
  result_l[pj - pn] = 0.
  find term-obl {wh-t &f=term-obl &c="/*"} and term-obl.end-date EQ wop.con-dat and
   term-obl.idnt EQ 1 no-lock NO-ERROR.
  if AVAIL term-obl then
    result_l[pj - pn] = result_l[pj - pn] +
     (if NOT fl-r THEN loan.interest[1] ELSE round(loan.interest[1],0)).

    find last loan-var of loan where
        loan-var.amt-id EQ 4 and
        loan-var.since  le wop.con-date
    no-lock NO-ERROR.
    if AVAIL loan-var then
        result_l[pj - pn] = result_l[pj - pn] + loan-var.balance.

    for each loan-int of loan where
        loan-int.mdate EQ wop.con-dat and
        (loan-int.id-d EQ 4 or loan-int.id-k EQ 4)
    no-lock:
        if loan-int.id-d EQ 4 then
            result_l[pj - pn] = result_l[pj - pn] + loan-int.amt-rub.
        ELSE if loan-int.id-k EQ 4 then
            result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
    END.

    find last loan-var of loan where
        loan-var.amt-id EQ 16 and
        loan-var.since  le wop.con-date
    no-lock NO-ERROR.
    if AVAIL loan-var then
        result_l[pj - pn] = result_l[pj - pn] + loan-var.balance.

    for each loan-int of loan where
        loan-int.mdate EQ wop.con-dat and
        (loan-int.id-d EQ 16 or loan-int.id-k EQ 16)
    no-lock:

        if loan-int.id-d EQ 16 then
            result_l[pj - pn] = result_l[pj - pn] + loan-int.amt-rub.
        ELSE if loan-int.id-k EQ 16 then
            result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
    END.

    find last loan-var
        {wh-t &f=loan-var &i=6} and
        loan-var.since le wop.con-date
    no-lock NO-ERROR.
    if AVAIL loan-var
        THEN summ_k = - loan-var.balance.
        ELSE summ_k = 0.

    for each loan-int of loan where
        loan-int.id-k  EQ 6 and
        loan-int.id-d  EQ 5 and
        loan-int.mdate EQ wop.con-date
    no-lock:
        summ_k = summ_k + loan-int.amt.
    END.

    for each loan-int of loan where
        loan-int.id-d  EQ 30 and
        loan-int.id-k  EQ 29 and
        loan-int.mdate EQ wop.con-date
    no-lock:
        summ_k = summ_k - loan-int.amt.
    END.

    for each loan-int of loan where
        loan-int.id-d  EQ 6 and
        loan-int.id-k  EQ 35 and
        loan-int.mdate EQ wop.con-date
    no-lock:
        summ_k = summ_k - loan-int.amt.
    END.

    for each loan-int of loan where
        loan-int.id-d  EQ 6 and
        loan-int.id-k  EQ 10 and
        loan-int.mdate EQ wop.con-date
    no-lock:
        summ_k = summ_k - loan-int.amt.
    END.
    if summ_k gt 0 then
        result_l[pj - pn] = result_l[pj - pn] - summ_k.

/* "-" 83 операция, если таковая проводка сегодня проводилась */
    for each loan-int of loan where
        loan-int.mdate EQ wop.con-date and
        loan-int.id-d  EQ 29 and
        loan-int.id-k  EQ 30
    no-lock:
        result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
    END.

    if result_l[pj - pn] lt 0 THEN result_l[pj - pn] = 0.

    mvar[pj - pn]     = "".

    is-ok = TRUE.
END PROCEDURE.
&ENDIF

&IF  DEFINED(NEW_PARSER) = 0 OR
    (DEFINED(NEW_PARSER) > 0 AND DEFINED(PLOAN_LIB) > 0) &THEN
/* Начисление процентов на внебалансе by Om */
PROCEDURE НачПрВ:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
  DEFINE VARIABLE h_templ AS handle NO-UNDO.
  DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
  DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

  IF NOT Pars-ValidParam(1) THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).
    vGlc = Pars-GetString(0).
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
        END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer loan).



  result_l[pj - pn] = 0. /* Обнуление суммы */

/* остаток по параметру 29 */
    find last loan-var of loan where
        loan-var.amt-id EQ 29 and
        loan-var.since  le wop.con-date
    no-lock NO-ERROR.
    if AVAIL loan-var then
        result_l[pj - pn] = result_l[pj - pn] + loan-var.balance.

    /* "+" операции начисления "-" операции списания */
    for each loan-int of loan where
        loan-int.mdate   EQ wop.con-date and
          (loan-int.id-d EQ 29 or
           loan-int.id-k EQ 29)
    no-lock:
        if loan-int.id-d EQ 29 then
            result_l[pj - pn] = result_l[pj - pn] + loan-int.amt-rub.
        ELSE if loan-int.id-k EQ 29 then
            result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
    END.

  mvar[pj - pn]     = "".
  is-ok = TRUE.
END PROCEDURE.
&ENDIF

&IF  DEFINED(NEW_PARSER) = 0 &THEN
PROCEDURE СписВ:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
  DEFINE VARIABLE h_templ AS handle NO-UNDO.
  DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
  DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

  IF NOT Pars-ValidParam(1) THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).
    vGlc = Pars-GetString(0).
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:

        END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer loan).


  result_l[pj - pn] = 0. /* Обнуление суммы */

  if NOT AVAIL loan THEN DO:
    is-ok = true.
    RETURN.
  END.
  for each loan-int of loan where
    loan-int.id-d  EQ 30 and
    loan-int.id-k  EQ 29 and
    loan-int.mdate EQ wop.con-date
  no-lock:
    result_l[pj - pn] = result_l[pj - pn] + loan-int.amt.
  END.
  mvar[pj - pn]     = "".
  is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Пересчитывает эквивалент из одной валюты в другую, по указанному курсу.
  Синтаксис : Пересчет(Сумма,Вал1,Вал2,Название_Курса)
 *            Пересчет(Сумма,Вал1,Вал2)                Название_Курса = УЧЕТНЫЙ
 *            Пересчет(Сумма,Вал1)                     Вал2 = tcur, Название_Курса = УЧЕТНЫЙ
*/
PROCEDURE Пересчет:
   DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO.

   DEFINE VARIABLE vCurr1 AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vCurr2 AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vKurs  AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vSumm  AS DECIMAL    NO-UNDO.

   IF NOT (Pars-ValidParam(2) OR
           Pars-ValidParam(3) OR
           Pars-ValidParam(4))
   THEN RETURN.

   assign
      vSumm  = Pars-GetDec ( 0 )
      vCurr1 = Pars-GetStringFormatted ( 1, "999" )
      vCurr2 = if pn < 2 THEN tcur      ELSE Pars-GetStringFormatted ( 2, "999" )
      vKurs  = if pn < 3 THEN 'УЧЕТНЫЙ' ELSE Pars-GetString ( 3 )
      .

   FIND FIRST code WHERE code.class = "Курсы" AND code.code = vKurs NO-LOCK NO-ERROR.
   IF NOT AVAIL code THEN DO:
      MESSAGE "В шаблоне проводки N " + STRING(wop.op-templ) + " ссылка на несуществующий курс '" + vKurs + "'" VIEW-AS ALERT-BOX ERROR.
      RETURN.
   END.
   /* находим первую валюту */
   IF vCurr1 NE "{&in-NC-Code}" AND vCurr1 NE "" THEN DO:
      FIND LAST instr-rate WHERE instr-rate.instr-cat = "currency" AND
                                 instr-rate.rate-type = vKurs AND
                                 instr-rate.instr-code = vCurr1  AND
                                 instr-rate.since <= in-op-date SHARE-LOCK NO-WAIT NO-ERROR.
      IF NOT AVAIL instr-rate THEN DO:
         MESSAGE "Шаблон №" wop.op-templ ": Курс" '"' + vKurs + '"' "валюты"  vCurr1 "не установлен!" VIEW-AS ALERT-BOX ERROR.
         RETURN.
      END.
      ASSIGN
         vSumm = vSumm * instr-rate.rate-instr / instr-rate.per.
   END.
   /* находим вторую валюту */
   IF vCurr2 NE "{&in-NC-Code}" AND vCurr2 NE "" THEN DO:
      FIND LAST instr-rate WHERE instr-rate.instr-cat = "currency" AND
                                 instr-rate.rate-type = vKurs AND
                                 instr-rate.instr-code = vCurr2 AND
                                 instr-rate.since <= in-op-date SHARE-LOCK no-wait NO-ERROR.
      IF NOT AVAIL instr-rate THEN DO:
         MESSAGE "Шаблон №" wop.op-templ ": Курс" '"' + vKurs + '"' "валюты"  vCurr2 "не установлен!" VIEW-AS ALERT-BOX ERROR.
         RETURN.
      END.
      ASSIGN
         vSumm = (vSumm / instr-rate.rate-instr) * instr-rate.per.
   END.

   RUN Pars-SetResult ( vSumm ).

   is-ok = TRUE.
END PROCEDURE.

/* Проверка срока на допустимость операции */
PROCEDURE Срок:

   DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE h_templ AS HANDLE NO-UNDO.
   DEFINE VARIABLE vStr    AS CHAR  NO-UNDO.
   DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

   IF NOT Pars-ValidParam(1) THEN RETURN.

   /* Определение правильного применения функции,
   ** формат private-data */
   RUN LOAN_VALID_HANDLE (INPUT-OUTPUT h_templ).
    vGlc = "Кредит".
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
        END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer loan).


   is-ok = TRUE.

   IF NOT AVAIL loan THEN
   DO:
      RUN Pars-SetResult ( 0 ).
      RETURN.
   END.

   RUN RE_TERM_OBL IN h_loan (loan.contract,
                              loan.cont-code,
                              1,
                              wop.con-date,
                              BUFFER term-obl).

   vStr = FGetSetting("Просроч",?,?).

   IF Pars-GetDec(0) = 1 THEN
   DO:

      result_l[pj - pn] = IF AVAIL term-obl AND
                             MONTH(term-obl.end-date) = MONTH(wop.con-date)
                          THEN 1
                          ELSE IF vStr <> ? AND
                                   AVAIL term-obl
                                   AND DAY(wop.con-date) = INT64(setting.val)
                               THEN 1
                               ELSE  0.
      RETURN.
   END.

   ASSIGN
      result_l[pj - pn] = IF vStr <> ? THEN
                             IF DAY(wop.con-date) = INT64(vStr)
                             THEN 1
                             ELSE 0
                          ELSE 0
      mvar[pj - pn]     = ""
      .

END PROCEDURE.

/*
  Что делает: Сумма заданной проводки при наличии более одной проводки на один шаблон
 *            Поиск по номеру шаблона и кассовому символу.
  Синтаксис : СуммаКС(Номер_Шаблона, Маска_Касс_Символа)
  Created: 25/03/99 17:11 Sema
*/

PROCEDURE СуммаКС:
   DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO.

   DEFINE VARIABLE vOpTempl    AS INT64    NO-UNDO.
   DEFINE VARIABLE vKassSymbol AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vResult     AS DECIMAL    NO-UNDO.

   IF NOT (Pars-ValidParam(2)) THEN RETURN.

   ASSIGN
      vOpTempl    = Pars-GetInt ( 0 )
      vKassSymbol = Pars-GetString ( 1 )
      vResult     = 0
      is-ok       = true
   .

   FOR EACH xwop WHERE
            xwop.op-templ = vOpTempl
        AND CAN-DO(vKassSymbol, xwop.symbol)
      NO-LOCK:
      ASSIGN
         vResult = vResult + if xwop.currency EQ "" THEN xwop.amt-rub ELSE xwop.amt-cur
         tcur = xwop.currency.
   END.
   RUN Pars-SetResult ( vResult ).
END PROCEDURE.


/* Следующие три функции (Вал2, Ком2, Курс2 - для валюты, в которой есть символы (d13, r21 и тд) */
/*
  Что делает: Код валюты из заданной проводки (возвращает строку а не число) - специально для ПТБ
  Синтаксис : Вал2(Номер_Проводки)
*/

PROCEDURE Вал2:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

  IF NOT Pars-ValidParam(1) THEN RETURN.

  if result_l[pj] NE 0 THEN DO:
    FIND FIRST xwop WHERE xwop.op-templ = INT64(result_l[pj]) NO-LOCK NO-ERROR.
    if AVAIL xwop then
     mvar[pj] = """" + (IF xwop.currency = "" THEN vNatCurrChar ELSE xwop.currency) + """".
    ELSE  RETURN.
    assign result_l[pj] = INT64(trim(mvar[pj], """")) NO-ERROR.
    if ERROR-STATUS:ERROR
    THEN assign
           result_l[pj]       = 0
           ERROR-STATUS:ERROR = false
          .
  END.
/* --- */
  is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Возвращает курс (валюта берется как строка)
  Синтаксис : Курс2(Тип_Курса)
*/

PROCEDURE Курс2:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

  IF NOT (Pars-ValidParam(1) OR Pars-ValidParam(2)) THEN RETURN.
/* --- */
  FIND FIRST code WHERE code.class = "Курсы" AND code.code = mvar[pj] NO-LOCK NO-ERROR.
  IF NOT AVAIL code THEN DO:
    MESSAGE "В шаблоне проводки N " + STRING(wop.op-templ) + " ссылка на несуществующий курс '" + mvar[pj] + "'" VIEW-AS ALERT-BOX ERROR.
    RETURN.
  END.
/*  IF tcur = code.val THEN*/ tcur = IF pn = 0 THEN wop.currency ELSE (if mvar[pj - 1] EQ "" THEN STRING(result_l[pj - 1]) ELSE trim(mvar[pj - 1], """")).
    IF tcur <> "" or tcur = vNatCurrChar THEN DO:
    FIND LAST instr-rate WHERE instr-rate.instr-cat = "currency" AND
                               instr-rate.rate-type = mvar[pj] AND
                               instr-rate.instr-code = tcur AND
                               instr-rate.since <= in-op-date SHARE-LOCK no-wait NO-ERROR.
    IF NOT AVAIL instr-rate THEN DO:
      MESSAGE "Курс ' " + mvar[pj] + "' валюты " + tcur + " не установлен!" VIEW-AS ALERT-BOX ERROR.
      RETURN.
    END.
  END.
  RUN Pars-SetResult ( IF tcur <> "" THEN instr-rate.rate-instr / instr-rate.per ELSE 1 ).
  tcur = code.val.
/* --- */
  is-ok = TRUE.
END PROCEDURE.
/*
  Что делает: Счет дебета из указанной проводки (возврат как строка)
  Синтаксис : Дб(Номер_Проводки)
*/

PROCEDURE Дб2:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    IF NOT Pars-ValidParam(1) THEN RETURN.
/* --- */
    FIND FIRST xwop WHERE xwop.op-templ EQ INT64(result_l[pj]) NO-LOCK NO-ERROR.
    IF AVAIL xwop THEN
       RUN Pars-SetACCTResult("""" + xwop.acct-db + """").
    ELSE
       RETURN.
/* --- */
  is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Счет кредита из указанной проводки (возврат как строка)
  Синтаксис : Кр(Номер_Проводки)
*/

PROCEDURE Кр2:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

  IF NOT Pars-ValidParam(1) THEN RETURN.
/* --- */
  FIND FIRST xwop WHERE xwop.op-templ = INT64(result_l[pj]) NO-LOCK NO-ERROR.
  IF AVAIL xwop THEN
     RUN Pars-SetACCTResult("""" + xwop.acct-cr + """").
  ELSE
     RETURN.
  /* --- */
  is-ok = TRUE.
END PROCEDURE.

/* *** */

/*
  Что делает: Сумма документов, созданных из одного шаблона заданной проводки.
  Синтаксис : СуммаД(Номер_Проводки)
*/

PROCEDURE СуммаД:
   DEFINE OUTPUT PARAM is-ok AS LOGICAL NO-UNDO.

   DEFINE VARIABLE vTag     AS INT64    NO-UNDO.
   DEFINE VARIABLE vResult  AS DECIMAL    NO-UNDO.

   IF NOT (Pars-ValidParam(1)) THEN RETURN.

   assign
      vTag    = Pars-GetInt(0)
      vResult = 0
   .

   FOR EACH xwop WHERE xwop.op-templ EQ vTag NO-LOCK:
      ASSIGN
         vresult = vresult + (IF xwop.amt-cur = ? THEN 0 ELSE xwop.amt-cur)
         tcur = xwop.currency
      .
   END.
   RUN Pars-SetResult (vResult).
   is-ok = TRUE.
END PROCEDURE.

/* Что делает: Возвращает курс из переменной sprate
 *  Синтаксис : КурсПр()
 * Sema 10/03/99 16:00
 */
PROCEDURE КурсПр:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

  IF NOT Pars-ValidParam(0) THEN RETURN.

  RUN Pars-SetResult ( sprate ).
/* --- */
  is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Возвращает ноль, если коммиссия с получателя, иначе единицу
  Синтаксис : КоммПлИстКом()
*/

PROCEDURE КоммПлИстКом:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
  DEFINE VARIABLE ht AS handle NO-UNDO.

  IF NOT Pars-ValidParam(0) THEN RETURN.

  ht = session:first-procedure.
  do while ht <> ?:
    if ht:file-name = "g-commgt.p" THEN leave.
    ht = ht:next-sibling.
  END.
  IF NOT VALID-HANDLE(ht) THEN RETURN.
  run GetRealPayer in ht (output result_l[pj - pn]).
  mvar[pj - pn]     = "".
/* --- */
  is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Возвращает кол-во дней, за которые надо считать пеню
  Синтаксис : КоммПлПроср()
*/

PROCEDURE КоммПлПроср:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
  DEFINE VARIABLE ht AS handle NO-UNDO.

  IF NOT Pars-ValidParam(0) THEN RETURN.

  ht = session:first-procedure.
  do while ht <> ?:
    if ht:file-name = "g-commgt.p" THEN leave.
    ht = ht:next-sibling.
  END.
  IF NOT VALID-HANDLE(ht) THEN RETURN.
  run GetRealDelay in ht (output result_l[pj - pn]).
  mvar[pj - pn]     = "".
/* --- */
  is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Возвращает комиссию
  Синтаксис : КоммПлКомм(КоммК|КоммП)
*/

PROCEDURE КоммПлКомм:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
  DEFINE VARIABLE ht AS handle NO-UNDO.

  IF NOT Pars-ValidParam(1) THEN RETURN.

  ht = session:first-procedure.
  do while ht <> ?:
    if ht:file-name = "g-commgt.p" THEN leave.
    ht = ht:next-sibling.
  END.
  IF NOT VALID-HANDLE(ht) THEN RETURN.
  run GetRealComm in ht (mvar[pj], output result_l[pj - pn]).
  mvar[pj - pn]     = "".
/* --- */
  is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Возврат номера счета (из указанного и его парного) у кот. остаток больше
  Синтаксис : ПарныйСч(Счет,Валюта,<входящий/исходящий>)
              ПарныйСч(Счет,<входящий/исходящий>) - валюта берется из счета
              ПарныйСч(Счет) - валюта берется из счета, учитывается входящий остаток
*/
PROCEDURE ПарныйСч:
   DEFINE OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   {&type-er} = "".
   IF pn <> 1 and pn <> 2 and pn <> 3 THEN DO:
     {&type-er} = {&EGMBadParamCount}.
     RETURN.
   END. ELSE pn = pn - 1.

   DEFINE VARIABLE in-acct     AS CHAR NO-UNDO.
   DEFINE VARIABLE in-currency AS CHAR NO-UNDO.
   DEFINE VARIABLE in-flagc    AS CHAR NO-UNDO.
   DEFINE VARIABLE in-flag     AS LOG  NO-UNDO.
   DEFINE VARIABLE ost-1       AS DECIMAL NO-UNDO.
   DEFINE VARIABLE ost-2       AS DECIMAL NO-UNDO.

   ASSIGN
      in-acct = Pars-GetString(0)
   .

   IF pn = 1 THEN /* 2 параметра */
      ASSIGN
         in-flagc    = Pars-GetString(1)
         in-currency = ?
         in-flag     = LOOKUP(in-flagc, "входящий,1,yes,да,так точно,несомненно") > 0
      .
   ELSE IF pn = 2 THEN /* 3 параметра */
      ASSIGN
         in-currency = Pars-GetString(1)
         in-flagc    = Pars-GetString(2)
         in-flag     = LOOKUP(in-flagc, "входящий,1,yes,да,так точно,несомненно") > 0
      .
   ELSE  /* 1 параметр */
      ASSIGN
         in-currency = ?
         in-flagc    = "входящий"
         in-flag     = YES
      .

   IF in-currency EQ ? THEN DO:
      {find-act.i
         &acct = in-acct
      }
   END.
   ELSE DO:
      {find-act.i
         &acct = in-acct
         &curr = in-currency
      }
   END.
   IF NOT AVAIL acct THEN DO:
      RUN Pars-SetACCTResult ("").
      is-ok = YES.
      RETURN.
   END.

   RUN acct-pos in h_base (acct.acct,acct.currency,?,in-op-date - INT64(in-flag),gop-status).
   IF RETURN-VALUE NE "" /* Om 22.12.00 */
      THEN RETURN.

   ost-1 = IF acct.currency EQ "" THEN sh-bal ELSE sh-val.

   RELEASE xacct1.
   IF {assigned acct.contr-acct} THEN DO:
      {find-act.i
         &bact = xacct1
         &acct = acct.contr-acct
         &curr = acct.currency
      }
   END.
   IF NOT AVAIL xacct1 THEN DO:
      RUN Pars-SetACCTResult (acct.acct).
   END.
   ELSE DO:
      RUN acct-pos in h_base (xacct1.acct,xacct1.currency,?,in-op-date - INT64(in-flag),gop-status).
      IF RETURN-VALUE NE "" /* Om 22.12.00 */
         THEN RETURN.

      ost-2 = IF acct.currency EQ "" THEN sh-bal ELSE sh-val.
      RUN Pars-SetACCTResult (IF ABS(ost-1) > ABS(ost-2) THEN acct.acct ELSE xacct1.acct).
   END.

   is-ok = TRUE.
END PROCEDURE.

/*
    Определяет номер скрытых проводок по документам
    приеняется в op_flt.p

    Синтаксис СП(<номер проводки в исходном документе>)

*/
PROCEDURE СП:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    IF NOT Pars-ValidParam(1) THEN RETURN.

    result_l[pj] = INT64(result_l[pj]) + 500.
    mvar[pj - pn]     = "".

    is-ok = TRUE.
END PROCEDURE.

/*
    Расчет рублевого эквивалента остатка по кредитному договору.

    формат private-data = "loan.contract, loan.cont-code,loan_flt"

    Om 10/03/00

*/
PROCEDURE ОстДогР:

    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE ph AS handle NO-UNDO.
    DEFINE VARIABLE loan_ost AS decimal NO-UNDO.
    DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
    DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

    IF NOT Pars-ValidParam(0) THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output ph).
    vGlc = entry(1,ph:PRIVATE-DATA) NO-ERROR.
    vGl  = entry(2,ph:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(ph)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
          RETURN.
        END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer loan).


    IF NOT AVAIL loan or
    (avail loan and loan.since NE wop.con-date)
    THEN RETURN.

    find last loan-var of loan where loan-var.amt-id EQ 0 no-lock NO-ERROR.
    IF AVAIL loan-var THEN loan_ost = loan-var.balance.

    find last loan-var of loan where loan-var.amt-id EQ 13 no-lock NO-ERROR.
    IF AVAIL loan-var THEN loan_ost = loan_ost + loan-var.balance.

    IF loan.currency NE "" THEN DO:

        find last instr-rate where
            instr-rate.instr-cat  EQ "currency"    and
            instr-rate.instr-code EQ loan.currency and
            instr-rate.rate-type  EQ "Учетный"     and
            instr-rate.since      le wop.value-date
        no-lock NO-ERROR.
        IF AVAIL instr-rate then
            loan_ost = loan_ost / instr-rate.per * instr-rate.rate-instr.

    END.

    RUN Pars-SetResult (loan_ost).

    is-ok = TRUE.
END PROCEDURE.

/* Значение коэффициента резервирования по договору за текущий опер.день.
   формат private-data = "loan.contract, loan.cont-code,loan_flt"
   amam 14/07/04
*/
PROCEDURE ПрРиск:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE ph        AS HANDLE NO-UNDO.
    DEFINE VARIABLE mRsrvRate AS DEC    NO-UNDO.
    DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
    DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

    IF NOT Pars-ValidParam(0) THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    RUN LOAN_VALID_HANDLE (input-output ph).
    vGlc = entry(1,ph:PRIVATE-DATA) NO-ERROR.
    vGl  = entry(2,ph:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(ph)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:

          RETURN.
        END.
    END.

    mRsrvRate = LnRsrvRate(vGlc,
                           vGl,
                           in-op-date
                          ).
    RUN Pars-SetResult(mRsrvRate).
    is-ok = TRUE.
END PROCEDURE.

/* Расчет процентов по ставке рефинансирования Nata*/
PROCEDURE НачРефДеп:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
  DEFINE VARIABLE h_templ AS handle NO-UNDO.
  DEFINE VARIABLE ost-count AS INT64 NO-UNDO.
  DEFINE VARIABLE ost AS INT64 extent 10 initial [4,8,9,11,12,14,15,17,18,20] NO-UNDO.
  DEFINE VARIABLE fl-r AS logical NO-UNDO.
  DEFINE VARIABLE summ_k AS decimal NO-UNDO.
  DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
  DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).
    vGlc = Pars-GetString(0).
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:

        END.
    END.
    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                           buffer loan).
  IF NOT Pars-ValidParam(1) THEN RETURN.

  run nach-r.p(loan.contract,loan.cont-code,wop.con-date,output result_l[pj - pn]).
  mvar[pj - pn] = "".
  is-ok = TRUE.
END PROCEDURE.

/******************************************************************************/
/*                          НАЧИСЛЕНИЕ НАЛОГОВ                                */
/******************************************************************************/

/* Процедуры БазаНалог, БазаНалогД и ПереРасчБазаНалог были перенесены отсюда в dpspars.p */

PROCEDURE НачРефДепОб:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
  DEFINE VARIABLE h_templ AS handle NO-UNDO.
  DEFINE VARIABLE ost-count AS INT64 NO-UNDO.
  DEFINE VARIABLE ost AS INT64 extent 10 initial [4,8,9,11,12,14,15,17,18,20] NO-UNDO.
  DEFINE VARIABLE fl-r AS logical NO-UNDO.
  DEFINE VARIABLE summ_k AS decimal NO-UNDO.
  DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
  DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

  IF NOT Pars-ValidParam(1) THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).
    vGlc = Pars-GetString(0).
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:

        END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                           buffer loan).



  run nach-ro.p(loan.contract,loan.cont-code,wop.con-date,output result_l[pj - pn]).
  mvar[pj - pn]     = "".
  is-ok = TRUE.
END PROCEDURE.

/*
* Что делает: Истина, если присутствует определенная корреспонденция счетов.
* Синтаксис : КоррСчетовДБ (<ДБ>,[<ДБ>,<ДБ>,<ДБ>,<ДБ>,]<КР>,<валюта>[,<признак учета переоценки>])
* Автор     : Om 27/07/00
* Пример    : КоррСчетовДБ (Дб(1), "20202810","")
* Пример    : КоррСчетовДБ (Дб(1), "2", "840","Нет") -
              найти определенную корреспонденцию счетов в интервале дат,
              но не учитывать переоценку.
*/
PROCEDURE КоррСчетовДБ:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE in_acct_db_lst AS CHAR                      NO-UNDO.
    DEFINE VARIABLE in_acct_cr     like acct.acct               NO-UNDO.
    DEFINE VARIABLE in_curr        like acct.currency           NO-UNDO.
    DEFINE VARIABLE is_reval       AS   CHAR          init "Да" NO-UNDO.  /* Учет переоценки. */
    DEFINE VARIABLE acct_count     AS   INT64                     NO-UNDO.  /* Список счетов дебета */

    DEFINE VARIABLE vAcct          AS   CHARACTER               NO-UNDO.

    IF pn lt 3
        THEN RETURN.

    /*  Инициализация переменных. */
    ASSIGN
        is_reval   = IF mvar[pj] EQ ""
                        THEN string (result_l[pj])
                        ELSE trim(mvar[pj], """'")
        acct_count = IF lookup (is_reval, "Да,Нет") NE 0
                        THEN 3
                        ELSE 2
        is_reval   = IF lookup (is_reval, "Да,Нет") NE 0
                        THEN is_reval
                        ELSE "Да"
        in_curr    = IF mvar[pj - acct_count + 2] EQ ""
                            THEN string (result_l[pj - acct_count + 2])
                            ELSE trim(mvar[pj - acct_count + 2], """'")
        in_curr    = IF in_curr EQ vNatCurrChar THEN "" ELSE in_curr
        in_acct_cr = IF mvar[pj - acct_count + 1] EQ ""
                            THEN string (result_l[pj - acct_count + 1])
                            ELSE trim(mvar[pj - acct_count + 1], """'")
   .

    do acct_count = (pj - acct_count) to (pj - pn + 1) by -1:
        vAcct = IF mvar[acct_count] EQ ""
                THEN string (result_l[acct_count])
                ELSE trim(mvar[acct_count], """'").
        in_acct_db_lst = IF in_acct_db_lst EQ ""
            THEN AddFilToAcct(vAcct,shFilial)
            ELSE in_acct_db_lst + "," + AddFilToAcct(vAcct,shFilial)
       .

    END.

    ASSIGN
       in_acct_cr        = FmtMskAddSuffix(in_acct_cr,"acct")
       pn                = pn - 1
       result_l[pj - pn] = 0
   .
    ENTRY_FND:
    do acct_count = 1 to num-entries(in_acct_db_lst):
        IF CAN-FIND(
            FIRST op-entry
                     WHERE op-entry.op-date   GE     beg-date
                       AND op-entry.op-date   LE     end-date
                       AND op-entry.currency  BEGINS in_curr
                       AND op-entry.acct-db   EQ     entry(acct_count, in_acct_db_lst)
                       AND CAN-DO(in_acct_cr,op-entry.acct-cr)
                       AND op-entry.filial-id EQ     dept.branch
                       AND ((is_reval EQ "Нет" AND
                            ((op-entry.currency NE ""   AND
                              op-entry.amt-cur  NE 0))  OR
                             (op-entry.currency EQ "")) OR
                            (is_reval EQ "Да"))
            NO-LOCK)
        THEN DO:
            result_l[pj - pn] = 1.
            leave ENTRY_FND.

        END.
    END.

    mvar[pj - pn] = STRING(result_l[pj - pn]).

    is-ok = TRUE.
END PROCEDURE.

/*
* Что делает: Истина, если присутствует определенная корреспонденция счетов.
* Синтаксис : КоррСчетовКР (<ДБ>,<КР>,[<КР>,<КР>,<КР>,<КР>,]<валюта>[,<признак учета переоценки>])
* Автор     : Om 27/07/00
* Пример    : КоррСчетовКР ("20202810",Кр(1),"")
* Пример    : КоррСчетовКР ("2",Кр(1),Кр(2),"840","Нет") -
              найти определенную корреспонденцию счетов в интервале дат,
              но не учитывать переоценку.
*/
PROCEDURE КоррСчетовКР:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE in_acct_cr_lst AS CHAR                      NO-UNDO.
    DEFINE VARIABLE in_acct_db     like acct.acct               NO-UNDO.
    DEFINE VARIABLE in_curr        like acct.currency           NO-UNDO.
    DEFINE VARIABLE is_reval       AS   CHAR          init "Да" NO-UNDO.  /* Учет переоценки. */
    DEFINE VARIABLE acct_count     AS   INT64                     NO-UNDO.  /* Список счетов дебета */

    DEFINE VARIABLE vAcct          AS   CHARACTER               NO-UNDO.

    IF pn lt 3
        THEN RETURN.
    /*  Инициализация переменных. */
    ASSIGN
        is_reval   = IF mvar[pj] EQ ""
                        THEN string (result_l[pj])
                        ELSE trim(mvar[pj], """'")
        acct_count = IF lookup (is_reval, "Да,Нет") NE 0
                        THEN 2
                        ELSE 1
        is_reval   = IF lookup (is_reval, "Да,Нет") NE 0
                        THEN is_reval
                        ELSE "Да"
        in_curr    = IF acct_count EQ 1
                        THEN IF mvar[pj] EQ ""
                            THEN string (result_l[pj])
                            ELSE trim(mvar[pj], """'")
                        ELSE IF mvar[pj - 1] EQ ""
                            THEN string (result_l[pj - 1])
                            ELSE trim(mvar[pj - 1], """'")
        in_curr    = IF in_curr EQ vNatCurrChar THEN "" ELSE in_curr
        in_acct_db = IF mvar[pj - pn + 1] EQ ""
                            THEN string (result_l[pj - pn + 1])
                            ELSE trim(mvar[pj - pn + 1], """'")
   .

    do acct_count = (pj - acct_count) to (pj - pn + 2) by -1:
        vAcct = IF mvar[acct_count] EQ ""
                THEN string (result_l[acct_count])
                ELSE trim(mvar[acct_count], """'").
        in_acct_cr_lst = IF in_acct_cr_lst EQ ""
            THEN AddFilToAcct(vAcct,shFilial)
            ELSE in_acct_cr_lst + "," + AddFilToAcct(vAcct,shFilial)
        .
    END.

    ASSIGN
        in_acct_db        = FmtMskAddSuffix(in_acct_db,shFilial)
        pn                = pn - 1
        result_l[pj - pn] = 0
   .
    ENTRY_FND:
    do acct_count = 1 to num-entries(in_acct_cr_lst):
        IF CAN-FIND(
            FIRST op-entry
                     WHERE op-entry.op-date   GE     beg-date
                       AND op-entry.op-date   LE     end-date
                       AND op-entry.currency  BEGINS in_curr
                       AND op-entry.acct-cr   EQ     entry(acct_count, in_acct_cr_lst)
                       AND CAN-DO(in_acct_db,op-entry.acct-db)
                       AND op-entry.filial-id EQ     dept.branch
                       AND ((is_reval EQ "Нет" AND
                            ((op-entry.currency NE "" AND
                              op-entry.amt-cur  NE 0)) OR
                             (op-entry.currency EQ "")) OR
                            (is_reval EQ "Да"))
            NO-LOCK)
        THEN DO:
            result_l[pj - pn] = 1.
            leave ENTRY_FND.

        END.
   .
    END.
    mvar[pj - pn] = STRING(result_l[pj - pn]).

    is-ok = TRUE.
END PROCEDURE.

/*
    * Что делает: Поиск ДР с определенным значением на счете.
    * Что делает: Истина, если найден доп реквизит <rek> со значением <val>
    * Что делает: На счете <acct>,<currency>
    * Синтаксис : ДопРекПоЗнач (<acct>,<currency>,<rek>,<val>)
    * Автор     : Om 28/07/00
    * Пример    : ДопРекПоЗнач (Дб(1),"","ddd","123")
*/
PROCEDURE ДопРекПоЗнач:

    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE in_acct   AS CHAR NO-UNDO.
    DEFINE VARIABLE in_curr   AS CHAR NO-UNDO.
    DEFINE VARIABLE in_code   AS CHAR NO-UNDO.
    DEFINE VARIABLE in_value  AS CHAR NO-UNDO.
    DEFINE VARIABLE vSurrChar AS CHAR NO-UNDO. /* Суррогат ДР */
    DEFINE VARIABLE vSigVal   AS CHAR NO-UNDO.

    IF NOT pars-validparam(4)
    THEN RETURN.

    /* Инициализация переменных. */
    ASSIGN
        in_acct  = IF mvar[pj - pn] EQ ""
                    THEN string (result_l[pj - pn])
                    ELSE trim(mvar[pj - pn], """'")
        in_curr  = IF mvar[pj - pn + 1] EQ ""
                    THEN string (result_l[pj - pn + 1])
                    ELSE trim(mvar[pj - pn + 1], """'")
        in_curr  = IF in_curr           EQ vNatCurrChar or
                      mvar[pj - pn + 1] EQ ""
                    THEN ""
                    ELSE in_curr
        in_code  = IF mvar[pj - pn + 2] EQ ""
                    THEN string (result_l[pj - pn + 2])
                    ELSE trim(mvar[pj - pn + 2], """'")
        in_value = IF mvar[pj - pn + 3] EQ ""
                    THEN string (result_l[pj - pn + 3])
                    ELSE trim(mvar[pj - pn + 3], """'")
        in_acct   = AddFilToAcct(in_acct,ShFilial)
        vSurrChar = in_acct + "," + in_curr
   .
    vSigVal = GetxAttrValueEx("acct", vSurrChar, in_code, "").

    /* Обработка записи. */
    ASSIGN
        result_l[pj - pn] = IF in_value EQ "-?" or
                               vSigVal  EQ in_value
                            THEN 1  /* Истина */
                            ELSE 0  /* Ложь */
        mvar[pj - pn] = STRING(result_l[pj - pn])
   .

    is-ok         = TRUE.
END PROCEDURE.


/*
    * Что делает: Возвращает значение параметра договора на дату.
    * Что делает: Если договор не пересчитан на требуемую дату возвращает ошибку.
    * Синтаксис : Прм (<код параметра>,<признак даты>,<текущие проценты>)
                  <признак даты>:
                  "ОД"  - дата опер. дня
                  "ПД"  - плановая дата
                  "КПМ" - значение будет расчитываться на дату окончания предыдущего месяца относительно
                          даты опер. дня
                  "ЧМ:<1-31>"  - значение будет рассчитываться на указанное число месяца опер.дня
                  <текущие проценты> (Необязательный параметр. По умолчанию Нет):
                  "Нет" - не учитывать проценты сохраненные в loan.interest[i]
                  "Да"  - учитывать проценты сохраненные в loan.interest[i]
                  <код параметра> - возможно перечисление параметров через запятую
    * Автор     : Om 05/10/00
    * Пример    : Прм (0, "ОД")
*/
PROCEDURE Прм:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    RUN parm_loan('ПРМ',OUTPUT is-ok).

END PROCEDURE.

/*
   *  процедура определения значения параметра договора соглашения при работе с периодами
   * Синтаксис : ПрмСогл (<код параметра>,<признак даты>,<текущие процценты>)
                  <признак даты>:
                  "ОД"  - дата опер. дня
                  "ПД"  - плановая дата
                  <текущие проценты> (по умолчанию Нет):
                  "Нет" - не учитывать проценты сохраненные в loan.interest[i]
                  "Да"  - учитывать проценты сохраненные в loan.interest[i]
                  <код параметра> - возможно перечисление параметров через запятую
   *  пример - определение остатка неиспользованного лимита : ПрмСогл("19","ПД")
*/
PROCEDURE  ПрмСогл .
   DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   RUN parm_loan('ПРМСогл',OUTPUT is-ok).

END PROCEDURE .

PROCEDURE parm_loan:
   DEFINE INPUT  PARAMETER vName  AS CHARACTER  NO-UNDO.
   DEFINE OUTPUT PARAMETER is-ok  AS LOGICAL    NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE in_param      AS INT64   NO-UNDO. /* Параметр по договору */
   DEFINE VARIABLE in_dt_pr      AS CHARACTER NO-UNDO. /* Признак требуемой даты */
   DEFINE VARIABLE vRateLog      AS LOGICAL   NO-UNDO. /* Учитывать проценты из массива */
   DEFINE VARIABLE vDbOpDec      AS DECIMAL   NO-UNDO. /* Е дб. операций (не используется) */
   DEFINE VARIABLE vCrOpDec      AS DECIMAL   NO-UNDO. /* Е кр. операций (не используется) */
   DEFINE VARIABLE vsumm          AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE summ          AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE ph            AS HANDLE    NO-UNDO.
   DEFINE VARIABLE vRec          AS RECID     NO-UNDO.
   DEFINE VARIABLE vParamlrate   AS CHARACTER NO-UNDO. /* Строка % ставок */
   DEFINE VARIABLE vParammint    AS CHARACTER NO-UNDO. /* Строка параметров являющихся процентами */
   DEFINE VARIABLE vAmtId        AS CHARACTER NO-UNDO. /* Коды параметров */
   DEFINE VARIABLE vAmtIdStr     AS CHARACTER NO-UNDO. /* Коды параметров строчно */
   DEFINE VARIABLE vMinCommRate  AS CHARACTER NO-UNDO. /* Минимальное значение комиссий */
   DEFINE VARIABLE vSchet        AS INT64   NO-UNDO.
   DEFINE VARIABLE vMinZnach     AS DECIMAL   NO-UNDO. /* ДР МинЗнач */
   DEFINE VARIABLE vDateMon      AS DATE      NO-UNDO. /* Определенная дата месяца(случай КПМ или ЧМ) */
   DEFINE VARIABLE vCodOstpar    AS INT64   NO-UNDO. /* Начальное значение ДР "КодОснДолг" на классе */
   DEFINE VARIABLE vAmtDiff      AS DECIMAL   NO-UNDO. /* Сумма корректировки параметра */
   DEFINE VARIABLE vParamChange  AS INT64   NO-UNDO. /* Параметр на замену */
   DEFINE VARIABLE vPrevResult   AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vGlc          AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE vGl           AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE in_param_str  AS CHARACTER  NO-UNDO. /* список Параметров по договору */
   DEFINE VARIABLE vI            AS INT64      NO-UNDO.    /* счетчик */


   /* Проверка числа входных параметров
   ** Допучтимые значения 2 или 3 */
   IF pn NE 2 AND
      pn NE 3 THEN
      RETURN.

   /* Т.к. не используется функция Pars-ValidParam */
   pn = pn - 1.

   /* Инициализация переменных. */
   ASSIGN
       in_param_str  = IF mvar[pj - pn] EQ "" THEN
                          STRING (result_l[pj - pn])
                       ELSE
                          TRIM(mvar[pj - pn], """'")

       in_dt_pr  = IF mvar[pj - pn + 1] EQ "" THEN
                      STRING (result_l[pj - pn + 1])
                   ELSE
                      TRIM(mvar[pj - pn + 1], """'")
       vRateLog  = pn EQ 2 AND
                   TRIM(mvar[pj - pn + 2], """'") EQ "Да"
   .
   /* Подготовка переменных */
   ASSIGN
       summ  = 0
       vsumm = 0
       in_param_str = TRIM(in_param_str,",")
   .

   IF NUM-ENTRIES(in_dt_pr,":") EQ 2 AND ENTRY(1,in_dt_pr,":") EQ "ЧМ" THEN
      /* Найдем указанную дату текущего месяца */
      vDateMon = DATE(MONTH(in-op-date), MIN(INT64(ENTRY(2,in_dt_pr,":")), DAY(LastMonDate(in-op-date))), YEAR(in-op-date)).
   ELSE IF in_dt_pr EQ "КПМ" THEN
   /* Найдем последнее число предыдущего месяца */
   IF in_dt_pr EQ "КПМ" THEN
         vDateMon = DATE(MONTH(in-op-date), 1, YEAR(in-op-date)) - 1.

   /* Определение правильного применения функции,
   ** формат private-data */
   RUN LOAN_VALID_HANDLE (INPUT-OUTPUT ph).
    vGlc = entry(1,ph:PRIVATE-DATA) NO-ERROR.
    vGl  = entry(2,ph:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(ph)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:

      RETURN.
        END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer loan).

   IF NOT AVAIL loan THEN
      RETURN.
   RUN FindLPResult(loan.contract,
                    loan.cont-code,
                    vName,
                    STRING(wop.op-templ) + CHR(1) + in_param_str + CHR(1) + in_dt_pr + CHR(1) + STRING(vRateLog),
                    OUTPUT vPrevResult).
   IF vPrevResult EQ "" THEN
   DO:

      IF vName = 'ПрмСогл' THEN DO:
         RUN GetMainLnId(RECID(loan),OUTPUT vRec).
         FIND FIRST loan WHERE
              RECID(loan) = vRec NO-LOCK NO-ERROR.
         IF NOT AVAIL loan THEN
            RETURN.
      END.
      IF    (in_dt_pr EQ "КПМ" OR ENTRY(1,in_dt_pr,":") EQ "ЧМ")
        AND loan.since LT vDateMon THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("","","1","Необходимо пересчитать договор " + loan.doc-ref +
                                               " на дату, не ранее " + STRING(vDateMon) + "!").
         RETURN.
      END.
      ELSE
      IF loan.since NE (IF in_dt_pr EQ "ОД" THEN
                          in-op-date
                        ELSE
                          wop.con-date) THEN DO:
          RUN Fill-SysMes IN h_tmess ("","","1","Договор " + loan.doc-ref + " не пересчитан на дату " +
                                                IF in_dt_pr EQ "ОД" THEN
                                                   STRING(in-op-date, "99/99/9999")
                                                ELSE
                                                   STRING(wop.con-date, "99/99/9999") + "!").
          RETURN.
      END.

      RUN colparam.p (OUTPUT vParamlrate,
                      OUTPUT vParammint).
      RUN ColMinImport (loan.contract,
                        loan.cont-code,
                        loan.currency,
                        loan.since,
                        vParamlrate,
                        vParammint,
                        OUTPUT vAmtId,
                        OUTPUT vAmtIdStr,
                        OUTPUT vMinCommRate).

      DO vI = 1 TO NUM-ENTRIES(in_param_str) :  /* цикл по списку параметров */
        in_param = INT64(ENTRY(vI,in_param_str)).
        /* Получение значения параметра */
        RUN STNDRT_PARAM IN h_Loan (
            loan.contract,    /* Назначение договора */
            loan.cont-code,   /* Номер договора */
            in_param,         /* Код параметра  */
            IF in_dt_pr EQ "КПМ" OR ENTRY(1,in_dt_pr,":") EQ "ЧМ" THEN vDateMon     /* Значение параметра на дату состояния договора */
                                ELSE loan.since,    /* Или если передан КПМ (или ЧМ), то на последнее (или указанное) число месяца */
            OUTPUT summ,      /* Значение параметра без loan.interest[i] */
            OUTPUT vDbOpDec,  /* Е дб операций (не используется) */
            OUTPUT vCrOpDec). /* Е кр операций (не используется) */
        /* Если есть признак "учитывать текущие проценты по параметрам" */
        IF vRateLog THEN DO:
            /* Для параметров 81,82,96, запрашиваем остатки по параметрам 11,12,13 */
          IF CAN-DO("81,82,96", STRING(in_param)) THEN
            ASSIGN
                vParamChange = IF in_param EQ 81 THEN 11 ELSE (IF in_param = 82 THEN 12 ELSE 13)
                summ = summ + LoadPar(vParamChange, loan.contract + ',' + loan.cont-code)
            .
            /* Для остальных */
          ELSE
          DO:
                /* В начальном значении реквизита "КодОснДолг" хранится позиция для смещения.
                ** В основном случае = 0, для АИЖК = 5000, и т.п. */
            vCodOstpar = GetParCode(loan.class-code, "КодОснДолг").
            RUN inter_current (BUFFER loan,
                                (in_param - vCodOstPar),
                                OUTPUT vAmtDiff).
            summ = summ + vAmtDiff.
          END.
        END.

        ASSIGN
          vSchet    = LOOKUP(STRING(in_param),vAmtId)
          vMinZnach = IF vSchet NE 0 THEN DEC(ENTRY(vSchet,vMinCommRate)) ELSE 0
        .
        IF  vSchet NE 0
          AND summ GT 0
          AND summ LT vMinZnach THEN
              summ = vMinZnach.

        vsumm = vsumm + summ.

      END.
      /* Обработка записи. */
      ASSIGN
          result_l[pj - pn] = vsumm
          mvar[pj - pn]     = STRING(result_l[pj - pn])
          is-ok             = TRUE
      .
      RUN SaveLPResult (loan.contract,
                        loan.cont-code,
                        vName,
                        STRING(wop.op-templ) + CHR(1) + in_param_str + CHR(1) + in_dt_pr + CHR(1) + STRING(vRateLog),
                        vsumm).
   END.
   ELSE
      ASSIGN
         result_l[pj - pn] = DEC(vPrevResult)
         mvar[pj - pn]     = STRING(result_l[pj - pn])
         is-ok             = TRUE
      .
END PROCEDURE.


/*
    * Что делает: Возвращает валюту договора.
    * Синтаксис : ВалДог
    * Автор     : Om 25.01.2001
    * Пример    : ВалДог
*/
PROCEDURE ВалДог:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE ph       AS handle  NO-UNDO.
    DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
    DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

    IF NOT Pars-ValidParam(0) THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output ph).

    IF valid-handle (ph) THEN
    RUN RE_B_LOAN IN h_Loan (entry(1, ph:private-data),
                             entry(2, ph:private-data),
                             buffer loan).
    ELSE DO:
      ASSIGN
         vGlc = Get_Loan_contr()
         vGl  = Get_Loan()
      NO-ERROR.

      FIND FIRST loan WHERE loan.contract  EQ vGlc
                        AND loan.cont-code EQ vGl NO-LOCK NO-ERROR.

    END.
    IF NOT AVAIL loan THEN RETURN.

    /* Обработка записи. */
    ASSIGN
        result_l[pj - pn] = IF loan.currency EQ ""
                                THEN INT64 (vNatCurrChar)
                                ELSE INT64 (loan.currency)
        mvar    [pj - pn] = loan.currency
        is-ok             = TRUE
   .

END PROCEDURE.

/*
    * Что делает: Возвращает тип клиента по договора.
    * Синтаксис : ТипКлДог
    * Автор     : ches 09.11.2010
    * Пример    : ТипКлДог
*/
PROCEDURE ТипКлДог:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE h_templ  AS handle  NO-UNDO.
    DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
    DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

    IF NOT Pars-ValidParam(0) THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).
    vGlc = entry(1,h_templ:PRIVATE-DATA) NO-ERROR.
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
          RUN Pars-SetResult ( 0 ).
          is-ok = TRUE.
          RETURN.
        END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer loan).
    IF NOT AVAIL loan
    THEN DO:
        RUN Pars-SetResult ( 0 ).
        is-ok = TRUE.
        RETURN.
    END.


    FIND FIRST loan WHERE loan.contract  EQ vGlc
                      AND loan.cont-code EQ vGl
                      NO-LOCK NO-ERROR.

    IF NOT AVAIL loan THEN RETURN.

     RUN Pars-SetCHARResult ( loan.cust-cat ) .
     is-ok             = TRUE .

END PROCEDURE.


/*
    * Что делает: Соединяет строки.
    * Синтаксис : ConCat(<Строка1>,<Строка2>[,<Строка3>][,<Строка4>... <СтрокаN>])
                  N = 25 (максимальное кол-во строк 25).
    * Автор     : Om 06/03/2001
    * Пример    : ConCat("20202",Вал(1),"0").
*/
PROCEDURE ConCat:

    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE vStackCountInt AS INT64  NO-UNDO. /* Счетчик входных значений */
    DEFINE VARIABLE vResult AS CHARACTER  NO-UNDO.

    IF pn lt 2 or
       pn gt 25
        THEN RETURN.

    pn = pn - 1.

    vResult = Pars-Getstring( 0 ).

    do vStackCountInt = 1 to pn:

        vResult = vResult + Pars-Getstring( vStackCountInt ).

    END.

    /* Обработка записи. */
    RUN Pars-SetCHARResult ( vResult ).

    is-ok = TRUE.

END PROCEDURE.

/*
    * Что делает: Возвращает значение из таблицы sysconf.
    * Синтаксис : СисПарам (<код параметра> [,<значение по-умолчанию>])
    * Автор     : Om 06/03/2001
    * Пример    : СисПарам ("Имя")
    *             СисПарам ("Фамилия", "Иванов")
*/
PROCEDURE СисПарам:

   DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEF VAR vPrmCnt   AS INT64 NO-UNDO.
   DEF VAR vPrmName  AS CHAR  NO-UNDO.

   vPrmCnt = pn.

   IF NOT (Pars-ValidParam(1) OR Pars-ValidParam(2)) THEN
      RETURN.
   ASSIGN
      vPrmName       =  IF mvar[pj - pn] EQ ""
                           THEN STRING (result_l[pj - pn])
                           ELSE TRIM   (    mvar[pj - pn], """'")
      mvar [pj - pn] = '"' + GetSysConf ( vPrmName) + '"'
   .
   IF mvar [pj - pn] = ? THEN
   DO:
      IF vPrmCnt LT 2 THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("", "", "0",
            "Не могу получить значение системного параметра " + QUOTER (vPrmName) + "."
         ).
         RETURN.
      END.
      ELSE
         mvar [pj - pn] = mvar [pj - pn + 1].
   END.

   ASSIGN
       result_l[pj - pn] = DECIMAL (TRIM (mvar[pj - pn], """'" ))
   NO-ERROR.

   IF ERROR-STATUS:ERROR THEN
      result_l[pj - pn] = 0.

   is-ok = TRUE.

END PROCEDURE.

/*
**      Что делает: Возвращает кол-во исходных документов в группе для OP_FLT.P
**      Синтаксис : КолДокГр ()
**      Автор     : Om 17/04/2001
**      Пример    : КолДокГр ()
*/
PROCEDURE КолДокГр.

    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    IF NOT Pars-ValidParam(0)
        THEN RETURN.

    RUN Pars-SetCHARResult ( bncr ).

    is-ok = TRUE.

END PROCEDURE.

/*
**      Что делает: Расчет суммы непогашенных процентов на счете требований.
**      Синтаксис : ПроцСчТреб()
**      Автор     : Om 20/04/2001
**      Пример    : ПроцСчТреб()
*/
PROCEDURE ПроцСчТреб:

    define output param is-ok AS logical NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE vLoanHandle AS handle  NO-UNDO. /* Указатель на параметры договора */
    DEFINE VARIABLE vRequirDec  AS decimal NO-UNDO. /* Остаток на счете требований по оплате %% */
    DEFINE VARIABLE vParamDec   AS decimal NO-UNDO. /* Значение параметра */
    DEFINE VARIABLE vParamDbDec AS decimal NO-UNDO. /* Дебетовые обороты */
    DEFINE VARIABLE vParamCrDec AS decimal NO-UNDO. /* Кредитовые обороты */
    DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
    DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

    define buffer bLoan     for loan.
    define buffer bTerm-obl for term-obl.

    IF NOT pars-validparam(0)
    THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output vLoanHandle).
    vGlc = entry(1,vLoanHandle:PRIVATE-DATA) NO-ERROR.
    vGl  = entry(2,vLoanHandle:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(vLoanHandle)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:

          RETURN.
        END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer bLoan).

    /* Договор не найден */
    IF NOT AVAIL bLoan
    THEN RETURN.

    /* Далее будут осуществляться "тихие выходы" */
    ASSIGN
        is-ok = true
        result_l[pj - pn] = 0
        mvar [pj - pn]    = string (result_l[pj - pn])
    .

    /* Поиск планового платежа ранее даты текущего ОД */
    run RE_TERM_OBL IN h_Loan (bLoan.contract,
                               bLoan.cont-code,
                               1, /* Код 1 соответствует плановым платежам */
                               in-op-date,
                               buffer bTerm-obl).

    /* Не было плановых требований на оплату процентов */
    IF NOT AVAIL bTerm-obl
    THEN RETURN.

    /* Рассчитываем остаток по счету "КредТ" - требования по оплате %% */
    /* Расчет 33 параметра */
    run PARAM_33 IN h_Loan (bLoan.contract,
                            bLoan.cont-code,
                            33,
                            ?,    /* Отражает состояние параметра на дату пересчета */
                            output vRequirDec,
                            output vParamDbDec,
                            output vParamCrDec).

    /* Расчет 34 параметра */
    run PARAM_34 IN h_Loan (bLoan.contract,
                            bLoan.cont-code,
                            34,
                            ?,    /* Отражает состояние параметра на дату пересчета */
                            output vParamDec,
                            output vParamDbDec,
                            output vParamCrDec).

    vRequirDec = vRequirDec + vParamDec.

    IF bTerm-obl.end-date NE in-op-date
    THEN DO:
        /* Необходимо вычесть 65 операцию за период на
        ** счет "требований по оплате процентов" */
        for each loan-int where
            loan-int.contract  EQ bLoan.contract and
            loan-int.cont-code EQ bLoan.cont-code and
            loan-int.mdate     gt bTerm-obl.end-date and
            loan-int.mdate     le in-op-date and
            loan-int.id-d      EQ 33 and
            loan-int.id-k      EQ 32
        no-lock:

            vRequirDec = vRequirDec - loan-int.amt-rub.

        END.
    END.

    /* Остаток по счету (параметру и есть требуемая сумма),
    ** в случае bTerm-obl.end-date EQ in-op-date */
    ASSIGN
        result_l[pj - pn] = vRequirDec
        mvar [pj - pn]    = string (result_l[pj - pn])
    .

END PROCEDURE.

/*
**      Что делает: Производит сравнение плановой даты документа с плановой
**                  датой оплаты процентов.
**      Синтаксис : ПланДатаПр ()
**      Автор     : Om 23/04/2001
**      Пример    : ПланДатаПр ()
*/

PROCEDURE ПланДатаПр:
   define output param is-ok AS logical NO-UNDO. /* успешно ли выполнена ? */
   run private_ПланДата in this-procedure (1, output is-ok).
end procedure.

procedure ПланДатаОД:
   define output param is-ok AS logical NO-UNDO. /* успешно ли выполнена ? */
   run private_ПланДата in this-procedure (3, output is-ok).
end procedure.


PROCEDURE private_ПланДата private :
   define input parameter iIdnt like term-obl.idnt NO-UNDO.
   define output param is-ok AS logical NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vLoanHandle AS handle NO-UNDO. /* Указатель на идентификатор договора */

   define variable vParamCount AS INT64 NO-UNDO.
   define variable vUseDelay AS logical initial no NO-UNDO.
   define variable vContract AS CHAR NO-UNDO.
   define variable vCont-code AS CHAR NO-UNDO.

   define variable vReturn AS INT64 initial 0 NO-UNDO.

   vParamCount = pn.
   IF NOT (Pars-ValidParam(0) OR Pars-ValidParam(1)) THEN
      RETURN.

   /* Определение правильного применения функции,
   ** формат private-data */
   run LOAN_VALID_HANDLE (input-output vLoanHandle).
   IF NOT VALID-HANDLE (vLoanHandle)
   THEN RETURN.

   assign
      vUseDelay = vParamCount EQ 1 and can-do("да,yes,true",Pars-GetString(0))
      vContract = entry(1,vLoanHandle:private-data)
      vCont-code = entry(2,vLoanHandle:private-data)
      vReturn = 0
   .

   IF vParamCount EQ 1 and Pars-GetString(0) EQ "Пробег" THEN
      run _Пробег in h_pint (vContract,
                                 vCont-code,
                                 wop.con-date,
                                 iIdnt, /*-> term-obl.idnt*/
                                 output vReturn).
   ELSE
      run _ПланДата in h_pint (vContract,
                                 vCont-code,
                                 wop.con-date,
                                 vUseDelay,
                                 iIdnt, /*-> term-obl.idnt*/
                                 output vReturn).


   ASSIGN
     result_l[pj - pn] = vReturn
     mvar [pj - pn]    = string (result_l[pj - pn])
   .

   is-ok = true.
END PROCEDURE.


/*
  Что делает: Количество месяцев в периоде
  Синтаксис : КолМес(дата начала периода (строка dd/mm/yy) [, дата окончания периода (строка dd/mm/yy) ] )
              в случае использования функции с одним параметром в расчет берется дата опердня
      Пример: КолМес (GetDetails("begin-date"),GetDetails("end-date")).
      Пример: КолМес (GetDetails("begin-date")).
*/

PROCEDURE КолМес:
    DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO.
    /* --- */
    IF NOT (Pars-ValidParam(1) OR Pars-ValidParam(2)) THEN RETURN.

    DEFINE VARIABLE vFirstDate AS DATE       NO-UNDO.
    DEFINE VARIABLE vLastDate  AS DATE       NO-UNDO.
    DEFINE VARIABLE vResult    AS INT64    NO-UNDO.
    ASSIGN
        vFirstDate = DATE ( Pars-GetString ( 0 ) )
        vLastDate  = IF pn EQ 0 THEN in-op-date ELSE DATE ( Pars-GetString ( 1 ) )
        .

    vResult = (YEAR  (vLastDate) - YEAR  (vFirstDate)) * 12 + MONTH (vLastDate) - MONTH (vFirstDate) + 1.

    RUN Pars-SetResult ( vResult ).
    is-ok = TRUE.
END PROCEDURE.

/*
** Что делает: Процедура запрашивает ввод суммы операции в транзакциях изъятия / довнесения во вклад
**
** Синтаксис : СуммаИзДов(<Текст подсказки>, <начальное значение ответа>).
**
** Пример    :  СуммаИзДов("довненсения",0) 
*/

PROCEDURE СуммаИзДов:

   DEFINE OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE inc-mess  AS CHAR   NO-UNDO.
   DEFINE VARIABLE inc-init  AS DEC    NO-UNDO.

   IF NOT (Pars-ValidParam(2)) THEN RETURN.
   
   ASSIGN
      inc-mess  = Pars-GetString (0) + ":"
      inc-init  = Pars-GetDec (1)

   .

   FORM
      inc-mess 
         VIEW-AS TEXT SIZE 20 BY 1 
         FORMAT "x(20)"
      inc-init
         VIEW-AS FILL-IN SIZE 30 BY 1 AT ROW 1 COL 18
         FORMAT "->>>>,>>>,>>>,>>9.99"
         HELP ""
       
   WITH FRAME fQstn CENTERED ROW 10 OVERLAY NO-LABELS 1 COL
   COLOR MESSAGES TITLE "ВВЕДИТЕ ДАННЫЕ".

   IF LASTKEY NE 10 AND LASTKEY NE 13 THEN RETURN.

   B_INPUT:
   DO WITH FRAME fQstn
   ON ERROR    UNDO B_INPUT, LEAVE B_INPUT
   ON ENDKEY   UNDO B_INPUT, LEAVE B_INPUT:
      PAUSE 0.
      DISPLAY  inc-init inc-mess WITH FRAME fQstn.
      UPDATE inc-init.
      RUN Pars-SetResult(inc-init).
   END.

   HIDE FRAME fQstn NO-PAUSE.

   is-ok = TRUE.

END PROCEDURE.

/*
** Что делает: Процедура запрашивает ввод строки с экрана, и передает строку в парсер внимание!
**
** Синтаксис : Вопрос(<Текст подсказки>, <начальное значение ответа>[,<"окно">]).
**
**             При указании двух аргументов, запрос строки происходит внизу экрана (область STATUS).
**             Максимально значение 40 символов.
**
**             Если указать третий аргумент "Окно", то запрос информации происходит в отдельном окне.
**             При этом максимальное значение ограничено 250 символами.
**
** Пример    : Вопрос ("Че те нада", "100000000000000000000000000000") - задать вопрос
**                  с текстом "Че те нада" и предустановленным ответом "100000000000000000000000000000"
**             Вопрос (?,?)    - получить ответ на предыдущий заданный вопрос без выдачи нового вопроса
**
**             Вопрос ("Введите назначение платежа", "Оплата по договру №.", "Окно").
**             Выводит окно с заголовком "[ ВВЕДИТЕ НАЗНАЧЕНИЕ ПЛАТЕЖА ]", 
**             с предустановленноым значением "Оплата по договру №.".
*/

PROCEDURE Вопрос:
   DEFINE OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE inc-mess  AS CHAR    NO-UNDO.
   DEFINE VARIABLE inc-hiden AS CHAR    NO-UNDO. /* потом перделать и расширить.... может фреймик наколбасить */
   DEFINE VARIABLE inc-init  AS CHAR    NO-UNDO.
   DEFINE VARIABLE inc-type  AS CHAR    NO-UNDO.
   
   IF NOT (    Pars-ValidParam (2)
            OR Pars-ValidParam (3)) THEN RETURN.
   ASSIGN
      inc-mess  = Pars-GetString (0)
      inc-init  = Pars-GetString (1)
      inc-type  = Pars-GetString (2)
   .
                        /* Если текст вопроса указан, задаем вопрос */
   IF LENGTH (inc-mess) GT 0 THEN 
   CASE inc-type:
      WHEN "Окно" THEN
      DO:
         FORM
            inc-init
               VIEW-AS EDITOR SIZE 60 BY 5
               FORMAT "x(250)"
               HELP ""
         WITH FRAME fQstn CENTERED ROW 10 OVERLAY SIDE-LABELS 1 COL NO-LABEL
         COLOR MESSAGES TITLE "".

         B_INPUT:
         DO WITH FRAME fQstn
         ON ERROR    UNDO B_INPUT, LEAVE B_INPUT
         ON ENDKEY   UNDO B_INPUT, LEAVE B_INPUT:
            ASSIGN
               vKeepAnswer       = ""
               FRAME fQstn:TITLE = "[ " + CAPS (inc-mess) + " ]"
            .
            UPDATE inc-init.
            vKeepAnswer = inc-init.
            RUN Pars-SetCHARResult (inc-init).
         END.
         HIDE FRAME fQstn NO-PAUSE.
      END.
      OTHERWISE
      DO:         
         vKeepAnswer = "".
         MESSAGE inc-mess + ": "  UPDATE inc-init FORMAT "x(40)".
         RUN Pars-SetCHARResult (inc-init).
         vKeepAnswer = inc-init.
      END.
   END CASE.
                        /* Если вместо текста вопроса передано неопределенное
                        ** значение - Вопрос(?,?) - то используем ответ на
                        ** предыдущий заданный пользователю вопрос */
   ELSE
      RUN Pars-SetCHARResult (vKeepAnswer).
   is-ok = TRUE.
END PROCEDURE.

/*
   Vlad:
   ДР("имя_файла", "идентификатор", кодДР, "Значение_КОТОРОЕ ПРОВЕРИТЬ")
   "Значение_КОТОРОЕ ПРОВЕРИТЬ" если указано "" то возвращается
   значение из допрека, иначе
   проверяется  Значение_КОТОРОЕ ПРОВЕРИТЬ = реальное значение из допреквизита
     1 если совпадает,
     0 если нет.
     0 = если др не найден ваще.
*/
PROCEDURE ДР.
    define output param is-ok AS logical NO-UNDO. /* успешно ли выполнена ? */
    IF NOT pars-validparam(4) THEN RETURN.
    is-ok = false.
    DEFINE VARIABLE inc_file   AS CHAR NO-UNDO. /* файл */
    DEFINE VARIABLE inc_surr   AS CHAR NO-UNDO. /* идентификатор экземпляра*/
    DEFINE VARIABLE inc_code   AS CHAR NO-UNDO. /* код др */
    DEFINE VARIABLE inc_value  AS CHAR NO-UNDO. /* значение которое предполагается, если оно есть (т.е. 4 параметр не "" ) функция возвращает 1/0 (Yes/No) */
    DEFINE VARIABLE get_value  AS CHAR NO-UNDO.

    Assign
        inc_file  = Pars-GetString (0)
        inc_surr  = Pars-GetString (1)
        inc_code  = Pars-GetString (2)
        inc_value = Pars-GetString (3)
    .
    IF inc_file EQ "acct" THEN DO: /* если ищем реквизит по счету то */
        IF NUM-ENTRIES(inc_surr) < 2 THEN DO: /* если суррогат задан не полностью то формируем правильный суррогат счета */
            {find-act.i
               &acct = inc_surr
               &fila = "/**/"
            }
            IF AMBIG acct THEN DO: /* нашли больше одного счета попадающего под условие */
                MESSAGE "Функция ДР: Найдено несколько счетов с указанным номером счета. Функция так работать не может!"
                    VIEW-AS ALERT-BOX ERROR BUTTONS OK.
                RETURN. /* ошибка */
            END.
            ELSE IF AVAIL acct THEN DO: /* если счет найден то формируем правильный суррогат */
                inc_surr = acct.acct + "," + acct.currency.
            END.
            ELSE . /* иначе просто ничего не делаем */
        END.
        ELSE IF ENTRY(2,inc_surr) EQ "810" THEN inc_surr = ENTRY(1,inc_surr) + ",".
    END.

    get_value = GetXattrValueEx(inc_file,inc_surr,inc_code,"").

    IF inc_value = "" then
        RUN Pars-SetCHARResult (get_value).
    else
        RUN Pars-SetResult (IF inc_value = get_value OR (inc_value = "#ПУСТО#" AND NOT {assigned get_value})  THEN 1 ELSE 0).
   is-ok = TRUE.
END PROCEDURE.

&ENDIF

&IF  DEFINED(NEW_PARSER) = 0 OR
    (DEFINED(NEW_PARSER) > 0 AND DEFINED(PLOAN_LIB) > 0) &THEN
/*-----------------*/
/* Начисление процентов на внебалансе(просроченном) by Sanders (скопировано с НачПрВ)*/
PROCEDURE НачПрВнеб:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
  DEFINE VARIABLE h_templ AS handle NO-UNDO.
  DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
  DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

  IF NOT Pars-ValidParam(1) THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).
    vGlc = Pars-GetString(0).
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:

        END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer loan).

  result_l[pj - pn] = 0. /* Обнуление суммы */

/* остаток по параметру 48 */
    find last loan-var of loan where
              loan-var.amt-id EQ 48
          AND loan-var.since  le wop.con-date
    no-lock NO-ERROR.
    IF AVAIL loan-var then
        result_l[pj - pn] = result_l[pj - pn] + loan-var.balance.

    /* "+" операции начисления "-" операции списания */
    for each loan-int of loan where
             loan-int.mdate   EQ wop.con-date
        AND (loan-int.id-d    EQ 48 or
             loan-int.id-k    EQ 48)
    no-lock:
        IF loan-int.id-d EQ 48 then
            result_l[pj - pn] = result_l[pj - pn] + loan-int.amt-rub.
        ELSE IF loan-int.id-k EQ 48 then
            result_l[pj - pn] = result_l[pj - pn] - loan-int.amt-rub.
    END.

  mvar[pj - pn]     = "".
  is-ok = TRUE.
END PROCEDURE.
&ENDIF

&IF  DEFINED(NEW_PARSER) = 0 &THEN
/*
Что делает: Возвращает сумму начисленных процентов за период
            Эта функция используется при выполнении транзакции на основе процедуры
            all_flt.p. Позволяет во время выполнения транзакции проводить формирование
            документов и печать ведомоcти начисленных процентов
Синтаксис : НачислКредДеп(Кредит)
Автор     : Nata (перенес в основную версию Sanders)
*/
PROCEDURE НачислКредДеп:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

  DEFINE VARIABLE nach-summ like op-entry.amt-rub no-undo .
  DEFINE VARIABLE mint      AS INT64 extent 12 initial [4,8,9,11,12,14,15,17,18,20,81,82] NO-UNDO.
  DEFINE VARIABLE ext       AS CHAR   NO-UNDO.
  DEFINE VARIABLE h_templ   AS handle NO-UNDO.
  DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
  DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.


  IF NOT Pars-ValidParam(1) THEN RETURN.

    /* Определение правильного применения функции,
    ** формат private-data */
    run LOAN_VALID_HANDLE (input-output h_templ).

    vGlc = Pars-GetString(0).
    vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(h_templ)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
          result_l[pj - pn] = 0.
          is-ok = TRUE.
    RETURN.
  END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                            buffer loan).


  ext = FGetSettingEx ("НачШтр", ?, "", No).

/* Обнуление суммы проводки */
  result_l[pj - pn] = 0.
   run "nach(l.p"(loan.contract,loan.cont-code,ext,output nach-summ)  .
   assign
     result_l[pj - pn] = nach-summ
     is-ok = yes
     .
end procedure .

/*
Что делает: Возвращает 1, если Клиент является нерезидентом юридически
(то есть код страны - не rus) и у него не стоит допреквизит, что он - налоговый резидент,
в противном случае возвращается 0.
Синтаксис : КлиентНалРез(dps), КлиентНалРез(Кредит), КлиентНалРез(Депоз).
Автор     : Gorm
*/
PROCEDURE КлиентНалРез:
    DEFINE OUTPUT PARAM oIsOk AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE vHTempl   AS HANDLE NO-UNDO. /* Указатель на параметры договора */
    DEFINE VARIABLE vContract AS CHAR   NO-UNDO. /* назначение договора */
    DEFINE VARIABLE vTemplCh  AS CHAR   NO-UNDO. /* Указатель на параметры договора */

    IF NOT Pars-ValidParam(1) THEN RETURN.

    vContract = Pars-GetString (0).

    /*Для вкладов*/
    IF vContract = "dps" THEN DO:

      RUN DPS_VALID_HANDLE (INPUT-OUTPUT vHTempl).

       /*Номер вклада не определен*/
       IF  NOT VALID-HANDLE(vHTempl)
       THEN DO:
           RUN Pars-SetResult ( 0 ).
           oIsOk = TRUE.
           RETURN.
       END.

       vTemplCh = ENTRY(1,SUBSTRING(vHTempl:private-data,6)).

    END.

    /* Для кредитов и депозитов */
    ELSE IF vContract = "Кредит"
       OR vContract ="Депоз"
    THEN DO:

       RUN LOAN_VALID_HANDLE (INPUT-OUTPUT vHTempl).

        /* Номер договора не определен */
        IF NOT VALID-HANDLE(vHTempl) THEN DO :
           RUN Pars-SetResult ( 0 ).
           oIsOk = TRUE.
           RETURN.
        END.

        vTemplCh = ENTRY(2,SUBSTRING(vHTempl:private-data,2)).

    END.
    ELSE DO:  /*Неверное назначение договора*/
       RUN Pars-SetResult ( 0 ).
       oIsOk = TRUE.
       RETURN.
    END.

    /* Поиск договора */
    RUN RE_B_LOAN IN h_Loan (Pars-GetString(0),
                             vTemplCh,
                             BUFFER loan).

    /*Номер договора не определен*/
    IF NOT AVAIL loan THEN DO:
       RUN Pars-SetResult ( 0 ).
       oIsOk = TRUE.
       RETURN.
    END.

    /*Клиент должен быть частным лицом*/
    IF loan.cust-cat <> "Ч" THEN DO:
       RUN Pars-SetResult ( 0 ).
       oIsOk = TRUE.
       RETURN.
    END.

    FIND person WHERE
        person.person-id EQ loan.cust-id
    NO-LOCK NO-ERROR.

    /*Проводка по договору несуществующего клиента*/
    IF NOT AVAIL person THEN DO:
       RUN Pars-SetResult ( 0 ).
       oIsOk = TRUE.
       RETURN.
    END.

    RUN Pars-SetResult (IF person.country-id <> 'RUS'
                           AND GetXAttrValue("person",
                                             STRING(loan.cust-id),
                                             "НалРез") <> "Да"
                          THEN 1 ELSE 0 ).

    oIsOk = TRUE.

END PROCEDURE.

/*
**    Что делает: Возвращает дату.
**    Синтаксис : ДатаДок ( Тип_даты [ ,номер шаблона [ ,формат вывода ] ] )
**                Тип_даты:
**                П: contract-date: Плановая дата проведения операции
**                Д: doc-date:      Дата выписки расчетно-денежного документа
**                С: due-date:      Дата (срок) платежа
**                В: ins-date:      Дата приема документа от клиента
**                О: op-date:       Дата документа
**                К: op-value-date: Дата валютирования
**
**    Возможна передача номера скрытой проводки в качестве 2-го параметра.
**
**    даты определяются в следующем порядке:
**       из фрейма (сначала в полях документа, затем - у проводки),
**       из временной таблицы (wop),
**       из документа (op).
*/
PROCEDURE ДатаДок:

   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /*успешно ли выполнена?*/

   DEFINE VARIABLE vCode    AS CHARACTER NO-UNDO.

   IF NOT (   pn EQ 1
           OR pn EQ 2
           OR pn EQ 3) THEN
      RETURN.
   vCode = Pars-GetString ( 1 ).

   RUN DateDoc (vCode, rid, output is-ok).

   RETURN.

END PROCEDURE.

/*    Что делает: Возвращает значение идентификатора банка по документу.
**    Синтаксис : ИдентБанка (<код идентификатора банка>,
**                            <роль банка в документе>,
**                            <Признак>)
**
**       <код идентификатора банка>
**             код идентификатора банка, значение которого необходимо узнать,
**       <роль банка в документе>
**             Роль банка, допустимы значения указаны в классификаторе
**             "op-bank" - "Роли банков в документах",
**       <Признак>
**             "Г"       - возвращает идентификаторы головного филиала по роли,
**             ""        - номер банка (филиала) по роли.
*/
PROCEDURE ИдентБанка:

   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена?*/

   DEFINE VARIABLE vBankId  AS CHAR  NO-UNDO. /* Код идентификатора банка. */
   DEFINE VARIABLE vBankRol AS CHAR  NO-UNDO. /* Роль банка. */
   DEFINE VARIABLE vHeadSet AS LOG   NO-UNDO. /* Признак (брать значениея с филиала или
                                      ** головы). */
   DEFINE VARIABLE vBankInt AS INT64   NO-UNDO. /* Внутренний идентификатор банка. */

   DEF BUFFER op         FOR op. /* Локализация буфера. */
   DEF BUFFER op-bank    FOR op-bank.    /* Локализация буфера. */
   DEF BUFFER banks-code FOR banks-code. /* Локализация буфера. */
   DEF BUFFER bBanksCode FOR banks-code. /* Локализация буфера. */
   DEF BUFFER RegBnkCode FOR banks-code. /* Регистрационный номер банка. */

   /* Разбор входных параметров. */
   IF NOT (    pn GE 0
           AND pn LE 3)
      THEN RETURN.

   ASSIGN
      pn       =  pn - 1 /* Затычка для parssen. */
      vBankId  =  IF pn GE 0
                     THEN Pars-GetString (0)
                     ELSE "REGN"
      vBankRol =  IF pn GE 1
                     THEN Pars-GetString (1)
                     ELSE ""
      vHeadSet =  Pars-GetString (2) EQ "Г"
   .

   FOR FIRST xwop WHERE
      xwop.op-templ EQ 501
   NO-LOCK,
   FIRST op WHERE
      op.op EQ xwop.op * (-1)
   NO-LOCK,
   FIRST op-bank OF op WHERE
      op-bank.op-bank-type EQ vBankRol
   NO-LOCK,
   FIRST banks-code OF op-bank
   NO-LOCK:

      /* Определение идентификатора банка (головы или филиала),
      ** для поиска значения идентификатора. */
      IF vHeadSet
      THEN FOR FIRST bBanksCode WHERE
               bBanksCode.bank-id         EQ banks-code.bank-id
         AND   bBanksCode.bank-code-type  EQ "REGN"
      NO-LOCK,
      FIRST RegBnkCode WHERE
               RegBnkCode.bank-code      EQ ENTRY (1, bBanksCode.bank-code, "/")
         AND   RegBnkCode.bank-code-type EQ "REGN"
      NO-LOCK:

           vBankInt = RegBnkCode.bank-id.

      END.
      ELSE vBankInt = banks-code.bank-id.

      /* Поиск требуемого значения идентификатора,
      ** на необходимом банке (филиале или голове). */
      FOR FIRST bBanksCode WHERE
               bBanksCode.bank-id         EQ vBankInt
         AND   bBanksCode.bank-code-type  EQ vBankId
      NO-LOCK:
         RUN Pars-SetCHARResult (bBanksCode.bank-code).
      END.
   END.

   is-ok = TRUE.
   RETURN.
END PROCEDURE.

/*
  Что делает: Возвращает остаток на картотеке.
  Если окончательное списание с картотеки, то 0,
              иначе > 0
  Синтаксис : ЧастСпис ()
  Автор     :
*/

PROCEDURE ЧастСпис:
   DEFINE OUTPUT PARAMETER oIs-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vResult AS DECIMAL NO-UNDO.

   DEFINE BUFFER b-op        FOR op.
   DEFINE BUFFER b-opo       FOR op.
   DEFINE BUFFER b-op-entry  FOR op-entry.
   DEFINE BUFFER b-op-entry2 FOR op-entry.
   DEFINE BUFFER wop         FOR wop.
   DEFINE BUFFER op          FOR op.
   DEFINE BUFFER op-entry    FOR op-entry.

   FIND FIRST wop WHERE wop.op-templ = 501 NO-LOCK NO-ERROR.

   IF AVAILABLE wop THEN
   DO:
      FIND FIRST op WHERE RECID(op) = wop.op-recid NO-LOCK NO-ERROR.

      IF AVAILABLE op THEN
      DO:
         FIND FIRST b-opo WHERE b-opo.op-tran  = op.op-tran
                            AND b-opo.acct-cat = "o"
            NO-LOCK NO-ERROR.

         IF AVAILABLE b-opo THEN
         DO:
            FIND FIRST op-entry OF b-opo NO-LOCK NO-ERROR.

            IF AVAILABLE op-entry THEN
            DO:
               FIND FIRST kau WHERE kau.kau-id BEGINS "Карт-ка"
                                AND kau.kau = op-entry.kau-cr
                  NO-LOCK NO-ERROR.

               IF AVAILABLE kau THEN
               DO:
                  FIND FIRST b-op WHERE b-op.op = INT64(ENTRY(1, op-entry.kau-cr))
                     NO-LOCK NO-ERROR.

                  IF AVAILABLE b-op THEN
                  DO:
                     FIND FIRST b-op-entry OF b-op NO-LOCK NO-ERROR.

                     IF AVAILABLE b-op-entry THEN
                     DO:
                        FOR EACH b-op-entry2 WHERE b-op-entry2.acct-cr   =  b-op-entry.acct-db
                                               AND b-op-entry2.op-date   >= b-op-entry.op-date
                                               AND b-op-entry2.op-date   <= op-entry.op-date
                                               AND b-op-entry2.op-status >= gop-status
                                               AND b-op-entry2.kau-cr    =  b-op-entry.kau-db
                                               AND b-op-entry2.currency  =  ""
                                               AND b-op-entry2.op        <= b-opo.op
                           NO-LOCK:

                           ACCUMULATE b-op-entry2.amt-rub (TOTAL).
                        END.
                        vResult = b-op-entry.amt-rub - ACCUM TOTAL b-op-entry2.amt-rub.
                     END.
                  END.
               END.
            END.
         END.
      END.
   END.

   RUN Pars-SetResult (vResult).
/* --- */
   oIs-ok = TRUE.
END PROCEDURE.

/*
**    Что делает: Возвращает 1, если первое движение равное опердню по счету
**                было в текущем месяце, иначе - 0.
**    Синтаксис : ПерДвижВТекМес ( Счет, [Вал, [Статус]] )
*/
PROCEDURE ПерДвижВТекМес:
   DEFINE OUTPUT PARAM oIs-Ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vAcc        AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vCur        AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vStatus     AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vResult     AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vMonBegDate AS DATE       NO-UNDO.
   DEFINE VARIABLE vOpDate     AS DATE       NO-UNDO.

   oIs-Ok = FALSE.
   IF NOT (Pars-ValidParam(1) OR Pars-ValidParam(2) OR Pars-ValidParam(3)) THEN
      RETURN.
   ASSIGN vAcc    = Pars-GetString(0)
          vCur    = IF pn = 0 THEN /* валюта счета не задана */
                       ""
                    ELSE
                       Pars-GetStringFormatted(1 , "999")
          vCur    = IF vCur EQ vNatCurrChar THEN "" ELSE vCur
          vStatus = IF pn = 1 THEN /* статус документа не задан */
                       gOp-Status
                    ELSE
                       Pars-GetString(2)
          vResult = "0".

   FIND acct WHERE acct.currency EQ vCur
               AND acct.acct     EQ vAcc
   NO-LOCK NO-ERROR.

   IF NOT AVAILABLE acct THEN
      RETURN.

   vMonBegDate = DATE(MONTH(in-op-date), 1, YEAR(in-op-date)).
   FIND FIRST op-entry
        WHERE op-entry.acct-db   EQ vAcc
          AND op-entry.op-date   GE vMonBegDate
          AND op-entry.op-date   LE in-op-date
          AND op-entry.op-status GE vStatus
          AND op-entry.currency  BEGINS vCur
   NO-LOCK NO-ERROR.

   vOpDate = IF AVAIL op-entry THEN op-entry.op-date ELSE ?.

   FIND FIRST op-entry
        WHERE op-entry.acct-cr   EQ vAcc
          AND op-entry.op-date   GE vMonBegDate
          AND op-entry.op-date   LE in-op-date
          AND op-entry.op-status GE vStatus
          AND op-entry.currency  BEGINS vCur
   NO-LOCK NO-ERROR.

   ASSIGN
      vOpDate = op-entry.op-date WHEN AVAIL op-entry /* найдена только по кредиту */
                                  AND vOpDate EQ ?
      vOpDate = MIN(op-entry.op-date, vOpdate) WHEN AVAIL op-entry /* Дб и Кт */
                                  AND vOpDate NE ?
   .

   IF vOpDate EQ in-op-date THEN
      vResult = "1".

   RUN Pars-SetCharResult(vResult).
   oIs-Ok = TRUE.

   RETURN.
END PROCEDURE.

/*
  Что делает: Оборот по счету в рублях
  Синтаксис : ОборотР (Номер_Счета, Д_или_К ) первые два параметра обязательны.
                       Номер_Счета - основной счет по которому выч. оборот.
                       Д_или_К     - тип оборота = Д - по Дебету, К - по Кредиту
                       необязательные параметры:
                       Дн          - дата начала    интервала
                       Дк          - дата окончания интервала, если не указаны
                                     то берется текущий операционный день.
                       Валюта      - валюта базового счета
                       Статус      - статус документа,
                                     если не указан то обрабатываются документы
                                     со статусом выше "крыж"
                       МаскаКорСчета - маска корреспондирующего счета,
                                       в формате CAN-DO
                       МАСКА ПОЛЬЗОВАТЕЛЕЙ - список пользователей, вводивших документы, 
                                     которые будут участвовать в расчете оборота,
                                       в формате CAN-DO

*/
PROCEDURE ОборотР:
   DEFINE OUTPUT PARAM opIsOk AS LOGICAL NO-UNDO.

   DEFINE VARIABLE vStrPar   AS CHAR    NO-UNDO.
   DEFINE VARIABLE vpRetSumm AS DECIMAL NO-UNDO.

   RUN PutParStr(OUTPUT opIsOk, OUTPUT vStrPar).

   IF opIsOk THEN
      RUN VALUE("oborot.p") ("Р",
                             vStrPar,
                             in-op-date,
                             OUTPUT opIsOk,
                             OUTPUT vpRetSumm).
   IF opIsOk THEN
      RUN Pars-SetResult(vpRetSumm).

END PROCEDURE.
/*
  Что делает: Готовит строку параметров для "oborot.p".
*/
PROCEDURE PutParStr:
   DEFINE OUTPUT PARAM opIsOk  AS LOGICAL   NO-UNDO.
   DEFINE OUTPUT PARAM oStrPar AS CHARACTER NO-UNDO.

   opIsOk = FALSE.
   IF NOT (    Pars-ValidParam(2)
            OR Pars-ValidParam(3)
            OR Pars-ValidParam(4)
            OR Pars-ValidParam(5)
            OR Pars-ValidParam(6)
            OR Pars-ValidParam(7)
            OR PARS-ValidParam(8)
            ) THEN
      RETURN.

   oStrPar = Pars-GetString(0) + "," +
             Pars-GetString(1).
   IF pn > 1 THEN oStrPar = oStrPar + "," + Pars-GetString(2).
   IF pn > 2 THEN oStrPar = oStrPar + "," + Pars-GetString(3).
   IF pn > 3 THEN oStrPar = oStrPar + "," + Pars-GetString(4).
   IF pn > 4 THEN oStrPar = oStrPar + "," + Pars-GetString(5).
   IF pn > 5 THEN oStrPar = oStrPar + "," + Pars-GetString(6).
   IF pn > 6 THEN oStrPar = oStrPar + "," + REPLACE(Pars-GetString(7), ",", ";").
   opIsOk = TRUE.

END PROCEDURE.

/*
  Что делает: Оборот по счету в валюте
  Синтаксис : ОборотВ (Номер_Счета, Д_или_К ) первые два параметра обязательны.
                       Номер_Счета - основной счет по которому выч. оборот.
                       Д_или_К     - тип оборота = Д - по Дебету, К - по Кредиту
                       необязательные параметры:
                       Дн          - дата начала    интервала
                       Дк          - дата окончания интервала, если не указаны
                                     то берется текущий операционный день.
                       Валюта      - валюта базового счета
                       Статус      - статус документа,
                                     если не указан то обрабатываются документы
                                     со статусом выше "крыж"
                       МаскаКорСчета - маска корреспондирующего счета,
                                       в формате CAN-DO
                       МАСКА ПОЛЬЗОВАТЕЛЕЙ - список пользователей, вводивших документы, 
                                     которые будут участвовать в расчете оборота,
                                       в формате CAN-DO

*/
PROCEDURE ОборотВ:
   DEFINE OUTPUT PARAM opIsOk AS LOGICAL NO-UNDO.

   DEFINE VARIABLE vStrPar   AS CHAR    NO-UNDO.
   DEFINE VARIABLE vpRetSumm AS DECIMAL NO-UNDO.

   RUN PutParStr(OUTPUT opIsOk, OUTPUT vStrPar).

   IF opIsOk THEN
      RUN VALUE("oborot.p") ("В",
                             vStrPar,
                             in-op-date,
                             OUTPUT opIsOk,
                             OUTPUT vpRetSumm).
   IF opIsOk THEN
      RUN Pars-SetResult(vpRetSumm).

END PROCEDURE.

/* перенесено из спецверсии Русюга */
/*
  Что делает: Вычисление комиссии (берет валюту и счет как строку а не число) - специально для ПТБ
  Синтаксис : Ком2(Сумма, Код_комиссии, Счет, Валюта[, Подразделение])
*/

PROCEDURE Ком2:
  DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

  IF NOT (Pars-ValidParam(4) OR
          Pars-ValidParam(5)) THEN RETURN.

  DEFINE VARIABLE l-summ AS dec  NO-UNDO.
  DEFINE VARIABLE l-code AS CHAR NO-UNDO.
  DEFINE VARIABLE l-acct AS CHAR NO-UNDO.
  DEFINE VARIABLE l-cur  AS CHAR NO-UNDO.
  DEFINE VARIABLE l-branch AS CHAR NO-UNDO.
  
  assign
    l-summ = result_l[pj - pn]
    l-code = TRIM(mvar[pj - pn + 1], """")
    l-acct = IF mvar[pj - pn + 2] EQ "" THEN STRING(result_l[pj - pn + 2]) ELSE trim(mvar[pj - pn + 2], """")
    l-cur  = IF mvar[pj - pn + 3]     EQ "" THEN STRING(result_l[pj - pn + 3])     ELSE trim(mvar[pj - pn + 3],     """")
    l-cur  = IF l-cur = vNatCurrChar THEN "" ELSE l-cur
    l-branch = (IF pn GE 4
                   THEN Pars-GetString(4)
                   ELSE "")
   .

  FIND FIRST commission WHERE commission.commission = l-code NO-LOCK NO-ERROR.
  FIND LAST comm-rate WHERE comm-rate.commi = commi.commi AND

                            comm-rate.filial-id = shfilial AND
                            (IF l-branch EQ "" THEN
                            comm-rate.branch-id EQ "" ELSE
                     CAN-DO(comm-rate.branch-id,l-branch)) AND
                            comm-rate.acct = l-acct AND
                            comm-rate.currency = l-cur AND
                            comm-rate.min-value <= l-summ AND
                            comm-rate.since <= in-op-date NO-LOCK NO-ERROR.
  IF NOT AVAIL comm-rate THEN
    FIND LAST comm-rate WHERE comm-rate.commi = commi.commi AND
                              (IF l-branch EQ "" THEN
                              comm-rate.branch-id EQ "" ELSE
                        CAN-DO(comm-rate.branch-id,l-branch)) AND
                              comm-rate.acct = "0" AND
                              comm-rate.currency = l-cur AND
                              comm-rate.min-value <= l-summ AND
                              comm-rate.since <= in-op-date NO-LOCK NO-ERROR.
  IF AVAIL comm-rate then
     RUN Pars-SetResult(IF comm-rate.rate-fixed THEN comm-rate.rate-comm ELSE (comm-rate.rate-comm / 100) * l-summ).
  ELSE
     RUN Pars-SetResult(0).
  /* --- */
  is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Оборот по роли-счета
  Синтаксис : ОборотКАУ (роль-счета,
                         тип оборота[,дата1][,дата2][,валюта][,статус][,маска корреспондирующего счета],
                         [код операции],
                         [код субаналитического учета])
                         роль-счета   - роль-счета, по которому вычисляется оборот
                         тип оборота  - Д или К - оборот по дебету или кредиту .
                                        Если не указан ╞ берется разность оборотов .
                         дата1        - начало интервала (по умолчанию опердень)
                         дата2        - конец интервала (по умолчанию опердень)
                         валюта       - валюта базового счета (не указана - берется из счета)
                         статус       - статус рассматриваемых документов (не указано
                                        берутся документы со статусом выше глобального)
                         маска        - маска корреспондирующего счета (не указана - по всем
                                        счетам), в формате CAN-DO
                         код операции ╞ маска кодов операций, учитываемых в вычислениях
                         код субаналитического учета ╞ маска кода субаналитического учета.

*/

PROCEDURE ОборотКАУ:
   DEFINE OUTPUT PARAM opIsOk   AS LOGICAL    NO-UNDO.

   DEFINE VARIABLE vRetSumm     AS DECIMAL    NO-UNDO.
   DEFINE VARIABLE vRetSummD    AS DECIMAL    NO-UNDO.
   DEFINE VARIABLE vRetSummC    AS DECIMAL    NO-UNDO.
   DEFINE VARIABLE vDbCr        AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vSince       AS DATE       NO-UNDO.
   DEFINE VARIABLE vUntil       AS DATE       NO-UNDO.
   DEFINE VARIABLE vCurrency    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vStatus      AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vCorAcctMask AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vCodOp       AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vCodKau      AS CHARACTER  NO-UNDO.

   DEFINE VARIABLE vHTempl      AS HANDLE    NO-UNDO. /* Указатель на параметры договора */

   IF NOT Pars-ValidParam(9) THEN RETURN.

   /*---------------------параметр 2 = оборот по дебету/кредиту---------------*/
   vDbCr = Pars-GetString(1).
   IF  vDbCr EQ "" OR vDbCr EQ ? THEN vDbCr = "*".

   /*---------------------параметр 3 = дата начала периода--------------------*/
   IF Pars-GetString(2) EQ "" THEN vSince = in-op-date.
   ELSE
   DO: /* или НЕ пустой */
     vSince = DATE(Pars-GetString(2)) NO-ERROR.
     IF ERROR-STATUS:ERROR THEN /* если кривой */
     DO:
        MESSAGE "Дата начала периода в функции. Оборот не приводится к типу дата!"
        VIEW-AS ALERT-BOX ERROR.
        RUN Pars-SetResult ( 0 ).
        opIsOk = TRUE.
        RETURN.
     END.
     IF vSince EQ ? THEN vSince = in-op-date.
   END.

   /* ---------------------параметр 4 = дата окончания периода----------------*/
   IF Pars-GetString(3) EQ "" THEN vUntil = in-op-date.
   ELSE
   DO: /* или НЕ пустой */
     vUntil = DATE(Pars-GetString(3)) NO-ERROR.
     IF ERROR-STATUS:ERROR THEN /* если кривой */
     DO:
        MESSAGE "Дата окончания периода в функции. Оборот не приводится к типу дата!"
        VIEW-AS ALERT-BOX ERROR.
        RUN Pars-SetResult ( 0 ).
        opIsOk = TRUE.
        RETURN.
     END.
     IF vUntil EQ ? THEN vSince = in-op-date.
   END.

   IF vSince > vUntil THEN
   DO:
     MESSAGE "Внимание: начальная дата больше конечной в процедуре Оборот!"
     VIEW-AS ALERT-BOX ERROR.
     RUN Pars-SetResult ( 0 ).
     opIsOk = TRUE.
     RETURN.
   END.

   /*----------------------параметр 5 = валюта базового счета ----------------*/
   vCurrency = Pars-GetString(4).
   IF vCurrency EQ FGetSetting("КодНацВал","","") THEN vCurrency = "".

   /*----------------------параметр 6 = статус--------------------------------*/
   vStatus = Pars-GetString(5).
   IF vStatus EQ ? OR vStatus EQ "" THEN vStatus = gop-status.

   /*----------------------параметр 7 = маска счета корреспондента------------*/
   vCorAcctMask = Pars-GetString(6).
   IF vCorAcctMask EQ "" OR vCorAcctMask EQ ? THEN vCorAcctMask = "*".

   /*----------------------параметр 8 = маска кода операции------------*/
   vCodOp = Pars-GetString(7).
   IF vCodOp EQ ? OR vCodOp EQ "" THEN vCodOp = "*".

   /*----------------------параметр 9 = маска кода операции------------*/
   vCodKau = Pars-GetString(8).
   IF vCodKau EQ ? OR vCodKau EQ "" THEN vCodKau = "*".

   /*Для вкладов*/
   RUN DPS_VALID_HANDLE (INPUT-OUTPUT vHTempl).

   /*Номер вклада не определен*/
   IF NOT VALID-HANDLE(vHTempl) THEN
   DO:
     RUN Pars-SetResult ( 0 ).
     opIsOk = TRUE.
     RETURN.
   END.

   /* Поиск договора */
   RUN RE_B_LOAN  IN h_Loan  ('dps',
                   ENTRY(1,SUBSTRING(vHTempl:PRIVATE-DATA,6)),
                   BUFFER loan).

   /*Номер договора не определен*/
   IF NOT AVAIL loan THEN DO:
       RUN Pars-SetResult ( 0 ).
       opIsOk = TRUE.
       RETURN.
    END.

   ASSIGN
       vRetSummD = 0
       vRetSummC = 0
   .

  IF vDbCr EQ "Д" OR vDbCr EQ "*" THEN /*для дебита*/
    /*По роли находим счета договора*/
    FOR EACH  loan-acct OF loan WHERE loan-acct.acct-type EQ Pars-GetString(0) /*роль-счета*/
                                NO-LOCK:
      /*Находим суб проводки для данного договора, т.к. на одном счете может быть
        несколько договоров*/
      FOR EACH kau-entry  WHERE kau-entry.acct        EQ loan-acct.acct
                            AND kau-entry.currency    EQ loan-acct.currency
                            AND kau-entry.kau     BEGINS (loan-acct.contract + "," + loan-acct.cont-code + ",")
                            /*маска кода субаналитического учета*/
                            AND CAN-DO(vCodKau, ENTRY(NUM-ENTRIES(kau-entry.kau), kau-entry.kau))
                            AND kau-entry.debit       EQ YES
                            AND kau-entry.op-date     GE vSince
                            AND kau-entry.op-date     LE vUntil
                            AND CAN-DO(vCodOp, kau-entry.op-code)  /*маска кода операций*/
                            AND kau-entry.op-status   GE vStatus
                            NO-LOCK:

        IF vDbCr EQ "*" THEN
          FIND FIRST op-entry OF kau-entry WHERE CAN-DO(vCorAcctMask,op-entry.acct-cr)   /*для проводок*/
                                              OR op-entry.acct-cr EQ ?                   /*для полупроводок*/
                                           NO-LOCK NO-ERROR.
        ELSE
          FIND FIRST op-entry OF kau-entry WHERE
                 (IF vDbCr EQ "Д" THEN (op-entry.acct-db EQ loan-acct.acct     AND
                                        (CAN-DO(vCorAcctMask,op-entry.acct-cr) OR  /*для проводок*/
                                         op-entry.acct-cr EQ ?))                   /*для полупроводок*/
                                  ELSE (op-entry.acct-cr EQ loan-acct.acct     AND
                                        (CAN-DO(vCorAcctMask,op-entry.acct-db) OR  /*для проводок*/
                                         op-entry.acct-db EQ ?)))                  /*для полупроводок*/
                                           NO-LOCK NO-ERROR.
        IF AVAIL op-entry THEN
        DO:
          IF vCurrency EQ "" THEN vRetSummD = vRetSummD + kau-entry.amt-rub.
                             ELSE vRetSummD = vRetSummD + kau-entry.amt-cur.
        END.
      END.
    END.
  IF vDbCr EQ "К" OR vDbCr EQ "*" THEN /*для кредита*/
    /*По роли находим счета договора*/
    FOR EACH  loan-acct OF loan WHERE loan-acct.acct-type EQ Pars-GetString(0) /*роль-счета*/
                                NO-LOCK:
      /*Находим суб проводки для данного договора, т.к. на одном счете может быть
        несколько договоров*/
      FOR EACH kau-entry  WHERE kau-entry.acct        EQ loan-acct.acct
                            AND kau-entry.currency    EQ loan-acct.currency
                            AND kau-entry.kau     BEGINS (loan-acct.contract + "," + loan-acct.cont-code + ",")
                            /*маска кода субаналитического учета*/
                            AND CAN-DO(vCodKau, ENTRY(NUM-ENTRIES(kau-entry.kau), kau-entry.kau))
                            AND kau-entry.debit       EQ NO
                            AND kau-entry.op-date     GE vSince
                            AND kau-entry.op-date     LE vUntil
                            AND CAN-DO(vCodOp, kau-entry.op-code)  /*маска кода операций*/
                            AND kau-entry.op-status   GE vStatus
                            NO-LOCK:

        IF vDbCr EQ "*" THEN
          FIND FIRST op-entry OF kau-entry WHERE CAN-DO(vCorAcctMask,op-entry.acct-cr)   /*для проводок*/
                                              OR op-entry.acct-cr EQ ?                   /*для полупроводок*/
                                           NO-LOCK NO-ERROR.
        ELSE
          FIND FIRST op-entry OF kau-entry WHERE
                 (IF vDbCr EQ "Д" THEN (op-entry.acct-db EQ loan-acct.acct     AND
                                        (CAN-DO(vCorAcctMask,op-entry.acct-cr) OR  /*для проводок*/
                                         op-entry.acct-cr EQ ?))                   /*для полупроводок*/
                                  ELSE (op-entry.acct-cr EQ loan-acct.acct     AND
                                        (CAN-DO(vCorAcctMask,op-entry.acct-db) OR  /*для проводок*/
                                         op-entry.acct-db EQ ?)))                  /*для полупроводок*/
                                           NO-LOCK NO-ERROR.
        IF AVAIL op-entry THEN
        DO:
          IF vCurrency EQ "" THEN vRetSummC = vRetSummC + kau-entry.amt-rub.
                             ELSE vRetSummC = vRetSummC + kau-entry.amt-cur.
        END.
      END.
    END.

   IF vRetSummD GT 0 THEN vRetSumm = vRetSummD - vRetSummC.
                     ELSE vRetSumm = vRetSummC.

   RUN Pars-SetResult(vRetSumm).
   opIsOk = YES.

END PROCEDURE.

/*
    * Что делает: Возвращает номер группы риска, вычисленный на основании
                  коэффициента риска, действующего по договору по состоянию
                  на текущий операционный день
    * Синтаксис : ГрРиска
    * Автор     : amam  14/07/04
    * Пример    : ГрРиска
*/
PROCEDURE ГрРиска:

    DEF OUTPUT PARAM is-ok AS LOG INIT FALSE NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE ph         AS HANDLE     NO-UNDO.
    DEFINE VARIABLE mrate_risk AS DEC        NO-UNDO. /* коэффициент риска */
    DEFINE VARIABLE mgr_risk   AS INT64 INIT 0 NO-UNDO. /* группа риска */
    DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
    DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

    mb:
    DO ON ERROR UNDO, LEAVE:

       IF NOT Pars-ValidParam(0) THEN LEAVE.

       /* Определение правильного применения функции,
       ** формат private-data */
       RUN LOAN_VALID_HANDLE(INPUT-OUTPUT ph).
    vGlc = entry(1,ph:PRIVATE-DATA) NO-ERROR.
    vGl  = entry(2,ph:PRIVATE-DATA) NO-ERROR.

    IF NOT VALID-HANDLE(ph)
    THEN DO:
        IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:
          LEAVE.
        END.
    END.

    RUN RE_B_LOAN IN h_Loan (vGlc,
                             vGl ,
                             buffer loan).
       IF NOT AVAIL loan THEN LEAVE.

       /* группа риска */
       mgr_risk = Re_History_Risk (loan.Contract,
                                   loan.Cont-Code,
                                   in-op-date,
                                   ?).

       ASSIGN
          mvar[pj - pn]     = STRING(mgr_risk)
          result_l[pj - pn] = mgr_risk
          is-ok             = TRUE
       .
    END. /* mb */

    RETURN.
END PROCEDURE.
/*
   Что делает: возвращает остаток на счете 2-го порядка с номером
   BalAcctNumber (целое) на 1 января текущего года
   Синтаксис: BalNU(BalAcctNumber)
*/
PROCEDURE BalNU:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
   DEFINE VARIABLE vBalance AS DECIMAL NO-UNDO.

   IF NOT Pars-ValidParam(1) THEN
      RETURN.
   RUN getbalrm.p (Pars-GetInt(0), /* Номер счета второго порядка */
                   dept.branch,              /* Код подразделения */
                   DATE(1, 1, YEAR(in-op-date)),  /* Дата остатка */
            OUTPUT vBalance).
   RUN Pars-SetResult(vBalance).
   is-ok = TRUE.
END PROCEDURE.



/*
  Что делает: Остаток в рублях
  Синтаксис : ОбКорР(Код валюты, Маска счета по дебету, Маска счета по кредиту, [Дата1], [Дата2], [статус])
              - Код валюты - код валюты.
              - Маска счета по дебету  - маска счета по дебету.
              - Маска счета по кредиту -  маска счета по кредиту.
              - Дата 1 - Дата начала расчета оборотов. Если параметр не указывается, то берется дата опердня
              - Дата 2 - Дата конца расчета оборотов. Если параметр не указывается, то берется дата опердня
              - Статус - Cтатус, начиная с которого документы учитываются при расчете оборотов. Если параметр не указан, то используется глобальный статус.
*/

PROCEDURE ОбКорР:
   DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vCurrency AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vDbMask   AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vCrMask   AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vSince    AS DATE       NO-UNDO.
   DEFINE VARIABLE vUntil    AS DATE       NO-UNDO.
   DEFINE VARIABLE vStatus   AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vRubSumm  AS DECIMAL    NO-UNDO.
   DEFINE VARIABLE vValSumm  AS DECIMAL    NO-UNDO.


   IF  NOT (   Pars-ValidParam(3)
            OR Pars-ValidParam(4)
            OR Pars-ValidParam(5)
            OR Pars-ValidParam(6)
           ) THEN
      RETURN.

   ASSIGN
      vCurrency = Pars-GetStringFormatted(0,"999")
      vDbMask   = Pars-GetString(1)
      vCrMask   = Pars-GetString(2)
      vSince    = (IF pn > 2 THEN DATE(mvar[pj - pn + 3]) ELSE in-op-date)
      vUntil    = (IF pn > 3 THEN DATE(mvar[pj - pn + 4]) ELSE in-op-date)
      vStatus   = (IF pn > 4 THEN Pars-GetString (5) ELSE gop-status)
   .

   RUN ОбКор (       vCurrency,
                     vDbMask,
                     vCrMask,
                     vSince,
                     vUntil,
                     vStatus,
              OUTPUT vValSumm,
              OUTPUT vRubSumm).

   IF RETURN-VALUE NE "" /* Om 22.12.00 */
      THEN RETURN.

   RUN Pars-SetResult(vRubSumm).

   is-ok = TRUE.
END PROCEDURE.

/*
  Что делает: Остаток в валюте
  Синтаксис : ОбКорВ(Код валюты, Маска счета по дебету, Маска счета по кредиту, [Дата1], [Дата2], [статус])
              - Код валюты - код валюты.
              - Маска счета по дебету  - маска счета по дебету.
              - Маска счета по кредиту -  маска счета по кредиту.
              - Дата 1 - Дата начала расчета оборотов. Если параметр не указывается, то берется дата опердня
              - Дата 2 - Дата конца расчета оборотов. Если параметр не указывается, то берется дата опердня
              - Статус - Cтатус, начиная с которого документы учитываются при расчете оборотов. Если параметр не указан, то используется глобальный статус.
*/

PROCEDURE ОбКорВ:

   DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vCurrency AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vDbMask   AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vCrMask   AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vSince    AS DATE       NO-UNDO.
   DEFINE VARIABLE vUntil    AS DATE       NO-UNDO.
   DEFINE VARIABLE vStatus   AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vRubSumm  AS DECIMAL    NO-UNDO.
   DEFINE VARIABLE vValSumm  AS DECIMAL    NO-UNDO.


   IF  NOT (   Pars-ValidParam(3)
            OR Pars-ValidParam(4)
            OR Pars-ValidParam(5)
            OR Pars-ValidParam(6)
           ) THEN
      RETURN.

   ASSIGN
      vCurrency = Pars-GetStringFormatted(0,"999")
      vDbMask   = Pars-GetString(1)
      vCrMask   = Pars-GetString(2)
      vSince    = (IF pn > 2 THEN DATE(mvar[pj - pn + 3]) ELSE in-op-date)
      vUntil    = (IF pn > 3 THEN DATE(mvar[pj - pn + 4]) ELSE in-op-date)
      vStatus   = (IF pn > 4 THEN Pars-GetString (5) ELSE gop-status)
   .

   RUN ОбКор (       vCurrency,
                     vDbMask,
                     vCrMask,
                     vSince,
                     vUntil,
                     vStatus,
              OUTPUT vValSumm,
              OUTPUT vRubSumm).

   IF RETURN-VALUE NE "" /* Om 22.12.00 */
      THEN RETURN.

   RUN Pars-SetResult(vValSumm).

   is-ok = TRUE.
END PROCEDURE.

PROCEDURE ОбКор.
   DEFINE INPUT  PARAMETER ipCurrency AS CHARACTER  NO-UNDO.
   DEFINE INPUT  PARAMETER ipDbMask   AS CHARACTER  NO-UNDO.
   DEFINE INPUT  PARAMETER ipCrMask   AS CHARACTER  NO-UNDO.
   DEFINE INPUT  PARAMETER ipSince    AS DATE       NO-UNDO.
   DEFINE INPUT  PARAMETER ipUntil    AS DATE       NO-UNDO.
   DEFINE INPUT  PARAMETER ipStatus   AS CHARACTER  NO-UNDO.
   DEFINE OUTPUT PARAMETER opSummVal  AS DECIMAL    NO-UNDO.
   DEFINE OUTPUT PARAMETER opSummRub  AS DECIMAL    NO-UNDO.

   IF ipSince EQ ? THEN ipSince = 01/01/1900.
   IF ipSince > ipUntil THEN DO:
      MESSAGE "Внимание: начальная дата больше конечной переданы в процедуру" ENTRY(1, PROGRAM-NAME(1), " ") "!"
         VIEW-AS ALERT-BOX ERROR.
      RETURN "Ошибка".
   END.

   IF ipStatus = ?   THEN ipStatus = gop-status.
   ELSE IF ipStatus = "1" THEN ipStatus = "П".
   ELSE IF ipStatus = "0" THEN ipStatus = "√".

   IF ipCurrency EQ "810" THEN ipCurrency = "".

   ASSIGN
      opSummVal = 0
      opSummRub = 0
   .

   FOR EACH op-date WHERE
            op-date.op-date >= ipSince
        AND op-date.op-date <= ipUntil NO-LOCK,
      EACH op-entry WHERE
           op-entry.op-date  EQ op-date.op-date
       AND op-entry.currency EQ ipCurrency
       AND CAN-DO(ipDbMask, op-entry.acct-db)
       AND CAN-DO(ipCrMask, op-entry.acct-cr)
       AND op-entry.op-status GE ipStatus NO-LOCK:

      ASSIGN
         opSummVal = opSummVal + op-entry.amt-cur
         opSummRub = opSummRub + op-entry.amt-rub
      .
   END.
END PROCEDURE.

{pp-uni.var &FILE_sword_p=YES}
{pp-uni.prg}

/*
  Что делает: Расчитывает сумму бесплатного расхода по кассе
  Синтаксис : СуммаБесплРасх (Номер_Счета[, ...]) первый параметр обязателен.
                       Номер_Счета - основной счет по которому выч. оборот.
                       необязательные параметры:
                       Дата1     - дата начала срока
                       Дата2     - дата окончания срока

*/
PROCEDURE СуммаБесплРасх:
   DEFINE OUTPUT PARAMETER opIsOk AS LOGICAL NO-UNDO.

   DEFINE VARIABLE vDate1       AS DATE      NO-UNDO.
   DEFINE VARIABLE vDate2       AS DATE      NO-UNDO.
   DEFINE VARIABLE vPeriod      AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vPer         AS INT64   NO-UNDO.
   DEFINE VARIABLE vAcct        AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vInSaldo     AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE vOuSaldo     AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE vNaznSch     AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vObKrKas     AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE vObDbKas     AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE vObKrFil     AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE vRegNomFVTB  AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vMFO         AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vRet         AS DECIMAL   NO-UNDO.

   DEFINE VARIABLE vStrTMP1     AS CHARACTER EXTENT 4 NO-UNDO.
   DEFINE VARIABLE vStrTMP2     AS CHARACTER          NO-UNDO.
   DEFINE VARIABLE vStrTMP3     AS CHARACTER EXTENT 4 NO-UNDO.
   DEFINE VARIABLE vStrTMP4     AS CHARACTER          NO-UNDO.

   DEFINE BUFFER op-entry   FOR op-entry.
   DEFINE BUFFER op         FOR op.
   DEFINE BUFFER Info-Store FOR Info-Store.
   DEFINE BUFFER acct       FOR acct.

   IF    Pars-ValidParam(1)
      OR Pars-ValidParam(2)
      OR Pars-ValidParam(3) THEN
   DO:

      IF TRIM(mvar[pj - pn + 1]) NE "" THEN
         vDate1 = DATE(mvar[pj - pn + 1]) NO-ERROR.
      ELSE
      DO:
         vPeriod = FGetSetting("КомисВТБ", "СрокБНП", "1М").

         vPer = INDEX(vPeriod,"М").

         IF vPer GT 0 THEN
         DO:
            vper = INT64(SUBSTRING(vPeriod,1,vPer - 1)).
            vDate1 = in-op-date - (30 * vPer).
         END.
         ELSE
         DO:
            vPer = INDEX(vPeriod,"Д").

            IF vPer GT 0 THEN
            DO:
               vPer = INT64(SUBSTRING(vPeriod,1,vPer - 1)).
               vDate1 = in-op-date - vPer.
            END.
            ELSE
               vDate1 = in-op-date - 30.
         END.
      END.

      IF TRIM(mvar[pj - pn + 2]) NE "" THEN
         vDate2 = DATE(mvar[pj - pn + 2]) NO-ERROR.
      ELSE
         vDate2 = in-op-date.

      vAcct = Pars-GetString(0). /* 1 */

      RUN acct-pos IN h_base ( vAcct,
                               "",
                               vDate1,
                               vDate1,
                               CHR(251) ).

      vInSaldo = -1 * sh-bal. /* 2 */

      vNaznSch = fGetSetting("НазнСчКас", "", "").
      vObKrKas = 0.

      FOR EACH op-entry WHERE op-entry.op-date GE vDate1
                          AND op-entry.op-date LE vDate2
                          AND op-entry.acct-cr EQ vAcct
         NO-LOCK,
         EACH op OF op-entry WHERE op.op-status GE CHR(251) NO-LOCK,
         EACH acct WHERE acct.acct     EQ op-entry.acct-db
                     AND acct.currency EQ op-entry.currency
                     AND CAN-DO(vNaznSch, acct.contract)
         NO-LOCK:
         vObKrKas = vObKrKas + op-entry.amt-rub.
      END. /* 3 */

      vNaznSch = fGetSetting("НазнСчМБР", "", "").
      vRegNomFVTB = fGetSetting("РегНомФВТБ", "", "").
      vObKrFil = 0.

      FOR EACH op-entry WHERE op-entry.op-date GE vDate1
                          AND op-entry.op-date LE vDate2
                          AND op-entry.acct-cr EQ vAcct
         NO-LOCK,
         EACH op OF op-entry WHERE op.op-status GE CHR(251) NO-LOCK,
         EACH acct WHERE acct.acct     EQ op-entry.acct-db
                     AND acct.currency EQ op-entry.currency
                     AND CAN-DO(vNaznSch, acct.contract)
         NO-LOCK:

         IF GetXAttrValueEx("op", STRING(op.op), "ВнешнБП", "Да") EQ "Нет" THEN
            vObKrFil = vObKrFil + op-entry.amt-rub.
         ELSE
         DO:

            {empty Info-Store}
            RUN Collection-Info.

            RUN for-pay("ДЕБЕТ,ПЛАТЕЛЬЩИК,БАНКПЛ,БАНКГО,БАНКФИЛ",
                        "ПП",
                        OUTPUT vStrTMP1[1],
                        OUTPUT vStrTMP2,
                        OUTPUT vStrTMP3[1],
                        OUTPUT vStrTMP4,
                        OUTPUT vMFO).
            IF CAN-DO(vRegNomFVTB, vMFO) THEN
               vObKrFil = vObKrFil + op-entry.amt-rub.
         END.
      END. /* 4 */

      vNaznSch = fGetSetting("НазнСчКас", "", "").
      vObDbKas = 0.

      FOR EACH op-entry WHERE op-entry.op-date GE vDate1
                          AND op-entry.op-date LE vDate2
                          AND op-entry.acct-db EQ vAcct
         NO-LOCK,
         EACH op OF op-entry WHERE op.op-status GE CHR(251) NO-LOCK,
         EACH acct WHERE acct.acct     EQ op-entry.acct-cr
                     AND acct.currency EQ op-entry.currency
                     AND CAN-DO(vNaznSch, acct.contract)
         NO-LOCK:
         vObDbKas = vObDbKas + op-entry.amt-rub.
      END. /* 5 */


      RUN acct-pos IN h_base ( vAcct,
                               "",
                               vDate2,
                               vDate2,
                               CHR(251) ).

      vOuSaldo = -1 * sh-bal. /* 6 */

      vRet = MIN(vInSaldo + vObKrKas + vObKrFil - vObDbKas, vOuSaldo).
      RUN Pars-SetResult(vRet).

      opIsOk = YES.
   END.

END PROCEDURE.

/*
  Что делает: Определяет сумму процентов по векселю, которые следует начислить на дату расчета
  Синтаксис : ВЕКСПРОЦНАЧ()
*/
PROCEDURE ВЕКСПРОЦНАЧ:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL      NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE h_templ       AS HANDLE       NO-UNDO.
   DEFINE VARIABLE oResult       AS DECIMAL      NO-UNDO.
   DEFINE VARIABLE mSignsDate    AS CHARACTER    NO-UNDO.
   DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

   IF    Pars-ValidParam(1)
   THEN DO:
      mSignsDate = Pars-GetString(0).

      RUN LOAN_VALID_HANDLE (INPUT-OUTPUT h_templ).
          vGlc = Pars-GetString(0).
          vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

          IF NOT VALID-HANDLE(h_templ)
          THEN DO:
              IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:

         RETURN.
              END.
          END.
      RUN veknproc.p (vGlc,vGl, IF mSignsDate EQ "OД" THEN in-op-date ELSE wop.con-date, OUTPUT oResult) NO-ERROR.
      IF ERROR-STATUS:ERROR THEN
         RETURN.

      RUN Pars-SetResult(oResult).

      is-ok = TRUE.
   END.
END PROCEDURE.

/*
  Что делает: Определяет сумму дисконта по векселю, которую следует начислить на дату расчета
  Синтаксис : ВЕКСДИСКНАЧ()
*/
PROCEDURE ВЕКСДИСКНАЧ:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL      NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE h_templ       AS HANDLE       NO-UNDO.
   DEFINE VARIABLE oResult       AS DECIMAL      NO-UNDO.
   DEFINE VARIABLE mSignsDate    AS CHARACTER    NO-UNDO.
   DEFINE VARIABLE iPar          AS LOGICAL      NO-UNDO.
   DEFINE VARIABLE vGlc AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE vGl  AS CHARACTER   NO-UNDO.

   IF    Pars-ValidParam(1)
      OR Pars-ValidParam(2)
   THEN DO:
      mSignsDate = Pars-GetString(0).
      iPar       = LOGICAL(IF Pars-GetString(1) EQ "" THEN "0" ELSE Pars-GetString(1),"1/0").

      RUN LOAN_VALID_HANDLE (INPUT-OUTPUT h_templ).
          vGlc = entry(1,h_templ:PRIVATE-DATA) NO-ERROR.
          vGl  = entry(2,h_templ:PRIVATE-DATA) NO-ERROR.

          IF NOT VALID-HANDLE(h_templ)
          THEN DO:
              IF ReFindLoan (output vGlc , output vGl ) = ? THEN DO:

         RETURN.
              END.
          END.
      RUN vekndisk.p (vGlc,vGl, IF mSignsDate EQ "OД" THEN in-op-date ELSE wop.con-date, iPar, OUTPUT oResult) NO-ERROR.
      IF ERROR-STATUS:ERROR THEN
         RETURN.

      RUN Pars-SetResult(oResult).

      is-ok = TRUE.
   END.
END PROCEDURE.

/*--------------------------------------------------------------------------
    * Что делает: Ищет счет с указанной ролью и балансовым счетом.
    * Синтаксис : РольБал(<роль счета>, <Балансовый счет>, <Признак даты>)
                  <Признак даты>:
                  "ОД" - Дата опердня
                  "ПД" - плановая дата
    * Автор     : jadv 05.12.2007
    * Пример    : РольБал("ДепДиск","52502","ОД")
  --------------------------------------------------------------------------*/
PROCEDURE РольБал.
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL   NO-UNDO.

   DEFINE VARIABLE vH_templ      AS HANDLE    NO-UNDO.
   DEFINE VARIABLE vResult       AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vDate         AS DATE      NO-UNDO.
   vResult   = ?.
   DEFINE BUFFER   loan-acct     FOR loan-acct.

   IF NOT Pars-ValidParam(3) THEN
      is-ok = FALSE.
   ELSE DO:
      /* Определение правильного применения функции, формат private-data */
      RUN LOAN_VALID_HANDLE (INPUT-OUTPUT vH_templ).
      IF VALID-HANDLE(vH_templ) THEN DO:

         vDate = IF Pars-GetString(2) EQ "ОД" THEN in-op-date
                                              ELSE wop.con-date.

         FIND LAST loan-acct WHERE
                loan-acct.contract  EQ ENTRY(1, vH_templ:PRIVATE-DATA)
            AND loan-acct.cont-code EQ ENTRY(2, vH_templ:PRIVATE-DATA)
            AND loan-acct.acct-type EQ Pars-GetString(0)
            AND loan-acct.acct      BEGINS(Pars-GetString(1))
            AND loan-acct.since     LE vDate
            NO-LOCK NO-ERROR.
         IF AVAIL loan-acct THEN
            vResult = loan-acct.acct.
      END.
      is-ok = TRUE.
   END.
   RUN Pars-SetACCTResult(vResult).

END PROCEDURE.

/*--------------------------------------------------------------------------
    * Что делает: Проверку наличия предварительной заявки по счету на дату
    * Синтаксис : ПредКЗ(<счет>[, <датa>])
    * Пример    : ПредКЗ(40702810800024567928)
  --------------------------------------------------------------------------*/

PROCEDURE ПредКЗ.
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   IF NOT (pars-validparam(1) OR pars-validparam(2)) THEN
      RETURN.

   is-ok = YES.
   DEFINE VARIABLE vAcct       AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE vDate       AS DATE        NO-UNDO.
   DEFINE VARIABLE out_Result  AS CHARACTER   NO-UNDO.

   DEFINE VARIABLE vCustCat AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vCustId  AS INT64   NO-UNDO.

   DEFINE BUFFER acct      FOR acct.
   DEFINE BUFFER loan-acct FOR loan-acct.
   DEFINE BUFFER loan      FOR loan.
   DEFINE BUFFER term-obl  FOR term-obl.

   ASSIGN
      vAcct = Pars-GetString(0)
/*      vDate = DATE(Pars-GetString(1))*/
   .

   IF TRIM(mvar[pj - pn + 1]) NE "" THEN
      vDate = DATE(mvar[pj - pn + 1]) NO-ERROR.
   ELSE
      vDate = gend-date.

   out_Result = "0".

   FIND FIRST acct WHERE acct.acct EQ vAcct NO-LOCK NO-ERROR.

   IF NOT AVAILABLE acct THEN
      RETURN.

   IF acct.cust-cat EQ "В" THEN
      RETURN.

   vCustCat = acct.cust-cat.
   vCustId  = acct.cust-id.

   FOR EACH acct WHERE acct.cust-cat EQ vCustCat
                   AND acct.cust-id  EQ vCustId
      NO-LOCK,
      EACH loan-acct OF acct NO-LOCK,
      EACH loan OF loan-acct NO-LOCK,
      EACH term-obl OF loan WHERE term-obl.class-code EQ "predkz"
                              AND term-obl.idnt       EQ 24
                              AND term-obl.end-date   EQ vDate
      NO-LOCK:

         out_Result = "1".
         LEAVE.
   END.
   RUN Pars-SetResult(out_Result).
   RETURN.

END PROCEDURE.

PROCEDURE ИнфоКлиент:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE mAcct     AS CHARACTER NO-UNDO.
   DEFINE VARIABLE mCurr     AS CHARACTER NO-UNDO.
   DEFINE VARIABLE mTypeInfo AS CHARACTER NO-UNDO.
   DEFINE VARIABLE mOp       AS INT64     NO-UNDO.
   DEFINE VARIABLE mBen-acct AS CHARACTER NO-UNDO.
   DEFINE VARIABLE mUIN      AS CHARACTER NO-UNDO.
   DEFINE VARIABLE  mAddr    AS CHARACTER NO-UNDO.
   DEFINE VARIABLE  mINN     AS CHARACTER NO-UNDO.
   DEFINE VARIABLE  mKPP     AS CHARACTER NO-UNDO.
   DEFINE VARIABLE  mType    AS CHARACTER NO-UNDO.
   DEFINE VARIABLE  mCode    AS CHARACTER NO-UNDO.
   DEFINE VARIABLE  mAcctC   AS CHARACTER NO-UNDO.
   DEFINE VARIABLE  mName    AS CHARACTER NO-UNDO.
   DEFINE VARIABLE  mRazdL   AS CHARACTER NO-UNDO.
   DEFINE VARIABLE  mRazdR   AS CHARACTER NO-UNDO.
   DEFINE VARIABLE mStrTMP   AS CHARACTER NO-UNDO.
   DEFINE VARIABLE  mIsPredpr AS LOGICAL  NO-UNDO.
   DEFINE VARIABLE  mTypeITD  AS CHARACTER NO-UNDO.
   DEFINE VARIABLE  mResult  AS CHARACTER NO-UNDO.

   DEFINE BUFFER acct FOR acct.

   FIND FIRST op WHERE RECID(op) EQ wop.op-recid NO-LOCK NO-ERROR.

   IF NOT pars-validparam(3) THEN
      RETURN.

   mAcct     = Pars-GetString(0).
   mCurr     = Pars-GetString(1).
   mTypeInfo = Pars-GetString(2).

   IF mCurr EQ "{&in-NC-Code}" THEN
      mCurr = "".                 

   {find-act.i
      &acct = mAcct
      &curr = mCurr
   }

    IF NOT AVAILABLE acct THEN
       RETURN.

   mName = GetCliName(acct.cust-cat,
                      STRING(acct.cust-id),
                      OUTPUT mAddr,
                      OUTPUT mINN,
                      OUTPUT mKPP,
                      INPUT-OUTPUT mType,
                      OUTPUT mCode,
                      OUTPUT mAcctC).
   IF CAN-DO(FGetSetting("БалСчНаим",?,""),STRING(acct.bal-acct,"99999"))
      AND {assigned acct.details}
   THEN
      mName = acct.details.
   IF NOT {assigned mName} AND acct.cust-cat EQ "В" THEN
   DO:
      mName = FGetSetting("ГНИ", "НаимКО","").

      CASE mName:
         WHEN "Банкс" THEN
            mName = FGetSetting("Банкс", ?, "").
         WHEN "Банк"  OR WHEN "" THEN DO:
            mName = FGetSetting("Банк", ?, "").
            IF NOT {assigned mName} THEN DO:
               mStrTMP = FGetSetting("КодФил", ?, "").
               FIND FIRST branch WHERE branch.branch-id EQ mStrTMP
                  NO-LOCK NO-ERROR.
               mName = IF AVAILABLE branch THEN branch.name
                                           ELSE "".
            END.
         END.
      END CASE.
   END.
   ELSE IF acct.cust-cat = "Ю" AND mTypeInfo = "Наим" AND
           NOT CAN-DO(FGetSetting("БалСчНаим",?,""),STRING(acct.bal-acct,"99999"))
   THEN
      RUN GetCustNameFormatted IN h_cust (acct.cust-cat,
                                          acct.cust-id,
                                          OUTPUT mName).
/*  Для ФИО-222П возвращаем:
    ФИО + Адрес + (если адрес не указан, то Дата рождения + место рождения)

    Если счет внутренний, то вместо ФИО возвращаем настроечный параметр "Банк" */

   IF CAN-DO("ФИО-2281У,Наим,ФИО-107н", mTypeInfo) THEN
      ASSIGN
         mRazdL = "//"
         mRazdR = "//"
      .
   ELSE IF mTypeInfo = "ФИО-222П" THEN
      ASSIGN
         mRazdL = "("
         mRazdR = ")"
      .

   IF (CAN-DO("ФИО-2281У,ФИО-107н,АДРЕС,АДРЕСР", mTypeInfo) 
      AND mAddr = "000000"
      OR  mTypeInfo = "Наим")
      AND acct.cust-cat <> "В"
   THEN DO:
      RUN GetCustAdr IN h_cust (acct.cust-cat,
                                acct.cust-id,
                                gend-date,
                                IF mTypeInfo = "Наим" THEN "АдрЮр" ELSE "*",
                                OUTPUT TABLE ttCustAddress).
      FIND LAST ttCustAddress NO-LOCK NO-ERROR.
      IF AVAILABLE ttCustAddress THEN
         mAddr = ttCustAddress.fAdrStr.
      IF (mTypeInfo EQ "АДРЕСР" OR mtypeInfo EQ "ФИО-107н") AND {assigned ttCustAddress.AdrStr} THEN
         mAddr = FrmtAddrStr(ttCustAddress.AdrStr,"").
   END.
   ELSE IF mTypeInfo EQ "АДРЕСР" THEN DO:
      RUN GetCustInfo2 IN h_cust (4,acct.acct,
                                  acct.currency,OUTPUT maddr).
      mAddr = fGetStrAdr(mAddr).
   END.

   IF mTypeInfo = "Наим" THEN DO:
      ASSIGN
         mResult = mName
         mStrTmp = FGetSetting("И113", "Сумма1626", "")
      .
      IF mStrTmp <> ""                  AND
         wop.amt-rub > DECIMAL(mStrTmp) AND
         {assigned mAddr}               AND
         mAddr <> "000000"              AND
         AVAILABLE op                   AND
         CAN-DO(FGetSetting("СтандТр", "СчАдрПлат", ""), op.ben-acct)
      THEN
         mResult = mResult + " " + mRazdL + mAddr + mRazdR.
   END.
   ELSE IF CAN-DO("ФИО-2281У,ФИО-222П", mTypeInfo) THEN DO:
      mResult = mName.
      IF acct.cust-cat EQ "В" THEN
         mResult = mResult + " " + mRazdL + " " + mRazdR + (IF AVAIL op THEN STRING(op.op) ELSE "") + mRazdL + " " + mRazdR.
      ELSE IF (AVAILABLE op) AND
               ( CAN-DO(FGetSetting("СтандТр", "СчАдрПлат", ""), op.ben-acct)
		OR (acct.cust-cat EQ "Ч" AND CAN-DO("40101*", op.ben-acct)))
      THEN
         mResult = mResult + " " + mRazdL + mAddr + mRazdR.
      ELSE IF     mINN  EQ ""
         AND mAddr NE "000000"
         AND mAddr NE ? THEN
      mResult = mResult + " " + mRazdL + mAddr + mRazdR.
      ELSE IF acct.cust-cat EQ "Ч"
          AND mINN          EQ ""
          AND mAddr         EQ "000000" THEN
      DO:
         IF mTypeInfo EQ "ФИО-222П" THEN DO:
            FIND FIRST person WHERE person.person-id EQ acct.cust-id NO-LOCK NO-ERROR.
            IF AVAILABLE person THEN DO:
               mResult = mResult + " " + mRazdL.
               IF person.birthday NE ? THEN
                  mResult = mResult + STRING(person.birthday) + " ".
               mResult = mResult
                         + GetXAttrValueEx("person",
                                           STRING(acct.cust-id),
                                           "BirthPlace",
                                           "")
                         + mRazdR.
            END.
         END.
         ELSE mResult = mResult + " " + mRazdL + " " + mRazdR.
      END.
      IF NOT {assigned mResult} THEN
         mResult = mName.
   END.
   ELSE IF mTypeInfo EQ "ФИО" THEN
      IF acct.cust-cat EQ "В" THEN
         mResult = FGetSetting("Банк", ?, "").
      ELSE
         mResult = mName.
/*0229671 ФИО-107н */
   ELSE IF mTypeInfo EQ "ФИО-107н" THEN DO:
      IF AVAIL(op) THEN mBen-Acct = op.ben-acct.

         IF {assigned mBen-Acct} AND CAN-DO(fGetSetting("ГНИ","bal-nalog",""),mBen-Acct) THEN DO: /*2*/
            CASE acct.cust-cat:
            WHEN "Ч" THEN DO: /*3*/
               ASSIGN
                  mIsPredpr = GetXattrValue("person", STRING(acct.cust-id), "Предпр") BEGINS "Пред"
                  mTypeITD  = GetXattrValue("person", STRING(acct.cust-id), "ВидИТД")
               .
               IF mIsPredpr OR {assigned mTypeITD} THEN 
                  mResult = mName + 
                           (IF {assigned mTypeITD} THEN
                              " ("  + mTypeITD + ") " 
                            ELSE " (ИП) ") + 
                              (IF mAddr NE "000000" AND mAddr NE ? THEN
                              (mRazdL + mAddr + mRazdR)
                               ELSE "").
               IF NOT mIsPredpr AND NOT {assigned mTypeITD} THEN DO: /*4*/
                  FIND FIRST person WHERE person.person-id EQ acct.cust-id NO-LOCK NO-ERROR.
                  mUIN = GetXattrValue("op",STRING(op.op),"УИН"). 
                  mResult = mName + 
                           (IF mAddr NE "000000" AND mAddr NE ? 
                               AND (NOT {assigned mUIN} OR mUIN EQ "0") AND 
                              (AVAIL(person) AND (NOT {assigned person.inn} OR person.inn EQ "000000000000")) THEN
                              (" " + mRazdL + mAddr + mRazdR)
                            ELSE "").
               END. /*4*/
            END. /*3*/
            WHEN "Ю" THEN DO: /*5*/
               FIND FIRST cust-corp WHERE
                        cust-corp.cust-id EQ acct.cust-id
                        NO-LOCK NO-ERROR.
               IF AVAIL(cust-corp) THEN DO: /*7*/
                  IF CAN-DO(FGetSetting("СтандТр","СтатусФЛЧП",""),cust-corp.cust-stat) THEN DO: /*6*/
                     CASE cust-corp.cust-stat:
                        WHEN "Адвокат"  THEN mStrTmp = "адвокат".
                        WHEN "Нотариус" THEN mStrTmp = "нотариус".
                        WHEN "ГКФХ"     THEN mStrTmp = "КФХ".
                        OTHERWISE mStrTmp = cust-corp.cust-stat.
                     END CASE.
                     mResult = cust-corp.name-corp + " (" + 
                               mStrTmp + ") " +                                                  
                              (IF mAddr NE "000000" AND mAddr NE ? THEN
                              (mRazdL + mAddr + mRazdR)
                               ELSE ""). 
                  END.  /*6*/
                  ELSE mResult = mName.
               END. /*7*/                         
            END. /*5*/
            WHEN "В" THEN DO: /*8*/
               IF AVAIL(op) THEN DO: /*9*/
                  FIND FIRST op-entry OF op WHERE
                             op-entry.acct-db <> ?
                  NO-LOCK NO-ERROR.
                  IF AVAIL(op-entry) AND CAN-DO(FGetSetting("СтандТр","СчетаБОС",""),op-entry.acct-db)
                  THEN DO: /*10*/
                     RUN browseld.p("person",
                                    "CrClass-Code" + CHR(1) + "Title",
                                    "*" + CHR(1) + "Выберите плательщика",
                                    "",
                                    7).
                     IF (LASTKEY EQ 13 OR LASTKEY EQ 10) AND {assigned pick-value} THEN DO: /*11*/
                        FIND FIRST person WHERE person.person-id EQ INT64(pick-value) NO-LOCK NO-ERROR.
                        IF AVAIL(person) THEN DO: /*12*/
                           mResult = mName +  " " + mRazdL + " " +
                                     person.name-last + " " + person.first-names +  " " + mRazdL + " " 
                                     + person.address[1] + " " + mRazdL.
                        END. /*12*/
                        ELSE mResult = mName + " " + mRazdL + " " + mRazdL + " " + mRazdR.
                     END. /*11*/
                     ELSE mResult = mName + " " + mRazdL + " " + mRazdL + " " + mRazdR.
                  END. /*10*/
                  ELSE mResult = mName.
               END. /*9*/
            END. /*8*/

            END CASE.
         END. /*2*/
/* 0229671 */
         ELSE
            IF AVAIL(op) THEN 
            DO: /*21*/
               FIND FIRST op-entry
                  WHERE op-entry.op EQ op.op
                  AND op-entry.acct-db NE ?
                  NO-LOCK NO-ERROR.
               IF AVAILABLE(op-entry) THEN DO: /*22*/
/*Если счет получателя (ben-acct) не удовлетворяет НП bal-nalog И счет по дебету 
удовлетворяет НП СчетаБОС, то генерируется запрос на необходимость выбора ФЛ из 
справочника физ.лиц (person) - клиентов и не клиентов и по выбранному ФЛ 
автоматически выводится один из вариантов:*/
                  IF CAN-DO(FGetSetting("СтандТр","СчетаБОС",""),op-entry.acct-db) THEN DO: /*23*/
                     RUN browseld.p("person",
                                    "CrClass-Code" + CHR(1) + "Title",
                                    "*" + CHR(1) + "Выберите плательщика",
                                    "",
                                    7).
                     IF (LASTKEY EQ 13 OR LASTKEY EQ 10) 
                        AND {assigned pick-value}
                     THEN DO: /*24*/
                        FIND FIRST person 
                           WHERE person.person-id EQ INT64(pick-value) 
                        NO-LOCK NO-ERROR.
                        IF AVAIL(person) THEN DO: /*25*/
/*1) 2) при наличии ИНН          наименование нашего банка //ФИО//ИНН//  */
                           IF person.inn NE "" AND person.inn NE ? THEN
                              IF CAN-DO(fGetSetting("СтандТр","СчАдрПлат",""),mBen-Acct) 
                                 AND op-entry.amt-rub GT DECIMAL(fGetSetting("И113","Сумма1626","")) 
                              THEN
/*если счет получателя (ben-acct) удовлетворяет НП СчАдрПлат И сумма перевода превышает 
значение НП Сумма1626, то адрес выводится всегда (независимо от наличия ИНН): */
                                 mResult = mName +  " " + mRazdL + " " +
                                 person.name-last + " " + person.first-names +  " " + mRazdL + " " 
                                 + person.address[1] + " " + mRazdL.
                              ELSE
                                 mResult = mName +  " " + mRazdL + " " +
                                 person.name-last + " " + person.first-names +  " " + mRazdL + " " 
                                 + person.inn + " " + mRazdL.
                           ELSE
/*1) при отсутствии ИНН     наименование нашего банка //ФИО// адрес форматированный//  */
                              mResult = mName +  " " + mRazdL + " " +
                                        person.name-last + " " + person.first-names +  " " + mRazdL + " " 
                                        + person.address[1] + " " + mRazdL.
                        END. /*25*/
                        ELSE 
                           mResult = mName + " " + mRazdL + " " + mRazdL + " " + mRazdR.
                     END. /*24*/
                     ELSE 
                        mResult = mName + " " + mRazdL + " " + mRazdL + " " + mRazdR.
                  END. /*23*/
                  ELSE DO:
/* Если счет получателя (ben-acct) не удовлетворяет НП bal-nalog И счет по дебету удовлетворяет НП ФизМаск, 
то выводить ФИО + статус индивидуального предпринимателя, адвоката, нотариуса в скобках аналогично текущему 
алгоритму параметра ФИО-107н для налоговых платежей, НО адрес выводить только при условии, если счет 
получателя (ben-acct) удовлетворяет НП СчАдрПлат И сумма перевода превышает значение НП Сумма1626: */
                     IF CAN-DO(FGetSetting("СтандТр","ФизМаск",""),op-entry.acct-db) THEN DO: /*33*/
                        ASSIGN
                           mIsPredpr = GetXattrValue("person", STRING(acct.cust-id), "Предпр") BEGINS "Пред"
                           mTypeITD  = GetXattrValue("person", STRING(acct.cust-id), "ВидИТД"). 

                        IF mIsPredpr OR {assigned mTypeITD} THEN 
                           mResult = mName + 
                                     (IF {assigned mTypeITD} THEN
                                        " ("  + mTypeITD + ") " 
                                     ELSE " (ИП) ") + 
                                     (IF mAddr NE "000000" AND mAddr NE ? THEN
                                        (IF CAN-DO(fGetSetting("СтандТр","СчАдрПлат",""),mBen-Acct) 
                                         AND op-entry.amt-rub GT DECIMAL(fGetSetting("И113","Сумма1626","")) THEN
                                           (mRazdL + mAddr + mRazdR) 
                                           ELSE "")
                                      ELSE "").
                        IF NOT mIsPredpr AND NOT {assigned mTypeITD} THEN DO: /*4*/
                           FIND FIRST person WHERE person.person-id EQ acct.cust-id NO-LOCK NO-ERROR.
                           mUIN = GetXattrValue("op",STRING(op.op),"УИН"). 
                           mResult = mName + 
                                     (IF mAddr NE "000000" AND mAddr NE ? 
                                         AND (NOT {assigned mUIN} OR mUIN EQ "0") AND 
                                        (AVAIL(person) AND (NOT {assigned person.inn} OR person.inn EQ "000000000000")) THEN
                                        (IF CAN-DO(fGetSetting("СтандТр","СчАдрПлат",""),mBen-Acct) 
                                         AND op-entry.amt-rub GT DECIMAL(fGetSetting("И113","Сумма1626","")) THEN
                                           (" " + mRazdL + mAddr + mRazdR)
                                           ELSE "")
                                        ELSE "").
                        END. /*4*/
                     END. /*33*/
/* Если счет получателя (ben-acct) не удовлетворяет НП bal-nalog И счет по дебету удовлетворяет НП ЮрМаск, т
о выводить наименование ЮЛ стандартно, адрес - только при условии, если счет получателя (ben-acct) 
удовлетворяет НП СчАдрПлат */
                     IF CAN-DO(FGetSetting("СтандТр","ЮрМаск",""),op-entry.acct-db) THEN DO:
                        FIND FIRST cust-corp WHERE
                                   cust-corp.cust-id EQ acct.cust-id
                        NO-LOCK NO-ERROR.
                        IF AVAIL(cust-corp) THEN DO: /*7*/
                           IF CAN-DO(FGetSetting("СтандТр","СтатусФЛЧП",""),cust-corp.cust-stat) THEN DO: /*6*/
                              CASE cust-corp.cust-stat:
                                 WHEN "Адвокат"  THEN mStrTmp = "адвокат".
                                 WHEN "Нотариус" THEN mStrTmp = "нотариус".
                                 WHEN "ГКФХ"     THEN mStrTmp = "КФХ".
                                 OTHERWISE mStrTmp = cust-corp.cust-stat.
                              END CASE.
                              mResult = cust-corp.name-corp + " (" + 
                                        mStrTmp + ") " +                                                  
                                        (IF mAddr NE "000000" AND mAddr NE ? THEN
                                           (IF CAN-DO(fGetSetting("СтандТр","СчАдрПлат",""),mBen-Acct) 
                                            AND op-entry.amt-rub GT DECIMAL(fGetSetting("И113","Сумма1626","")) THEN
                                              (mRazdL + mAddr + mRazdR)
                                              ELSE "")
                                        ELSE ""). 
                           END.  /*6*/
                           ELSE mResult = mName.
                        END. /*7*/                         
                     END.
                  END.
               END. /*22*/
            END. /*21*/
/* 0229671 */
      ELSE 
         mResult = mName.
      IF NOT {assigned mResult} THEN
         mResult = mName.
   END.

   ELSE IF mTypeInfo EQ "ИНН" THEN
      mResult = IF {assigned mInn} THEN mInn ELSE "?".
   ELSE IF mTypeInfo EQ "ИННв"
   THEN DO:
      IF acct.cust-cat EQ "В" THEN
         mResult = FGetSetting("ИНН", "", "").
      ELSE
         mResult = IF {assigned mInn} THEN mInn ELSE "?".
   END.

   ELSE IF mTypeInfo EQ "КПП" THEN
      mResult = mKPP.
   ELSE IF CAN-DO("АДРЕС,АДРЕСР",mTypeInfo) THEN
      mResult = mAddr.
   ELSE IF mTypeInfo EQ "ДАТАРОЖДЕНИЯ" THEN DO:
      IF acct.cust-cat EQ "Ч" THEN DO:
         FIND FIRST person WHERE person.person-id EQ acct.cust-id NO-LOCK NO-ERROR.
         IF AVAILABLE person THEN DO:
            IF person.birthday NE ? THEN
               mResult = STRING(person.birthday, "99/99/9999").
         END.
      END.
   END.
   ELSE IF mTypeInfo EQ "МЕСТОРОЖДЕНИЯ" THEN DO:
      IF acct.cust-cat EQ "Ч" THEN
         mResult = GetXAttrValueEx("person",
                                   STRING(acct.cust-id),
                                   "BirthPlace",
                                   "").
   END.
   ELSE IF mTypeInfo EQ "КартСч" THEN DO:
      IF acct.cust-cat EQ "Ч" OR acct.cust-cat EQ "Ю" THEN 
         mResult = (IF GetXattrValue(IF acct.cust-cat EQ "Ч" THEN "person" ELSE "cust-corp", STRING(acct.cust-id), "Предпр") BEGINS "Пред" THEN 
                       "Индивидуальный предприниматель " ELSE "")
                    + mName.             
   END.                                 

   is-ok = YES.
   RUN Pars-SetCHARresult(mResult).

END PROCEDURE.

PROCEDURE ТипСч:
    DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE mAcct     AS CHARACTER NO-UNDO.
    DEFINE VARIABLE mCurr     AS CHARACTER NO-UNDO.
    DEFINE VARIABLE mCat      AS CHARACTER NO-UNDO.

    DEFINE VARIABLE  mResult  AS INT64 NO-UNDO.

    DEFINE BUFFER acct FOR acct.

    IF NOT pars-validparam(3) THEN
      RETURN.

    mAcct     = Pars-GetString(0).
    mCurr     = Pars-GetString(1).
    mCat      = Pars-GetString(2).

    IF mCurr EQ "{&in-NC-Code}" THEN
      mCurr = "".

    {find-act.i
      &acct = mAcct
      &curr = mCurr
    }

    IF NOT AVAILABLE acct THEN
       RETURN.

    IF CAN-DO(mCat, acct.cust-cat) THEN
      mResult = 1.
   ELSE
      mResult = 0.

    is-ok = YES.

    RUN Pars-SetResult(mResult).

END PROCEDURE.

PROCEDURE РЕЗИДЕНТ:
    DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE vCustCat AS CHARACTER NO-UNDO.
    DEFINE VARIABLE vCustId  AS INT64   NO-UNDO.

    IF NOT pars-validparam(2) THEN
      RETURN.
    vCustCat = Pars-GetString(0).
    vCustId  = INT64(Pars-GetString(1)).

    IF IsResident(vCustCat, vCustId) THEN
       RUN Pars-SetCHARResult ( "YES" ).
/*       RUN Pars-SetResult ( 1 ).*/
    ELSE
       RUN Pars-SetCHARResult ( "NO" ).
/*       RUN Pars-SetResult ( 0 ).*/

    is-ok = YES.

END PROCEDURE.

PROCEDURE acctCustCat:
    DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE vAcct AS CHARACTER NO-UNDO.
    DEFINE VARIABLE vCurr AS CHARACTER NO-UNDO.

    DEFINE BUFFER acct FOR acct.

    IF NOT pars-validparam(2) THEN
      RETURN.

    vAcct = Pars-GetString(0).
    vCurr = Pars-GetString(1).

    {find-act.i
      &acct = vAcct
      &curr = vCurr
    }

    IF AVAILABLE acct THEN
       RUN Pars-SetCHARResult ( acct.cust-cat ).
    ELSE
       RUN Pars-SetCHARResult ( "" ).


    is-ok = YES.

END PROCEDURE.

PROCEDURE acctCustId:
    DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    DEFINE VARIABLE vAcct AS CHARACTER NO-UNDO.
    DEFINE VARIABLE vCurr AS CHARACTER NO-UNDO.

    DEFINE BUFFER acct FOR acct.

    IF NOT pars-validparam(2) THEN
      RETURN.

    vAcct = Pars-GetString(0).
    vCurr = Pars-GetString(1).

    {find-act.i
      &acct = vAcct
      &curr = vCurr
    }

    IF AVAILABLE acct THEN
       RUN Pars-SetResult ( STRING(acct.cust-id) ).
    ELSE
       RUN Pars-SetCHARResult ( "" ).


    is-ok = YES.

END PROCEDURE.

PROCEDURE DateDoc:
   DEFINE INPUT  PARAMETER iCode AS CHAR    NO-UNDO.
   DEFINE INPUT  PARAMETER iRid  AS RECID   NO-UNDO.
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vCode    AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vTemplet AS INT64   NO-UNDO.
   DEFINE VARIABLE vFormat  AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vData    AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vDate    AS DATE      NO-UNDO.
   DEFINE VARIABLE vField   AS CHARACTER NO-UNDO.

   DEFINE BUFFER wop       FOR wop.       /* Локализация буфера. */
   DEFINE BUFFER op        FOR op.        /* Локализация буфера. */
   DEFINE BUFFER op-entry  FOR op-entry.  /* Локализация буфера. */

   /* Разбор входных параметров. */
   IF NOT (   Pars-ValidParam(0)
           OR Pars-ValidParam(1)
           OR Pars-ValidParam(2)
           OR Pars-ValidParam(3)   ) THEN
      RETURN.

   vCode = iCode.
   IF pn GE 1
      THEN vTemplet = Pars-GetInt ( 1 ).
   IF pn EQ 2
      THEN vFormat = Pars-GetString ( 2 ).
   IF    vFormat EQ ?
      OR vFormat EQ ""
      THEN vFormat = "99/99/9999".

   /* Формирование кода поля для поиска во фрейме. */
   CASE vCode:
      WHEN "П" THEN  vField = "contract-date".
      WHEN "Д" THEN  vField = "doc-date".
      WHEN "С" THEN  vField = "due-date".
      WHEN "В" THEN  vField = "ins-date".
      WHEN "О" THEN  vField = "op-date".
      WHEN "К" THEN  vField = "value-date".
      OTHERWISE RETURN.
   END CASE.

   /* Ищем в форме ввода документа. */
   RUN internal-parser-getdetails-form-ttable (vTemplet,
                                               "",
                                               vField,
                                               OUTPUT vData).
   IF vData EQ ? THEN
   DO:
      /* Корректировка кода и повторный поиск. */
      vField = "op-" + vField.
      RUN internal-parser-getdetails-form-ttable (vTemplet,
                                                  "",
                                                  vField,
                                                  OUTPUT vData).
   END.

   vDate = DATE (vData) NO-ERROR.

   /* Поиск прототипа создаваемого документа. */
   FIND FIRST wop WHERE
      IF vTemplet GT 500
         THEN (wop.op-templ EQ vTemplet)
         ELSE (RECID(wop) EQ iRid)
   NO-LOCK NO-ERROR.

/* Прототип документа не найден. */
   IF AVAIL wop THEN
   DO:
      /* Поиск документа. */
      FIND FIRST op WHERE
         RECID(op) EQ wop.op-recid
      NO-LOCK NO-ERROR.
   END.

   IF vDate EQ ? THEN
   DO:
      IF AVAIL wop THEN
      CASE vCode:
         WHEN "П" THEN  vDate = wop.con-date.
         WHEN "О" THEN  vDate = wop.op-date.
         WHEN "К" THEN  vDate = wop.value-date.
      END CASE.

      IF     vDate EQ ?
         AND AVAIL op THEN
      CASE vCode:
         WHEN "П" THEN  vDate = op.contract-date.
         WHEN "Д" THEN  vDate = op.doc-date.
         WHEN "С" THEN  vDate = op.due-date.
         WHEN "В" THEN  vDate = op.ins-date.
         WHEN "О" THEN  vDate = op.op-date.
         WHEN "К" THEN  vDate = op.op-value-date.
      END CASE.
   END.

   /* Формирование результата. */
   RUN Pars-SetCHARResult (IF vDate NE ?
                              THEN STRING(vDate, vFormat)
                              ELSE "").
   is-ok = TRUE.

END PROCEDURE.

/*
PROCEDURE ПустойШаблон:
    DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

    IF NOT pars-validparam(<кол-во параметров функции>) THEN
      RETURN.

    is-ok = YES.

END PROCEDURE.
*/

/* Получение значения допреквизита с документа созданного ранее текущей транзакцией */
PROCEDURE ДР_Док.
   DEFINE OUTPUT PARAM is-ok AS LOGICAL NO-UNDO.

   DEFINE VARIABLE vTmpl  AS INT64   NO-UNDO. /* номер шаблона */
   DEFINE VARIABLE vKodDR AS CHAR  NO-UNDO. /* код ДР */
   DEFINE VARIABLE vValDR AS CHAR  NO-UNDO. /* значение ДР */

   DEF BUFFER tmpl-op FOR op. /* Локализация буфера. */

   /* Разбор входных параметров. */
   IF NOT (   Pars-ValidParam(1)
           OR Pars-ValidParam(2)) THEN
      RETURN.
   ASSIGN
      vTmpl = Pars-GetInt(0)
      vKodDR = Pars-GetString(1)
   .

            /* поиск проводки созданной шаблоном с номером vTag в wop */
   FIND FIRST xwop WHERE xwop.op-templ EQ vTmpl NO-LOCK NO-ERROR.
   IF AVAIL xwop THEN
               /* поиск документа созданного шаблоном с номером vTag */
      FIND FIRST tmpl-op WHERE RECID(tmpl-op) EQ xwop.op-recid NO-LOCK NO-ERROR.
            /* если документ найден */
   IF AVAIL tmpl-op THEN
   DO:
                  /* берем значение ДР с документа */
      vValDR = GetXAttrValue("op",STRING(tmpl-op.op),vKodDR).
      RUN Pars-SetCHARResult (vValDR).
   END.

   is-ok = YES.
   RETURN.
END PROCEDURE.


PROCEDURE Уст_СПОДПРИБУБ:
   DEF OUTPUT PARAM is-ok AS LOG NO-UNDO. /* Успешно ли выполнена ? */

   DEFINE VARIABLE mAcct707  AS CHAR NO-UNDO.
   DEFINE VARIABLE mResult   AS CHAR NO-UNDO.
   DEFINE VARIABLE vAcctMskDb AS CHAR NO-UNDO.
   DEFINE VARIABLE vAcctMskCr AS CHAR NO-UNDO.

   IF NOT Pars-ValidParam(1) THEN
      RETURN.

   IF result_l[pj] NE 0 THEN
   DO:
       FIND FIRST xwop WHERE
                  xwop.op-templ EQ INT64(result_l[pj])
       NO-LOCK NO-ERROR.
       IF AVAIL xwop THEN
       DO:
          ASSIGN
             vAcctMskDb = GetXattrValueEx("op-kind",
                                          wop.op-kind,
                                          "СПОДдебет",
                                          FGetSetting("СПОД","СПОДдебет",""))
             vAcctMskCr = GetXattrValueEx("op-kind",
                                          wop.op-kind,
                                          "СПОДкредит",
                                          FGetSetting("СПОД","СПОДкредит",""))
          .
          IF CAN-DO(vAcctMskDb,xwop.acct-db) THEN
             mAcct707 = xwop.acct-db.
          ELSE IF CAN-DO(vAcctMskCr,xwop.acct-db) THEN
             mAcct707 = xwop.acct-cr.

          IF {assigned mAcct707} THEN
             RUN GetCodeSpodPU (mAcct707,
                                IF xwop.op-date EQ ? THEN gend-date ELSE xwop.op-date,
                                OUTPUT mResult).
       END.
   END.
   RUN Pars-SetCHARResult (mResult).
   is-ok = TRUE.
END PROCEDURE.


PROCEDURE Дата_Прописью.
   DEFINE OUTPUT PARAM is-ok AS LOGICAL NO-UNDO.
   IF NOT (   Pars-ValidParam(1)
           OR Pars-ValidParam(2)) THEN
      RETURN.
   /* Формирование результата. */
   RUN Pars-SetCHARResult (getDateString(DATE(Pars-GetString(0)),
                                         Pars-GetString(1) EQ "ДА")
                          ) .
   is-ok = TRUE.
END PROCEDURE.

PROCEDURE NCashTime:
   DEFINE OUTPUT PARAM is-ok AS LOGICAL NO-UNDO.

   DEFINE VARIABLE vDpr-id AS INT64 NO-UNDO.

   vDpr-id = INT64(DYNAMIC-FUNCTION("tGetParam" IN h_tparam, "dpr-id", "vok", "")) NO-ERROR.
   IF NOT ERROR-STATUS:ERROR THEN
   DO:
      vDpr-id = IF vDpr-id EQ 0 THEN ? ELSE vDpr-id.
      RUN Pars-SetResult (INT64(IsVecherKas(GetBranchIDFromSessions(vDpr-id)))).
      is-ok = TRUE.
   END.
END PROCEDURE.

PROCEDURE ОстБлокСуммВ:
   DEF OUTPUT PARAM oIsOk AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vAcct   AS CHAR NO-UNDO.  /* Номер счета */
   DEFINE VARIABLE vCurr   AS CHAR NO-UNDO.  /* Валюта счета */
   DEFINE VARIABLE vResult AS DEC  NO-UNDO.
   DEFINE VARIABLE vBlck   AS CHAR NO-UNDO.

   ASSIGN
      sh-val = 0
      vAcct  = Pars-GetString(1)
      vCurr  = IF pn > 1 THEN Pars-GetString(2) ELSE ?
      vCurr  = IF    vCurr EQ ? 
                  OR vCurr EQ vNatCurrChar
                  OR vCurr EQ "0"
               THEN "" ELSE vCurr
      vBlck  = FGetSetting("УчитБлок", ?, "")
   .

   RUN Ост ( OUTPUT oIsOk ).
   IF NOT oIsOk THEN
      RETURN.
   
   vResult = (IF vCurr EQ "" THEN sh-bal ELSE sh-val).
   
   IF vBlck EQ "Да" THEN
      vResult = vResult - GetBlockPosition(vAcct,vCurr,"",in-op-date).
   RUN Pars-SetResult (vResult).

END PROCEDURE.

PROCEDURE ОстБлокСуммР:
   DEF OUTPUT PARAM oIsOk AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vAcct   AS CHAR NO-UNDO.  /* Номер счета */
   DEFINE VARIABLE vCurr   AS CHAR NO-UNDO.  /* Валюта счета */
   DEFINE VARIABLE vResult AS DEC  NO-UNDO.
   DEFINE VARIABLE vBlck   AS CHAR NO-UNDO.


   ASSIGN
      sh-bal = 0
      vAcct  = Pars-GetString(1)
      vCurr  = Pars-GetString(2)
      vCurr  = IF    vCurr EQ ? 
                  OR vCurr EQ vNatCurrChar
               THEN "" ELSE vCurr
      vBlck  = FGetSetting("УчитБлок", ?, "")
   .
   RUN Ост ( OUTPUT oIsOk ).
   IF NOT oIsOk THEN
      RETURN.
   IF vCurr EQ vNatCurrChar THEN
      vCurr = "".

   IF vBlck EQ "Да" THEN
      vResult = sh-bal -  IF vCurr NE ""
                          THEN CurToBase("Учетный",vCurr,in-op-date,GetBlockPosition(vAcct,vCurr,"",in-op-date))
                          ELSE GetBlockPosition(vAcct,vCurr,"",in-op-date).
   ELSE
      vResult = sh-bal.

   RUN Pars-SetResult (vResult).

END PROCEDURE.

PROCEDURE ОверПрос:
   DEF OUTPUT PARAM oIsOk AS LOG  NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vh_templ  AS HANDLE NO-UNDO.
   DEFINE VARIABLE vResult   AS INT64    NO-UNDO.
   DEFINE VARIABLE vContract AS CHAR   NO-UNDO.
   DEFINE VARIABLE vContCode AS CHAR   NO-UNDO.
   DEFINE VARIABLE vPriost   AS CHAR   NO-UNDO.
   DEFINE VARIABLE vDPriost  AS CHAR   NO-UNDO.
   DEFINE VARIABLE vDatePr   AS DATE   NO-UNDO.
   DEFINE VARIABLE vDate     AS DATE   NO-UNDO.

   MAIN:
   DO ON ERROR  UNDO MAIN, LEAVE MAIN:
      IF NOT Pars-ValidParam(1) THEN
         LEAVE MAIN.
      RUN LOAN_VALID_HANDLE (INPUT-OUTPUT vh_templ).
      IF NOT VALID-HANDLE(vH_templ) THEN
         LEAVE MAIN.
      ASSIGN
         vContract = ENTRY(1, vH_templ:PRIVATE-DATA)
         vContCode = ENTRY(2, vH_templ:PRIVATE-DATA)
         vPriost   = GetXattrValueEx("loan",
                                     vContract + "," + vContCode,
                                     "Приостанов",
                                     "")
      .
      IF vPriost NE "ДА" THEN
         LEAVE MAIN.
      vDPriost = GetXattrValueEx("loan",
                                 vContract + "," + vContCode,
                                 "ДатаПриостанов",
                                 "").
      IF vDPriost EQ "" THEN
         LEAVE MAIN.
      vDatePr = DATE (vDPriost).
      vDate = IF Pars-GetString(0) EQ "ОД" THEN in-op-date
                                           ELSE wop.con-date.
      vResult = IF vDatePr LE vDate THEN 1 ELSE 0.
   END.
   RUN Pars-SetResult (vResult).
   oIsOk = TRUE.
END PROCEDURE.

PROCEDURE ОверСтоп:
   DEF OUTPUT PARAM oIsOk     AS LOG  NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vH_templ  AS HANDLE NO-UNDO.
   DEFINE VARIABLE vDate     AS DATE   NO-UNDO.
   DEFINE VARIABLE vResult   AS INT64    NO-UNDO.
   DEFINE VARIABLE vContract AS CHAR   NO-UNDO.
   DEFINE VARIABLE vContCode AS CHAR   NO-UNDO.
   DEFINE VARIABLE vOvStop   AS INT64    NO-UNDO.

   DEF BUFFER loan FOR loan.

   MAIN:
   DO:
      IF NOT Pars-ValidParam(1) THEN
         LEAVE MAIN.
      RUN LOAN_VALID_HANDLE (INPUT-OUTPUT vh_templ).
      IF NOT VALID-HANDLE(vH_templ) THEN
         LEAVE MAIN.
      ASSIGN
         vContract = ENTRY(1, vH_templ:PRIVATE-DATA)
         vContCode = ENTRY(2, vH_templ:PRIVATE-DATA)
         vContCode = IF NUM-ENTRIES(vContCode, " ") GT 1
                     THEN ENTRY(1, vContCode, " ")
                     ELSE vContCode
      .
      FIND FIRST loan WHERE
                 loan.contract  EQ vContract
             AND loan.cont-code EQ vContCode
      NO-LOCK NO-ERROR.
      IF NOT AVAIL loan THEN
         LEAVE MAIN.
      vOvStop = INT64 (GetXattrValueEx("loan",
                                     vContract + "," + vContCode,
                                     "ОврСтоп",
                                     "0")
                    ).
      vDate = IF Pars-GetString(0) EQ "ОД" THEN in-op-date
                                           ELSE wop.con-date.
      vResult = IF vDate GT (loan.end-date - vOvStop) THEN 1 ELSE 0.
      RUN Pars-SetResult (vResult).
      oIsOk = TRUE.
   END.
END PROCEDURE.

PROCEDURE ЕстьОстаток:
   DEF OUTPUT PARAM oIsOk     AS LOG  NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vH_templ  AS HANDLE NO-UNDO.
   DEFINE VARIABLE vDate     AS DATE   NO-UNDO.
   DEFINE VARIABLE vResult   AS INT64    NO-UNDO.
   DEFINE VARIABLE vContract AS CHAR   NO-UNDO.
   DEFINE VARIABLE vContCode AS CHAR   NO-UNDO.
   DEFINE VARIABLE vLisrPar  AS CHAR   NO-UNDO.
   DEFINE VARIABLE vSumPrm   AS DEC    NO-UNDO.
   DEFINE VARIABLE vDbSumDec AS DEC    NO-UNDO.
   DEFINE VARIABLE vCrSumDec AS DEC    NO-UNDO.
   DEFINE VARIABLE vCounter  AS INT64    NO-UNDO.

   DEF BUFFER loan FOR loan.

   MAIN:
   DO:
      IF NOT Pars-ValidParam(2) THEN
         LEAVE MAIN.
      ASSIGN
         vLisrPar  = Pars-GetString(0)
         vDate     = IF Pars-GetString(1) EQ "ОД"
                        THEN in-op-date
                        ELSE wop.con-date
      .
      RUN LOAN_VALID_HANDLE (INPUT-OUTPUT vh_templ).
      IF NOT VALID-HANDLE(vH_templ) THEN
         LEAVE MAIN.
      ASSIGN
         vContract = ENTRY(1, vH_templ:PRIVATE-DATA)
         vContCode = ENTRY(2, vH_templ:PRIVATE-DATA)
      .
      REPEAT vCounter = 1 TO NUM-ENTRIES(vLisrPar):
         RUN STNDRT_PARAM IN h_Loan (vContract,
                                     vContCode,
                                     INT64 (ENTRY (vCounter, vLisrPar)),
                                     vDate,
                                     OUTPUT vSumPrm,
                                     OUTPUT vDbSumDec,
                                     OUTPUT vCrSumDec).
         IF vSumPrm NE 0 THEN
         DO:
            vResult = 1.
            LEAVE.
         END.
      END.
      RUN Pars-SetResult (vResult).
      oIsOk = TRUE.
   END.
END PROCEDURE.

PROCEDURE ОврСумДоСтоп:
   DEF OUTPUT PARAM oIsOk     AS LOG  NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vH_templ  AS HANDLE NO-UNDO.
   DEFINE VARIABLE vDate     AS DATE   NO-UNDO.
   DEFINE VARIABLE vDateTr   AS CHAR   NO-UNDO.
   DEFINE VARIABLE vResult   AS DEC    NO-UNDO.
   DEFINE VARIABLE vContract AS CHAR   NO-UNDO.
   DEFINE VARIABLE vContCode AS CHAR   NO-UNDO.
   DEFINE VARIABLE vSurr     AS CHAR   NO-UNDO.
   DEFINE VARIABLE vAcct     AS CHAR   NO-UNDO.
   DEFINE VARIABLE vCurr     AS CHAR   NO-UNDO.
   DEFINE VARIABLE vStatus   AS CHAR   NO-UNDO.
   DEFINE VARIABLE vStopDate AS DATE   NO-UNDO.
   DEFINE VARIABLE vTrDate   AS DATE   NO-UNDO.
   DEFINE VARIABLE vSumOver  AS DEC    NO-UNDO.
   DEFINE VARIABLE vSumLim   AS DEC    NO-UNDO.
   DEFINE VARIABLE vLimit    AS DEC    NO-UNDO.
   DEFINE VARIABLE vMeasure  AS CHAR   NO-UNDO.
   DEFINE VARIABLE vLimDebt  AS DEC    NO-UNDO.
   DEFINE VARIABLE vFindAcct AS CHAR   NO-UNDO. /* НП КартОвер */

   DEF BUFFER acct     FOR acct.
   DEF BUFFER bacct    FOR acct.
   DEF BUFFER loan     FOR loan.
   DEF BUFFER op       FOR op.
   DEF BUFFER op-entry FOR op-entry.

   MAIN:
   DO ON ERROR UNDO, RETRY:
      IF RETRY THEN
      DO:
         RUN Pars-SetResult (0).
         LEAVE MAIN.
      END.
      IF Pars-ValidParam(3) THEN
         vStatus = Pars-GetString(2).
      ELSE
         vStatus = "Ф".
      IF NOT Pars-ValidParam(2) THEN
         UNDO, RETRY MAIN.
      vAcct = Pars-GetString(0).
      ASSIGN
         vCurr = Pars-GetString(1)
         vCurr = IF vCurr EQ "810" THEN "" ELSE vCurr
      .
      {find-act.i
        &acct = vAcct
      }
      IF NOT AVAILABLE acct THEN
         UNDO, RETRY MAIN.
      RUN LOAN_VALID_HANDLE (INPUT-OUTPUT vh_templ).
      IF NOT VALID-HANDLE(vH_templ) THEN
         UNDO, RETRY MAIN.
      ASSIGN
         vContract = ENTRY(1, vH_templ:PRIVATE-DATA)
         vContCode = ENTRY(2, vH_templ:PRIVATE-DATA)
         vContCode = IF NUM-ENTRIES(vContCode, " ") GT 1
                     THEN ENTRY(1, vContCode, " ")
                     ELSE vContCode
      .
      FIND FIRST loan WHERE
                 loan.contract  EQ vContract
             AND loan.cont-code EQ vContCode
      NO-LOCK NO-ERROR.
      IF NOT AVAIL loan THEN
         UNDO, RETRY MAIN.
      vSurr = loan.contract + "," + loan.cont-code.
      vDate = in-op-date.
      CASE GetXattrValueEx("loan",
                         vSurr,
                         "КартОвер",
                         ""):
         WHEN "Разреш" THEN
         DO:
         END.
            /* если ДР не ведется, то определяем по классу счета */
         WHEN "" THEN
         DO:
            vFindAcct = FGetSetting("КартОвер", ?, "").
            IF    vFindAcct EQ ""
               OR NUM-ENTRIES(vFindAcct,"=") NE 2 THEN
               UNDO, RETRY MAIN.
            FIND LAST loan-acct WHERE
                      loan-acct.contract  EQ loan.contract
                  AND loan-acct.cont-code EQ loan.cont-code
                  AND loan-acct.acct-type EQ ENTRY(1, vFindAcct, "=")
                  AND loan-acct.since     LE vDate
            NO-LOCK NO-ERROR.
            IF NOT AVAIL loan-acct THEN
               UNDO, RETRY MAIN.
            {find-act.i
               &bact = bacct
               &acct = loan-acct.acct
            }
            IF NOT AVAIL bacct THEN
               UNDO, RETRY MAIN.
            IF NOT CAN-DO(ENTRY(2, vFindAcct, "="), bacct.class-code) THEN
            DO:
               oIsOk = TRUE.
               UNDO, RETRY MAIN.
            END.
         END.
         OTHERWISE
         DO:
            oIsOk = TRUE.
            UNDO, RETRY MAIN.
         END.
      END CASE.
      vStopDate = DATE(GetXattrValueEx("loan",
                                       vSurr,
                                       "ДатаПриостанов",
                                      "")).
      IF vStopDate EQ ? THEN
         vStopDate = loan.end-date - INT64 (GetXattrValueEx("loan",
                                                          vSurr,
                                                          "ОврСтоп",
                                                          "0")
                                          ).
      IF vStopDate LE vDate THEN /* если есть приостановление или кончился срок */
      DO:
         /* получаем сумму проводок с ДР ТрДата */
         FOR EACH op-entry WHERE
                  op-entry.acct-db EQ acct.acct
              AND op-entry.op-date EQ vDate
         NO-LOCK,
            FIRST op WHERE
                  op.op        EQ op-entry.op
              AND op.op-status GE vStatus
         NO-LOCK:
            vTrDate  = DATE (GetXattrValueEx("op",
                                             STRING (op-entry.op),
                                             "ТрДата",
                                             "")
                            ) NO-ERROR.
            IF     vTrDate NE ?
               AND vTrDate LT vStopDate THEN
               vSumOver = vSumOver + IF op-entry.currency EQ ""
                                     THEN op-entry.amt-rub
                                     ELSE op-entry.amt-cur.
         END. /* FOR EACH op-entry */
         /* находим лимит */
         vLimit = ?.
         IF GetXAttrValueEx("loan",
                            vSurr,
                            "Режим",
                            ?) EQ "ЛимВыдЗад" THEN
         DO:
            RUN get-one-limit ("loan",
                               vSurr,
                               "limit-l-debts",
                               vDate,
                               "",
                               OUTPUT vMeasure,
                               OUTPUT vLimit). /* Лимит задолжености */
            IF vLimit EQ ? THEN
               RUN get-one-limit ("loan",
                                  vSurr,
                                  "limit-l-distr",
                                  vDate,
                                  "",
                                  OUTPUT vMeasure,
                                  OUTPUT vLimit). /* Лимит выдачи */

            IF vLimit EQ ? THEN
            DO:
               FIND FIRST term-obl WHERE
                          term-obl.contract  EQ vContract
                      AND term-obl.cont-code EQ vContCode
                      AND term-obl.idnt      EQ 2
                      AND term-obl.end-date  LE vDate /* дата последнего условия */
               NO-LOCK NO-ERROR.
               IF AVAIL term-obl THEN
                  vLimit = term-obl.amt-rub.
            END.
         END.
         ELSE
         DO:
            FIND LAST term-obl WHERE
                      term-obl.contract  EQ vContract
                  AND term-obl.cont-code EQ vContCode
                  AND term-obl.idnt      EQ 2
                  AND term-obl.end-date  LE vDate
            NO-LOCK NO-ERROR.
            IF AVAIL term-obl THEN
               vLimit = term-obl.amt-rub.
         END.
         IF vLimit EQ ? THEN
         DO:
            oIsOk = TRUE.
            UNDO, RETRY MAIN.
         END.
         vSumLim = vLimit - LnPrincipal(vContract,
                                        vContCode,
                                        vDate,
                                        loan.currency).
         RUN Pars-SetResult (MIN(vSumOver, MAX(vSumLim,0))).
      END.
      ELSE  /* договор на дату действует просто выдали овер */
      DO:
         oIsOk = TRUE.
         UNDO, RETRY MAIN.
      END.
      oIsOk = TRUE.
   END.
END PROCEDURE.

PROCEDURE УНИВ:
   DEFINE OUTPUT PARAMETER oIsOk AS LOGICAL NO-UNDO.
   DEFINE VAR vExpression AS CHARACTER NO-UNDO.
   DEFINE VAR vLibs       AS CHARACTER NO-UNDO.
   DEFINE VAR vResult     AS CHARACTER NO-UNDO.
   DEFINE VAR vFlErr      AS INT64   NO-UNDO.

   IF NOT (   Pars-ValidParam(1)
           OR Pars-ValidParam(2))
   THEN RETURN.

   vExpression = Pars-GetString(0).
   IF pn >= 1 THEN vLibs = Pars-GetString(1).

   {intrface.get parsr}
   RUN ParsMain IN h_parsr (vExpression,"",vLibs,OUTPUT vFlErr,OUTPUT vResult).
   IF vFlErr < 0 THEN RETURN.

   RUN Pars-SetCHARResult (vResult).
   oIsOk = YES.
END PROCEDURE.

/* Значение настроечного параметра */
PROCEDURE Настройка:
   DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vSetCode    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vSubCode    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vDefault    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vResult     AS CHARACTER  NO-UNDO.

   IF NOT (Pars-ValidParam(1) OR
           Pars-ValidParam(2) OR
           Pars-ValidParam(3))
   THEN RETURN.

   ASSIGN
      vSetCode = Pars-GetString(0)
      vSubCode = IF pn > 0 THEN Pars-GetString(1) ELSE ""
      vDefault = IF pn > 1 THEN Pars-GetString(2) ELSE ""
   .

   vResult = FGetSettingEx(vSetCode,vSubCode,vDefault,NO).

   RUN Pars-SetCharResult (IF {assigned vResult} THEN vResult ELSE "?").
   is-ok = YES.

END PROCEDURE.

/*
  Что делает: Значение настроечного параметра указанного филиала.
  Синтаксис : НастройкаФ(КОД ПАРАМЕТРА [, СУБКОД ПАРАМЕТРА [, ЗНАЧЕНИЕ ПО УМОЛЧАНИЮ [, КОД ФИЛИАЛА ]]]).
              если не задан код филиала - берется текущий филиал
*/

PROCEDURE НастройкаФ:
   DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE vSetCode    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vSubCode    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vDefault    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vFilial     AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vResult     AS CHARACTER  NO-UNDO.

   IF NOT (Pars-ValidParam(1) OR
           Pars-ValidParam(2) OR
           Pars-ValidParam(3) OR
           Pars-ValidParam(4))
   THEN RETURN.

   ASSIGN
      vSetCode = Pars-GetString(0)
      vSubCode = IF pn > 0 THEN Pars-GetString(1) ELSE ""
      vDefault = IF pn > 1 THEN Pars-GetString(2) ELSE ""
      vFilial  = IF pn > 2 THEN Pars-GetString(3) ELSE shFilial
   .

   vResult = FGetSettingMF(vSetCode,vSubCode,vDefault,vFilial,NO).

   RUN Pars-SetCharResult (IF {assigned vResult} THEN vResult ELSE "?").
   is-ok = YES.

END PROCEDURE.



PROCEDURE РеквСвязСубъекта:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнено */

   DEFINE VARIABLE vSysConf    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vCustRoleID AS INT64   NO-UNDO. 
   DEFINE VARIABLE vType     AS CHARACTER NO-UNDO. /* Реквизит */
   DEFINE VARIABLE vResult   AS CHARACTER NO-UNDO. /* Результат */

   DEFINE BUFFER person    FOR person. /* локализация буфера */
   DEFINE BUFFER cust-role FOR cust-role.

   IF NOT Pars-ValidParam(1) THEN
      RETURN.
   vType = Pars-GetString(0).

   vSysConf = GetSysConf("СвязСубъект").
   IF {assigned vSysConf} THEN DO:
      vCustRoleID = INT64(vSysConf) NO-ERROR.
      IF NOT ERROR-STATUS:ERROR AND vCustRoleID NE 0 THEN DO:
         FIND FIRST cust-role WHERE
                    cust-role.cust-role-id EQ vCustRoleID NO-LOCK NO-ERROR.
         IF AVAIL(cust-role) THEN DO:

            CASE vType:
               WHEN "Наименование" THEN
                  vResult = cust-role.cust-name.
               WHEN "ИНН" THEN
                  vResult = cust-role.inn.
               WHEN "КПП" THEN
                  vResult = cust-role.kpp.
               WHEN "ТипДокумента" THEN   
                  vResult = cust-role.cust-code-type.
               WHEN "Документ" THEN   
                  vResult = cust-role.cust-code.
               WHEN "Счет" THEN
                  vResult = cust-role.corr-acct.
               WHEN "КемВыдан"  OR WHEN "ДатаВыдачи" THEN DO:
                  IF cust-role.cust-cat EQ "Ч" THEN DO:
                     FIND FIRST person WHERE person.person-id EQ INT64(cust-role.cust-id) NO-LOCK NO-ERROR.
                     IF AVAIL(person) THEN DO:
                        IF vType EQ "КемВыдан" THEN vResult = person.issue. 
                        ELSE vResult = GetXAttrValueEx("person",
                                                       STRING(person.person-id),
                                                       "Document4Date_vid",
                                                       "").
                     END.
                  END. 
               END.
            END CASE.
         END.
      END.
   END.
   is-ok = YES.
   RUN Pars-SetCharResult (IF {assigned vResult}
                           THEN vResult
                           ELSE "?").

END PROCEDURE. /* РеквСвязСубъекта */

PROCEDURE РеквПостПолуч:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO INIT NO. /* успешно ли выполнено */

   DEFINE VARIABLE vPersonId   AS INT64   NO-UNDO. /* Постоянный получатель */
   DEFINE VARIABLE vType     AS CHARACTER NO-UNDO. /* Реквизит */
   DEFINE VARIABLE vResult   AS CHARACTER NO-UNDO. /* Результат */

   DEFINE BUFFER person FOR person. /* локализация буфера */
   DEFINE BUFFER cust-role FOR cust-role.
   DEFINE BUFFER m_user FOR _user.

   IF NOT Pars-ValidParam(1) THEN
      RETURN.
   vType = Pars-GetString(0).
   ASSIGN
      vPersonId = INT64(GetSysConf("ПостоянныйПолучатель"))
      NO-ERROR.
   IF ERROR-STATUS:ERROR THEN DO:
      RUN Fill-SysMes IN h_tmess ("", "", "-1", ERROR-STATUS:GET-MESSAGE(1)).
      RETURN.
   END.
   IF vPersonId = ? THEN DO:
      RUN Fill-SysMes IN h_tmess ("", "", "-1", "Не задано значение GetSysConf('ПостоянныйПолучатель')").
      RETURN.
   END.
   FIND FIRST person WHERE 
      person.person-id EQ vPersonId NO-LOCK NO-ERROR.
   IF NOT AVAIL person THEN DO:
      RUN Fill-SysMes IN h_tmess ("", "", "-1", subst("Не найдена запись person где person.person-id = &1", vPersonId)).
      RETURN.
   END.

      CASE vType:
         WHEN "ТипДокумента"      OR
         WHEN "document-id"       THEN
            vResult = person.document-id.
         WHEN "КемВыдан"          OR
         WHEN "issue"             THEN
            vResult = person.issue.
         WHEN "document"          OR
         WHEN "Документ"          THEN
            vResult = person.document.
         WHEN "Document4Date_vid" OR
         WHEN "КогдаВыдан"        OR
         WHEN "ДатаВыдачи"        THEN
            vResult = GetXAttrValueEx("person",
                                      STRING(person.person-id),
                                      "Document4Date_vid",
                                      "").
         WHEN "СерияДокумента"    OR
         WHEN "Document1Ser_Doc"  THEN
            vResult = GetXAttrValueEx("person",
                                      STRING(person.person-id),
                                      "Document1Ser_Doc",
                                      "").
         WHEN "Должность" THEN 
            vResult = GetXAttrValueEx("person",
                                      STRING(person.person-id),
                                      "Долж",
                                      "").
         WHEN "ФИО" THEN 
            vResult = person.name-last + " " + person.first-names. 
         WHEN "ДолжПольз" THEN DO:
          FIND FIRST cust-role WHERE cust-role.file-name  = "_user"
                               AND cust-role.class-code = "Пользователь"
                               AND cust-role.cust-id    = STRING(person.person-id)
                               NO-LOCK NO-ERROR.
          IF AVAIL(cust-role) THEN 
          FIND FIRST m_user WHERE m_user._Userid = cust-role.surrogate no-lock no-error.
          IF AVAIL(m_user) THEN vResult = GetXAttrValueEx("_user", m_user._userid, "Должность", "").
         END.
         WHEN "НомерДокумента"    OR
         WHEN "Document2Num_Doc"  THEN
            vResult = GetXAttrValueEx("person",
                                      STRING(person.person-id),
                                      "Document2Num_Doc",
                                      "").
         WHEN "КемВыданДокумент"  OR
         WHEN "Document3Kem_Vid"  THEN
            vResult = GetXAttrValueEx("person",
                                      STRING(person.person-id),
                                      "Document3Kem_Vid",
                                      "").
         OTHERWISE
         DO:
            RUN Fill-SysMes IN h_tmess ("", "", "1",
                                        "Неизвестный реквизит физ. лица: " + vType).
            ASSIGN
            vResult = "".
         RETURN.
         END.
      END CASE. /* vType */

   RUN Pars-SetCharResult (IF {assigned vResult}
                           THEN vResult
                           ELSE "?").
   is-ok = YES.
END PROCEDURE. /* РеквПостПолуч */

/* Получение значений с созданного документа,
** как с текущего, так и созданного прендыдущими шаблонами.
** Примеры использования.
** op ("details")       - вернет назаначение платежа с документа созданного текущим шаблоном.
** op ("details", "1")  - вернет назаначение платежа с документа созданного первым шаблоном.
*/
PROCEDURE op:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнено */
   DEFINE VARIABLE vAttr   AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vTmpl   AS INT64     NO-UNDO.
   DEFINE VARIABLE vResult AS CHARACTER NO-UNDO.

   DEFINE BUFFER xwop FOR xwop.
   DEFINE BUFFER xop  FOR op.
            
   IF NOT (   Pars-ValidParam(1)
           OR Pars-ValidParam(2))
   THEN RETURN.

   CASE pn:
      WHEN 0 THEN
         vAttr = Pars-GetString(0).
      WHEN 1 THEN
         ASSIGN
            vAttr = Pars-GetString(0)
            vTmpl = INT64 (Pars-GetString(1))
         .
   END CASE.
   IF LENGTH (vAttr) GT 0 THEN
   DO:
      IF vTmpl GT 0
         THEN FIND FIRST xwop WHERE xwop.op-templ EQ vTmpl NO-LOCK NO-ERROR.
         ELSE FIND FIRST xwop NO-LOCK NO-ERROR.

      IF AVAIL xwop THEN
      DO:
         FIND FIRST xop WHERE
            RECID (xop) EQ xwop.op-recid
         NO-LOCK NO-ERROR.
         IF AVAIL xop THEN
         DO:
            vResult = BUFFER xop:BUFFER-FIELD(vAttr):BUFFER-VALUE NO-ERROR.
            RUN Pars-SetCharResult (IF vResult = ? THEN "" ELSE vResult).
            is-ok = YES.
         END.
      END.
   END.   
   RETURN.
END PROCEDURE.

PROCEDURE op-entry:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнено */
   DEFINE VARIABLE vAttr   AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vResult AS CHARACTER NO-UNDO.
   DEFINE BUFFER xop-entry FOR op-entry.

   IF Pars-ValidParam(1) THEN DO:

      vAttr = Pars-GetString(0).
      FIND FIRST xwop NO-LOCK NO-ERROR.
      IF AVAIL xwop THEN DO:
         FIND FIRST xop-entry WHERE RECID(xop-entry) = xwop.open-recid NO-LOCK NO-ERROR.
         IF AVAIL xop-entry THEN DO:
            vResult = BUFFER xop-entry:BUFFER-FIELD(vAttr):BUFFER-VALUE NO-ERROR.
            RUN Pars-SetCharResult (IF vResult = ? THEN "" ELSE vResult).
            is-ok = YES.
         END.
         ELSE DO:
            vResult = BUFFER xwop:BUFFER-FIELD(vAttr):BUFFER-VALUE NO-ERROR.
            IF NOT ERROR-STATUS:ERROR THEN DO:
               RUN Pars-SetCharResult (IF vResult = ? THEN "" ELSE vResult).
               is-ok = YES.
            END.
            ELSE
               is-ok = NO.
         END.
      END.

   END.

   RETURN.
END PROCEDURE.

PROCEDURE ДРop:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнено */
   DEFINE VARIABLE vAttr   AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vResult AS CHARACTER NO-UNDO.
   DEFINE BUFFER xop FOR op.

   IF Pars-ValidParam(1) THEN DO:

      vAttr = Pars-GetString(0).
      FIND FIRST xwop NO-LOCK NO-ERROR.
      IF AVAIL xwop THEN DO:
         FIND FIRST xop WHERE RECID(xop) = xwop.op-recid NO-LOCK NO-ERROR.
         IF AVAIL xop THEN DO:
            vResult = GetXAttrValueEx("op",STRING(xop.op),vAttr,"").
            RUN Pars-SetCharResult (vResult).
            is-ok = YES.
         END.
      END.

   END.

   RETURN.
END PROCEDURE.

PROCEDURE ДРop-entry:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнено */
   DEFINE VARIABLE vAttr   AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vResult AS CHARACTER NO-UNDO.
   DEFINE BUFFER xop-entry FOR op-entry.

   IF Pars-ValidParam(1) THEN DO:

      vAttr = Pars-GetString(0).
      FIND FIRST xwop NO-LOCK NO-ERROR.
      IF AVAIL xwop THEN DO:
         FIND FIRST xop-entry WHERE RECID(xop-entry) = xwop.open-recid NO-LOCK NO-ERROR.
         IF AVAIL xop-entry THEN DO:
            vResult = GetXAttrValueEx("op-entry",STRING(xop-entry.op) + "," + STRING(xop-entry.op-entry),vAttr,"").
            RUN Pars-SetCharResult (vResult).
            is-ok = YES.
         END.
      END.

   END.

   RETURN.
END PROCEDURE.

PROCEDURE ВалДок:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнено */

   DEFINE BUFFER yop FOR op.
   DEFINE BUFFER bfop-entry FOR op-entry.
   RUN Pars-SetResult(0).

   FIND FIRST xwop NO-LOCK NO-ERROR.
   IF AVAIL xwop THEN
   _find_op:
   DO:
      FIND FIRST bfop-entry WHERE RECID(bfop-entry) EQ xwop.op-recid NO-LOCK NO-ERROR.
      IF NOT AVAIL bfop-entry THEN
         FIND FIRST yop WHERE RECID(yop) = xwop.op-recid NO-LOCK NO-ERROR.
      ELSE 
         FIND FIRST yop WHERE yop.op EQ bfop-entry.op NO-LOCK NO-ERROR.
      IF AVAIL yop THEN DO:
         RUN Pars-SetResult(IF CAN-FIND(FIRST op-entry OF yop WHERE op-entry.currency NE "") THEN 1 ELSE 0).
      END.
      ELSE
         RUN Pars-SetResult(IF xwop.currency NE "" THEN 1 ELSE 0).
   END.

   is-ok = YES.

   RETURN.
END PROCEDURE.



PROCEDURE ПервыйМО:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнено */

   DEFINE BUFFER xop FOR op.
   DEFINE BUFFER yop FOR op.

   RUN Pars-SetCharResult ("""""").

   FIND FIRST xwop NO-LOCK NO-ERROR.
   IF AVAIL xwop THEN
   _find_op:
   DO:
      FIND FIRST yop WHERE RECID(yop) = xwop.op-recid NO-LOCK NO-ERROR.
      IF AVAIL yop THEN DO:
         FOR EACH xop WHERE xop.op-transaction = yop.op-transaction
                        AND ROWID(xop)        <> ROWID(yop)
         NO-LOCK:
            IF GetXAttrValueEx("op",
                               STRING(xop.op),
                               "ПрилДокум",
                               "") <> ""
            THEN DO:
               RUN Pars-SetCharResult (xop.doc-num).
               LEAVE _find_op.
            END.
         END.
      END.
   END.

   is-ok = YES.

   RETURN.
END PROCEDURE.

/* Возвращает значение реквизита объекта, как основного так и дополнительного.
Параметры: КЛАСС,ИДЕНТИФИКАТОР,КОД РЕКВИЗИТА,ЗНАЧЕНИЕ ПО УМОЛЧАНИЮ" */
PROCEDURE Реквизит:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнено */

   DEFINE VARIABLE vClass      AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vSurrogate  AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vCode       AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vDefault    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vInstance  AS HANDLE     NO-UNDO.
   DEFINE VARIABLE vHBuffer   AS HANDLE     NO-UNDO.
   DEFINE VARIABLE vXattrs    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vOk        AS LOGICAL    NO-UNDO.
   DEFINE VARIABLE vResult    AS CHARACTER   NO-UNDO.

    IF NOT (Pars-ValidParam(1) OR
            Pars-ValidParam(2) OR
            Pars-ValidParam(3) OR
            Pars-ValidParam(4))
    THEN RETURN.

   ASSIGN
      vClass     = Pars-GetString(0)
      vSurrogate = Pars-GetString(1)
      vCode      = Pars-GetString(2)
      vDefault   = IF pn > 2  THEN Pars-GetString(3) ELSE ""
   .
   RUN PrepareInstance("").
   RUN GetInstance(vClass,vSurrogate,OUTPUT vInstance,OUTPUT vOk).
   IF vOk <> YES THEN
      vResult = vDefault.
   ELSE DO:

      vResult = GetInstanceProp2(vInstance,vCode).
      IF vResult = "??_ERROR_!!" THEN
         vResult = vDefault.

      /* Commented BY KSV: Если реквизит является дополнительным, то значение ?
      **  обозначает, что он не найден для объекта, и функция вернет в этом
      ** случае значение по умолчанию */
      IF vResult = ? THEN
      DO:
         vHBuffer = vInstance:DEFAULT-BUFFER-HANDLE.
         vXattrs = ENTRY(2,vHBuffer:ADM-DATA,CHR(1)).
         IF CAN-DO(vXattrs,vCode) OR
            CAN-DO(vXattrs,GetMangledName(vCode)) THEN
            vResult = vDefault.
      END.
   END.

   RUN DelEmptyInstance(vInstance).

   RUN Pars-SetCharResult (IF vResult EQ ? THEN "" ELSE vResult).
   is-ok = YES.

END PROCEDURE.


/* Возвращает значение реквизита счета, как основного так и дополнительного.
Параметры: СЧЕТ,КОД РЕКВИЗИТА,ЗНАЧЕНИЕ ПО УМОЛЧАНИЮ */
PROCEDURE РеквСчета:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнено */

   DEFINE VARIABLE vAcct       AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vSurrogate  AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vCode       AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vDefault    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vInstance  AS HANDLE     NO-UNDO.
   DEFINE VARIABLE vHBuffer   AS HANDLE     NO-UNDO.
   DEFINE VARIABLE vXattrs    AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vOk        AS LOGICAL    NO-UNDO.
   DEFINE VARIABLE vResult    AS CHARACTER   NO-UNDO.

    IF NOT (Pars-ValidParam(1) OR
            Pars-ValidParam(2) OR
            Pars-ValidParam(3))
    THEN RETURN.

   ASSIGN
      vAcct      = Pars-GetString(0)
      vCode      = Pars-GetString(1)
      vDefault   = IF pn > 1  THEN Pars-GetString(2) ELSE ""
   .
   
   {find-act.i 
      &bact=acct 
      &acct=vAcct
   }
   IF NOT AVAIL acct THEN
      vResult = vDefault.
   ELSE DO:
      vSurrogate = acct.acct + "," + acct.currency.
      RUN PrepareInstance("").
      RUN GetInstance(acct.Class-Code,vSurrogate,OUTPUT vInstance,OUTPUT vOk).
      IF vOk <> YES THEN
         vResult = vDefault.
      ELSE DO:
         vResult = GetInstanceProp2(vInstance,vCode).
         IF vResult = "??_ERROR_!!" THEN
            vResult = vDefault.
    
         /* Если реквизит является дополнительным, то значение ? обозначает, что 
         ** он не найден для объекта, и функция вернет в этом случае значение по умолчанию */
         IF vResult = ? THEN
         DO:
            vHBuffer = vInstance:DEFAULT-BUFFER-HANDLE.
            vXattrs = ENTRY(2,vHBuffer:ADM-DATA,CHR(1)).
            IF CAN-DO(vXattrs,vCode) OR
               CAN-DO(vXattrs,GetMangledName(vCode)) THEN
               vResult = vDefault.
         END.
      END.
    
      RUN DelEmptyInstance(vInstance).
   END.
    
   RUN Pars-SetCharResult (IF vResult EQ ? THEN "" ELSE vResult).
   is-ok = YES.

END PROCEDURE.


   /* возвращает длинну строки */
PROCEDURE LENGTH:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO.

   DEFINE VARIABLE vString AS CHARACTER  NO-UNDO.
   IF NOT Pars-ValidParam(1) THEN
      RETURN.

   vString     = Pars-GetString(0).
   IF NOT {assigned vString} THEN
      is-ok = NO.
   ELSE DO:
      RUN Pars-SetCharResult(LENGTH(vString)).
      is-ok = YES.
   END.
END PROCEDURE.

   /* Возвращает символ строки */
PROCEDURE GETCHAR:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO.

   DEFINE VARIABLE vString  AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vCharPos AS INT64      NO-UNDO.

   IF NOT (Pars-ValidParam(1) OR
           Pars-ValidParam(2)) THEN
      RETURN.

   ASSIGN
      vString     = Pars-GetString(0)
      vCharPos       = INT64(Pars-GetString(1))
   .
   IF NOT {assigned vString} OR
     vCharPos <= 0           OR
     vCharPos > LENGTH(vString)
   THEN
      is-ok = NO.
   ELSE DO:
      RUN Pars-SetCharResult(SUBSTRING(vString,vCharPos,1)).
      is-ok = YES.
   END.
END PROCEDURE.

/* Возвращает номер внутреннего счета в случае если в качестве параметра стоит "номер";
              наименование внутреннего счета в случае если в качестве параметра стоит "наим"*/
PROCEDURE ВнСчет:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнено */

   DEFINE VARIABLE vType      AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vResult    AS CHARACTER   NO-UNDO.
   DEFINE BUFFER xop-entry FOR op-entry.
   DEFINE BUFFER xop FOR op.
   IF NOT Pars-ValidParam(1) THEN
      RETURN.
   vType = Pars-GetString(0).
   FIND FIRST xwop NO-LOCK NO-ERROR.
   IF AVAIL xwop THEN DO:
      FIND FIRST xop WHERE RECID(xop) = xwop.op-recid NO-LOCK NO-ERROR.
      IF AVAIL xop THEN DO:
         FOR EACH xop-entry OF xop NO-LOCK:
            {find-act.i
            &bact   = acct
            &acct   = xop-entry.acct-cr
            }
            IF AVAIL(acct) AND acct.cust-cat EQ "В" THEN DO:
               IF vType EQ "номер" THEN
                  vResult = vResult + acct.acct + "#".
               ELSE IF vType EQ "наим" THEN
                  vResult = vResult + acct.details + "#".
            END.
            {find-act.i
               &bact   = acct
               &acct   = xop-entry.acct-db
            }
            IF AVAIL(acct) AND acct.cust-cat EQ "В" THEN DO:
               IF vType EQ "номер" THEN
                  vResult = vResult + acct.acct + "#".
               ELSE IF vType EQ "наим" THEN
                  vResult = vResult + acct.details + "#".
            END.
         END.
      END.
   END.
   RUN Pars-SetCharResult (vResult).
   is-ok = YES.
   RETURN.
END PROCEDURE.

/*
**    Что делает: Производит рассчет комисии.
**    Синтаксис : КомТарифПлан(<база начисления>, 
                               <код комиссии>, 
                               <cчет>, 
                               <валюта>, 
                               <назначение договора>, 
                               <код тарифного плана>,
                               [<период>],
                               [<тип даты>],
                               [<вид результата>],
                               [<код отделения>])
                         
   <вид результата> : %= - возвращается либо фикс.сумма либо % * Сумма
                       = - возвращает комиссию в случае фикс. ставки иначе 0 
                       % - возвращает комиссию в случае % ставки иначе 0 
                     ТИП - возвращает тип комиссии % или =
                     СТВ - возвращает либо фикс сумму либо %              
                      
*/
PROCEDURE КомТарифПлан:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
                                
   IF NOT (Pars-ValidParam(6) OR
           Pars-ValidParam(7) OR
           Pars-ValidParam(8) OR
           Pars-ValidParam(9) OR
           Pars-ValidParam(10)
           )
      THEN RETURN.

   DEFINE VARIABLE vSumm     AS DECIMAL   NO-UNDO. /* База начисления. */
   DEFINE VARIABLE vCommName AS CHARACTER NO-UNDO. /* Код вида комиссии. */
   DEFINE VARIABLE vAcct     AS CHARACTER NO-UNDO. /* Счет. */
   DEFINE VARIABLE vCurrency AS CHARACTER NO-UNDO. /* Валюта. */
   DEFINE VARIABLE vContract AS CHARACTER NO-UNDO. /* Назначение договора */
   DEFINE VARIABLE vRatePlan AS CHARACTER NO-UNDO. /* Тарифный план */
   DEFINE VARIABLE vPeriod   AS INT64     NO-UNDO. /* период нахождения остатка */
   DEFINE VARIABLE vDate     AS DATE      NO-UNDO. /* дата, на которую рассчитывается коммиссия */
   DEFINE VARIABLE vResType  AS CHARACTER NO-UNDO. /* тип результата */
   DEFINE VARIABLE vBranchID AS CHARACTER NO-UNDO. /* код отделения */
   DEFINE VARIABLE vResult   AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE vD        AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE vS        AS CHARACTER NO-UNDO.

   DEF BUFFER op         FOR op.          /* Локализация буфера. */
   DEF BUFFER commission FOR commission.  /* Локализация буфера. */
   DEF BUFFER acct       FOR acct.        /* Локализация буфера. */
   DEF BUFFER loan-dbo   FOR loan.        /* Локализация буфера. */
   DEF BUFFER loan-cond  FOR loan-cond.

   DEFINE VARIABLE vKau AS CHARACTER   NO-UNDO.
   
   ASSIGN
      vSumm     = result_l[pj - pn]
      vCommName = Pars-GetString ( 1 )
      vAcct     = Pars-GetString ( 2 )
      vCurrency = Pars-GetStringFormatted ( 3 , "999" )
      vCurrency = (IF vCurrency EQ vNatCurrChar THEN "" ELSE vCurrency)
      vContract = Pars-GetString ( 4 )
      vRatePlan = Pars-GetString ( 5 )

      vPeriod   = (IF pn GE 6  THEN  Pars-GetDec(6)  ELSE 0)
      vDate     = (IF     pn GE 7
                      AND Pars-GetString(7) NE ?
                   THEN DATE(Pars-GetString(7)) 
                   ELSE in-op-date)
      vResType  = (IF pn GE 8
                   THEN Pars-GetString(8)
                   ELSE '%=')
      vBranchID = (IF pn GE 9  THEN  Pars-GetString(9)  ELSE "")
   .

   IF  {assigned vRatePlan} THEN DO:

      IF vRatePlan EQ "*" THEN DO:

         IF {assigned vAcct} THEN
             {find-act.i
                 &bact   = acct
                 &acct   = vAcct
                 &curr   = vCurrency}
         IF AVAILABLE acct THEN DO:
            IF vContract EQ "dbo" THEN DO:
               /* Договоры ДБО */
               FIND LAST loan-dbo WHERE
                         loan-dbo.cust-cat eq acct.cust-cat
                     AND loan-dbo.cust-id eq acct.cust-id
                     AND loan-dbo.contract eq vContract
                     AND loan-dbo.filial-id eq acct.filial-id
                     AND loan-dbo.close-date eq ?
                  NO-LOCK NO-ERROR.
               IF AVAIL loan-dbo THEN
                  RUN RE_L_COND IN h_loan  (loan-dbo.contract,
                                            loan-dbo.cont-code,
                                            vDate,
                                            BUFFER loan-cond).
            END.
            ELSE DO:
               /* Договоры РКО */
               FOR EACH loan-acct WHERE
                   loan-acct.acct     EQ acct.acct     AND
                   loan-acct.currency EQ acct.currency AND
                   loan-acct.contract EQ vContract
               NO-LOCK,
               FIRST loan WHERE
                   loan.contract   EQ loan-acct.contract  AND
                   loan.cont-code  EQ loan-acct.cont-code AND
                   loan.open-date  LE gend-date           AND
                  (loan.close-date EQ ?                   OR
                   loan.close-date GT gend-date)
               NO-LOCK
               BY loan.open-date DESCENDING:
                   LEAVE.
               END.
               IF AVAILABLE loan THEN
                   RUN RE_L_COND IN h_loan (loan.contract,
                                            loan.cont-code,
                                            vDate,
                                            BUFFER loan-cond).
            END.
         END.
         IF AVAIL(loan-cond) THEN 
            vKau =  GetXAttrValue("loan-cond",                                                                           
                                  loan-cond.contract + "," + loan-cond.cont-code + "," + STRING(loan-cond.since),        
                                  "ТарифПлан").
            IF {assigned vKau} THEN
               vKau = "ТарифыРКО," + vKau.

      END.
      ELSE vKau = "ТарифыРКО," + vRatePlan.

   END.

   /* получение описания комиссии (pp-comm, comm.pro) */
   RUN GetCommDesc IN h_comm (vCommName, vAcct, vCurrency, vSumm, vKau, vPeriod, vDate, shFilial, vBranchID, BUFFER comm-rate) NO-ERROR.
   IF ERROR-STATUS:ERROR THEN DO:
      RUN Fill-SysMes IN h_tmess ("", "", "-1", RETURN-VALUE).
      RETURN.
   END.
   IF NOT AVAIL comm-rate THEN 
      RUN GetCommDesc IN h_comm (vCommName, vAcct, vCurrency, vSumm, "", vPeriod, vDate, shFilial, vBranchID, BUFFER comm-rate) NO-ERROR.
   
   CASE vResType:
      WHEN "%="  THEN
         vResult = IF AVAILABLE comm-rate THEN
                       (IF comm-rate.rate-fixed THEN
                            comm-rate.rate-comm
                        ELSE
                            comm-rate.rate-comm * vSumm / 100)
                   ELSE
                       0.
      WHEN "="   THEN 
         vResult = IF AVAILABLE comm-rate THEN
                       (IF comm-rate.rate-fixed THEN
                            comm-rate.rate-comm
                        ELSE
                            0)
                   ELSE
                       0.
      WHEN "%"   THEN
         vResult = IF AVAILABLE comm-rate THEN
                       (IF comm-rate.rate-fixed THEN
                            0
                        ELSE
                            comm-rate.rate-comm * vSumm / 100)
                   ELSE
                       0.
      WHEN "ТИП" THEN
         RUN Pars-SetCHARResult(IF AVAILABLE comm-rate
                                THEN (IF comm-rate.rate-fixed
                                      THEN  "="
                                      ELSE "%"
                                     )
                                ELSE "%="
                                ).
      WHEN "СТВ"  THEN
         vResult = IF AVAILABLE comm-rate THEN
                       comm-rate.rate-comm
                   ELSE
                       0.
   END CASE.

   IF vResType <> "ТИП" THEN DO:
       IF AVAILABLE comm-rate THEN DO:
           vS = GetXAttrValueEx("comm-rate",
                                STRING(comm-rate.comm-rate-id),
                                "МинЗнач",
                                "").
           IF {assigned vS} THEN DO:
               vD = DECIMAL(vS) NO-ERROR.
               IF NOT (vD = ? OR ERROR-STATUS:ERROR) THEN
                   vResult = MAXIMUM(vResult, vD).
           END.
           vS = GetXAttrValueEx("comm-rate",
                                STRING(comm-rate.comm-rate-id),
                                "МаксЗнач",
                                "").
           IF {assigned vS} THEN DO:
               vD = DECIMAL(vS) NO-ERROR.
               IF NOT (vD = ? OR ERROR-STATUS:ERROR) THEN
                   vResult = MINIMUM(vResult, vD).
           END.
       END.
       RUN Pars-SetResult(vResult).
   END.

   is-ok = TRUE.
   RETURN.

END PROCEDURE.

PROCEDURE СчетПолуч:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE param-id-optempl AS INT64   NO-UNDO.
   DEFINE VARIABLE param-format     AS CHARACTER NO-UNDO.
   DEFINE VARIABLE mChResult        AS CHARACTER NO-UNDO.
   DEFINE VARIABLE v-str            AS CHARACTER NO-UNDO.

   IF NOT (   Pars-ValidParam(0)
           OR Pars-ValidParam(1)
           OR Pars-ValidParam(2)
          )
   THEN RETURN.

   FIND FIRST wop WHERE
        RECID(wop) EQ rid NO-LOCK NO-ERROR.

   param-id-optempl = IF pn < 0
                      THEN (IF AVAIL wop
                            THEN wop.op-templ
                            ELSE ?)
                      ELSE Pars-GetInt(pn).

   RUN internal-parser-getdetails-form-ttable (param-id-optempl,
                                               "",
                                               "ben-acct",
                                               OUTPUT v-str).

   IF v-str EQ ? THEN
      RUN ElseTryGetFieldFraMeVal("ben-acct", OUTPUT v-str).

   IF AVAIL wop THEN
      /* Поиск документа. */
      FIND FIRST op WHERE
           RECID(op) EQ wop.op-recid NO-LOCK NO-ERROR.

   IF     NOT {assigned v-str}
      AND AVAIL op THEN
      v-str = STRING(op.doc-date).

   RUN Pars-SetCHARResult (IF v-str NE ?
                              THEN STRING(v-str)
                              ELSE "").

    is-ok = TRUE.
END PROCEDURE.

PROCEDURE Содержание:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE param-id-optempl AS INT64   NO-UNDO.
   DEFINE VARIABLE param-format     AS CHARACTER NO-UNDO.
   DEFINE VARIABLE mChResult        AS CHARACTER NO-UNDO.
   DEFINE VARIABLE v-str            AS CHARACTER NO-UNDO.

   IF NOT (   Pars-ValidParam(0)
           OR Pars-ValidParam(1)
           OR Pars-ValidParam(2)
          )
   THEN RETURN.

   FIND FIRST wop WHERE
        RECID(wop) EQ rid NO-LOCK NO-ERROR.

   param-id-optempl = IF pn < 0
                      THEN (IF AVAIL wop
                            THEN wop.op-templ
                            ELSE ?)
                      ELSE Pars-GetInt(pn).

   RUN internal-parser-getdetails-form-ttable (param-id-optempl,
                                               "",
                                               "details",
                                               OUTPUT v-str).

   IF v-str EQ ? THEN
      RUN ElseTryGetFieldFraMeVal("details", OUTPUT v-str).

   IF AVAIL wop THEN
      /* Поиск документа. */
      FIND FIRST op WHERE
           RECID(op) EQ wop.op-recid NO-LOCK NO-ERROR.

   IF     NOT {assigned v-str}
      AND AVAIL op THEN
      v-str = STRING(op.doc-date).

   RUN Pars-SetCHARResult (IF v-str NE ?
                              THEN STRING(v-str)
                              ELSE "").

    is-ok = TRUE.
END PROCEDURE.

PROCEDURE Очередность:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */

   DEFINE VARIABLE param-id-optempl AS INT64   NO-UNDO.
   DEFINE VARIABLE param-format     AS CHARACTER NO-UNDO.
   DEFINE VARIABLE mChResult        AS CHARACTER NO-UNDO.
   DEFINE VARIABLE v-str            AS CHARACTER NO-UNDO.

   IF NOT (   Pars-ValidParam(0)
           OR Pars-ValidParam(1)
           OR Pars-ValidParam(2)
          )
   THEN RETURN.

   FIND FIRST wop WHERE
        RECID(wop) EQ rid NO-LOCK NO-ERROR.

   param-id-optempl = IF pn < 0
                      THEN (IF AVAIL wop
                            THEN wop.op-templ
                            ELSE ?)
                      ELSE Pars-GetInt(pn).

   RUN internal-parser-getdetails-form-ttable (param-id-optempl,
                                               "",
                                               "order-pay",
                                               OUTPUT v-str).

   IF v-str EQ ? THEN
      RUN ElseTryGetFieldFraMeVal("order-pay", OUTPUT v-str).

   IF AVAIL wop THEN
      /* Поиск документа. */
      FIND FIRST op WHERE
           RECID(op) EQ wop.op-recid NO-LOCK NO-ERROR.

   IF     NOT {assigned v-str}
      AND AVAIL op THEN
      v-str = STRING(op.doc-date).

   RUN Pars-SetCHARResult (IF v-str NE ?
                              THEN STRING(v-str)
                              ELSE "").

    is-ok = TRUE.
END PROCEDURE.



 /*
** Для МБанка.
** Производит расчет суммы остатока по счету с учетом комиссии на картотеке.
** Т.е. из остатка по счету выичитает все комиссии на картотеке.
**
** Синтаксис.
**
** ОстСумКом ("<Счет Р/С клиента>", "<Код ДР на счете 70601*>=<Значение ДР на счетет>")
**
** Пример использования.
**
** ОстСумКом (Фильтр(), "Комисс=Прдоксч")
*/
PROCEDURE ОстСумКом.

   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнено */

   DEF VAR vAcct     AS CHAR  NO-UNDO. /* Р/С клиента. */
   DEF VAR vSgnsVl   AS CHAR  NO-UNDO. /* Код и значение ДР. */
   DEF VAR vAcctK    AS CHAR  NO-UNDO. /* Счет картотеки 2. */
   DEF VAR vRealPos  AS DEC   NO-UNDO. /* Остаток на счетет с учетом К2. */
   DEF VAR vPosK     AS DEC   NO-UNDO. /* Остаток на картотеке. */

   DEF BUFFER acct   FOR acct.
   DEF BUFFER acctK  FOR acct.
                        /* Проверка на число входных параметров. */
   IF Pars-ValidParam (2) THEN
   DO:
      ASSIGN
         vAcct    =  Pars-GetString(0)
         vSgnsVl  =  Pars-GetString(1)
         is-ok    =  YES
      .
                        /* Поиск счета ЛС. */
      FOR FIRST acct WHERE
         acct.acct BEGINS vAcct
      NO-LOCK:
                        /* Определение остатка на счете. */
         RUN acct-pos IN h_base (
            acct.acct,
            acct.currency,
            in-op-date,
            in-op-date,
            "П"
         ).
         ASSIGN
                        /* Остаток по счету. */
            vRealPos = ABS (IF acct.currency EQ "" THEN sh-bal ELSE sh-val)
                        /* Поиск картотечного счета К1. */
            vAcctK = GetXAttrValue ("acct", acct.acct + "," + acct.currency, "КартБВнСчет")
         .
         IF vAcctK EQ "" THEN
         FOR FIRST acctK WHERE
                  acctK.bal-acct   EQ 90901
            AND   acctK.cust-cat   EQ acct.cust-cat
            AND   acctK.cust-id    EQ acct.cust-id
         NO-LOCK:
            vAcctK = acctK.acct + "," + acctK.currency.
         END.
                        /* Определение суммы документов комиссий на К1. */
         IF LENGTH (vAcctK) GT 0 THEN
            RUN GetCardPosMseb (acct.acct + "," + acct.currency, vAcctK, vSgnsVl, INPUT-OUTPUT vRealPos).
                        /* Если остаток более нуля, то продолжаем счет. */
         IF vRealPos GT 0 THEN
         DO:
                        /* Поиск картотечного счета К2. */
            vAcctK = GetXAttrValue ("acct", acct.acct + "," + acct.currency, "Карт2ВнСчет").
            IF vAcctK EQ "" THEN
            FOR FIRST acctK WHERE
                     acctK.bal-acct   EQ 90902
               AND   acctK.cust-cat   EQ acct.cust-cat
               AND   acctK.cust-id    EQ acct.cust-id
            NO-LOCK:
               vAcctK = acctK.acct + "," + acctK.currency.
            END.
                        /* Определение суммы документов комиссий на К2. */
            IF LENGTH (vAcctK) GT 0 THEN
               RUN GetCardPosMseb (acct.acct + "," + acct.currency, vAcctK, vSgnsVl, INPUT-OUTPUT vRealPos).
         END.
      END.
                        /* Установка значения. */
      RUN Pars-SetResult (vRealPos).
   END.
   RETURN.
END PROCEDURE.

/* Получаем остаток по К2 или К1 по поределенному виду операции. */
PROCEDURE GetCardPosMseb.

   DEF INPUT         PARAM  iAcct       AS CHAR  NO-UNDO. /* Балансовый счет. */
   DEF INPUT         PARAM  iAcctCard   AS CHAR  NO-UNDO. /* Счет картотеки. */
   DEF INPUT         PARAM  iSgnsVl     AS CHAR  NO-UNDO. /* Формат значения "<Код ДР счета>=<значение ДР счета>". */
   DEF INPUT-OUTPUT  PARAM  oRealPos    AS DEC   NO-UNDO. /* Значение по картотеке. */
   
   DEF BUFFER kau       FOR kau.       /* Локализация буфера. */
   DEF BUFFER signs     FOR signs.     /* Локализация буфера. */
   DEF BUFFER op        FOR op.        /* Локализация буфера. */
   DEF BUFFER op-entry  FOR op-entry.  /* Локализация буфера. */
   DEF BUFFER bOp       FOR op.        /* Локализация буфера. */
   DEF BUFFER bOpEntry  FOR op-entry.  /* Локализация буфера. */
   DEF BUFFER bAcctCr   FOR acct.      /* Локализация буфера. */
   DEF BUFFER bSigns    FOR signs.     /* Локализация буфера. */

                        /* Перебираем несписанные картотечные документы. */
   ClcK2:
   FOR EACH kau WHERE
            kau.acct       EQ ENTRY (1, iAcctCard)
      AND   kau.currency   EQ ENTRY (2, iAcctCard)
      AND   NOT kau.zero-bal
   NO-LOCK,
   FIRST signs WHERE
            signs.file-name   EQ "op"
      AND   signs.surrogate   EQ ENTRY (1, kau.kau)
      AND   signs.code        EQ "op-bal"
   NO-LOCK,
                        /* Находим документ постановки на кртотеку. */
   FIRST op WHERE
      op.op EQ INT64(signs.code-value)
   NO-LOCK,
   FIRST op-entry OF op WHERE
      op-entry.acct-db  EQ ENTRY (1, iAcct)
   NO-LOCK,
                        /* Находим документ отнесения в доходы банка "70601*". */
   EACH bOp WHERE
            bOp.op-transaction   EQ op.op-transaction
   NO-LOCK,
   FIRST bOpEntry OF bOp WHERE 
      bOpEntry.acct-db  EQ op-entry.acct-cr
   NO-LOCK,
                        /* На счете кредита "70601*" находим ДР и проверяем значение. */
   FIRST bAcctCr WHERE
            bAcctCr.acct      EQ       bOpEntry.acct-cr
      AND   bOpEntry.currency BEGINS   bAcctCr.currency
   NO-LOCK,
   FIRST bSigns WHERE
            bSigns.file-name                          EQ "acct"
      AND   bSigns.surrogate                          EQ bAcctCr.acct + "," + bAcctCr.currency
      AND   bSigns.code                               EQ ENTRY (1, iSgnsVl, "=")
      AND  (bSigns.code-value + bSigns.xattr-value)   EQ ENTRY (2, iSgnsVl, "=")
   NO-LOCK:
      oRealPos = oRealPos - ABS (IF ENTRY (2, iAcct) EQ ""
                                    THEN bOpEntry.amt-rub
                                    ELSE bOpEntry.amt-cur).
      IF oRealPos LE 0 THEN
      DO:
         oRealPos = 0.
         LEAVE ClcK2.
      END.
   END.
   RETURN.
END PROCEDURE.

/* Возвращает сумму всех кредитовых оборотов на заданную дату всех течений.
** по ссудному счету роль "Кредит"  или счету с ролью указанной во втором параметре 
** Из суммы оборотов исключаются движения, у которых по дебету указана маски счетов.
**
** Если роль счета не передана,то:
**
** Если маска счета дебета не указана, то маска по умоляанию принимает следующий вид.
**
** "!458*,!47427*,!<счет 1-го порядка ссудного счета>*,*"
**
**  Если указана, то маска принимает следующий вид.
** "!<счет 1-го порядка ссудного счета>*,<заданная маска>"
**
** В сумму оборотов включаются все движения от статуса "П".
**
** Если роль счета передана то маски для исключения по умолчанию нет!
**
*******************************************************************************
** Параметры функции.
** ДбОбТеч (<маски счетов для исключения>,[РольСчета])
** 
** Пример использования.
** ДбОбТеч ()
** ДбОбТеч ("!458*,!47427*,*")
** ДбОбТеч ("",Кред)
*/
PROCEDURE ДбОбТеч.
   DEF OUTPUT PARAM is-ok AS LOG NO-UNDO INIT YES. /* успешно ли выполнено */

   DEF VAR vContract       AS CHAR  NO-UNDO. /* Назначение договора. */
   DEF VAR vContCode       AS CHAR  NO-UNDO. /* Номер договора. */
   DEF VAR vEcptMskDbUsr   AS CHAR  NO-UNDO. /* Маски счетов дебета, обороты по которым не включаются. */
   DEF VAR vAcctType       AS CHAR  NO-UNDO. /* Роль счета */
   DEF VAR vDate           AS DATE  NO-UNDO. /* Дата, на которую получаем обороты. */
   DEF VAR vNew            AS LOG   NO-UNDO. /* Новый синтаксис с ролью */

   DEF VAR vTotalCr     AS DEC      NO-UNDO. /* Сумма кредитовых оборотов. */
   DEF VAR vAcctLst     AS CHAR     NO-UNDO. /* Список обработанных счетов. */
   DEF VAR vEcptMskDb   AS CHAR     NO-UNDO. /* Маски счетов дебета, обороты по которым не включаются */
   DEF VAR h_templ      AS HANDLE   NO-UNDO. /* Для определения номера договора. */


   DEF BUFFER loan      FOR loan.      /* Локализация буфера. */
   DEF BUFFER loan-acct FOR loan-acct. /* Локализация буфера. */
   DEF BUFFER op-entry  FOR op-entry.  /* Локализация буфера. */

                        /* Определение номер договора. */
   RUN LOAN_VALID_HANDLE (INPUT-OUTPUT h_templ).

   ASSIGN
      vContract      =  ENTRY (1, h_templ:PRIVATE-DATA)
      vContCode      =  ENTRY (2, h_templ:PRIVATE-DATA)
      vDate          =  in-op-date   
      vAcctType      =  vContract
   NO-ERROR.

                        /* Проверяем наличие параметра. */
   IF pn GE 1 THEN
   DO:
      pn = pn - 1.
      vEcptMskDbUsr  =  Pars-GetString(0).
                        /* Перебираем все течение договора.
                        ** И формируем список счетов по роли "кредит"
                        ** (счета могут быть одинаковы для разных течений). */
      IF pn GE 1 THEN
         ASSIGN
            vAcctType = Pars-GetString(1)
            vNew      = Yes
         .

   END.

   
   FOR EACH loan WHERE
            loan.contract                       EQ       vContract
      AND   loan.cont-code                      BEGINS   vContCode + " "
      AND   NUM-ENTRIES (loan.cont-code, " ")   GT       1
   NO-LOCK,
   LAST loan-acct OF loan  WHERE
            loan-acct.acct-type  EQ vAcctType
      AND   loan-acct.since      LE vDate
   NO-LOCK:
                        /* Если счет не участвовал в обработке,
                        ** то определяем сумму кредитовых оборотов. */
      IF NOT CAN-DO (loan-acct.acct, vAcctLst) THEN
      DO:
         {additem.i  vAcctLst loan-acct.acct}
                        /* Если пользователь указал свою маску, то ее и подставляем
                        ** Если нет, то заменяем константой. */
         IF vNEW THEN
            vEcptMskDb  =  IF vEcptMskDbUsr = "" THEN "*" ELSE vEcptMskDbUsr + "*,*".
         ELSE 
         vEcptMskDb  =  IF LENGTH (vEcptMskDbUsr)  GT 0
                           THEN "!" + SUBSTRING (loan-acct.acct, 1, 3) + "*," + vEcptMskDbUsr
                           ELSE "!458*,!47427*,!" + SUBSTRING (loan-acct.acct, 1, 3) + "*,*".
                        /* Берем все кредитовые обороты
                        ** на заданную дату от статуса "П". */
         FOR EACH op-entry WHERE
                  op-entry.acct-cr     EQ loan-acct.acct
            AND   op-entry.op-date     EQ vDate
            AND   op-entry.op-status   GE "П"
            AND   op-entry.currency    EQ loan-acct.currency
            AND   CAN-DO (vEcptMskDb, op-entry.acct-db)
         NO-LOCK:
                        /* Итоговая сумма в валюте счета. */
            vTotalCr =  vTotalCr +  IF loan-acct.currency EQ ""
                                       THEN op-entry.amt-rub
                                       ELSE op-entry.amt-cur.
         END.
      END.
   END.
                        /* Возвращаем значение. */
   RUN Pars-SetResult (vTotalCr).
END PROCEDURE.

/*--------------------------------------------------------------------------
    * Что делает: Возвращает значение переменной транзакции
    * Синтаксис : Перем(<код переменной>[,<код транзакции>,<номер шаблона>])
  --------------------------------------------------------------------------*/

PROCEDURE Перем:
   DEFINE OUTPUT PARAMETER is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнено */

   DEFINE VARIABLE vOpKind  AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vTempl   AS INT64     NO-UNDO.
   DEFINE VARIABLE vCodeVar AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vValVar  AS CHARACTER NO-UNDO.

   IF NOT (Pars-ValidParam(1) OR
           Pars-ValidParam(2) OR
           Pars-ValidParam(3)) THEN
      RETURN.

   ASSIGN
      vCodeVar = Pars-GetString(0)
      vOpKind  = IF    pn EQ 2 
                    OR pn EQ 3 
                 THEN Pars-GetString(1) 
                 ELSE ""
      vTempl   = IF    pn EQ 2 
                    OR pn EQ 3 
                 THEN Pars-GetInt(2)    
                 ELSE 0
      vValVar  = GetAttrValue2(vOpKind,vTempl,vCodeVar)
      .
   
   RUN Pars-SetCharResult (vValVar).         
   is-ok = YES. 
END PROCEDURE.
&ENDIF


/* Процедура сравнения строк. */
PROCEDURE CmpStr:
   DEF OUTPUT PARAM is-ok AS LOGICAL NO-UNDO. /* успешно ли выполнена ? */
    
   IF NOT pars-validparam(2)
      THEN RETURN.

   IF Pars-GetString(0) EQ Pars-GetString(1)
   THEN ASSIGN
      mvar[pj - pn]     =  "1"
      result_l[pj - pn] =  1
   .
   ELSE ASSIGN
      mvar[pj - pn]     =  "0"
      result_l[pj - pn] =  0
   .
   is-ok =  YES.
   RETURN.
END PROCEDURE. 

/*--------------------------------------------------------------------------
    * Что делает: Возвращает значение реквизита на обрабатываемом договоре.
    * Синтаксис : ДогДр(<код реквизита>)
    * Пример    : ДогДр("ПродКод")
  --------------------------------------------------------------------------*/
PROCEDURE ДогДр:
   DEF OUTPUT PARAM  is-ok AS LOGICAL   NO-UNDO. /* успешно ли выполнена ? */
   
   DEF VAR vXattr    AS CHAR   NO-UNDO.
   DEF VAR vContract AS CHAR   NO-UNDO.
   DEF VAR vContCode AS CHAR   NO-UNDO.
   DEF VAR vH        AS HANDLE NO-UNDO.
   
   DEF BUFFER loan  FOR loan.
   DEF BUFFER xattr FOR xattr.
   
   BLCK:
   DO
   ON ERROR UNDO BLCK, LEAVE BLCK:
      IF NOT (Pars-ValidParam(0) OR Pars-ValidParam(1)) THEN RETURN.
      
      vXattr   = Pars-GetString(0).
      /* Определение правильного применения функции,
         ** формат private-data */
      RUN LOAN_VALID_HANDLE IN THIS-PROCEDURE (INPUT-OUTPUT vH).
       
      ASSIGN
         pick-value = ""
         vContract = ENTRY(1,vH:PRIVATE-DATA)
         vContCode = ENTRY(2,vH:PRIVATE-DATA) NO-ERROR.
   
      IF NOT VALID-HANDLE(vH) THEN 
         IF ReFindLoan (OUTPUT vContract , OUTPUT vContCode ) = ? THEN 
            RETURN.
            
      FIND FIRST loan WHERE
                 loan.contract  EQ vContract
             AND loan.cont-code EQ vContCode 
      NO-LOCK NO-ERROR.
      IF NOT AVAIL loan THEN RETURN.
      
      RUN GetXattr IN h_xclass (loan.Class-Code, vXattr, BUFFER xattr).

      IF AVAIL xattr THEN
      DO:
         IF xattr.progress-field THEN
            pick-value = GetBufferValue("loan",
                                        "WHERE loan.contract EQ '" + loan.contract + "'
                                         AND loan.cont-code EQ '" + loan.cont-code + "'",
                                         STRING(vXattr)) NO-ERROR.
         ELSE
         DO:
            pick-value = GetXattrValue ("loan",
                                        loan.contract + ',' + loan.cont-code,
                                        vXattr
                                        ).
         END.
      END.

      RUN Pars-SetCharResult IN THIS-PROCEDURE (pick-value).

      is-ok = YES.
   END.
   
END PROCEDURE.

&IF  DEFINED(NEW_PARSER) = 0 OR
    (DEFINED(NEW_PARSER) > 0 AND DEFINED(PLOAN_LIB) > 0) &THEN


/*--------------------------------------------------------------------------
    * Что делает: Произвольный реквизит с клиента договора
                                                       
    * Синтаксис : РольСоглП(РЕКВИЗИТ)
    * Пример    : РеквизитКлиента('Субъект')
  --------------------------------------------------------------------------*/
PROCEDURE РеквизитКлиента:


   DEF OUTPUT PARAM  is-ok AS LOGICAL   NO-UNDO. /* успешно ли выполнена ? */

   DEF VAR in-contract  AS CHAR   NO-UNDO.
   DEF VAR in-cont-code AS CHAR   NO-UNDO.
   DEF VAR in-ContCode  AS CHAR   NO-UNDO.
   DEF VAR vAttr        AS CHAR   NO-UNDO.   

   DEF VAR vH           AS HANDLE NO-UNDO.
   DEF VAR vDate        AS DATE  NO-UNDO.
   DEF VAR vTable       AS CHAR  NO-UNDO. 

   DEF BUFFER xloan-acct FOR loan-acct .
   DEF BUFFER NewLA      FOR loan-acct. /* Для копирования привязки с охватывающего */

   /* Должно быть 1 или более параметров */
   IF pn LT 1 THEN RETURN.
   
   pn = pn - 1.
   
   ASSIGN
      vAttr = Pars-GetString(0)      


      &IF  DEFINED(PLOAN_LIB) > 0 &THEN
      vDate          =  wop.con-date         
      &else
      vDate          =  in-op-date     
      &Endif
      /* Почемуто не подхватывается ОД, для транзакций на основе sozschet */
      vDate = if vDate EQ ? then GetBaseOpDate() else vDate
      .

/* Определение правильного применения функции,
         ** формат private-data */
   RUN LOAN_VALID_HANDLE IN THIS-PROCEDURE (INPUT-OUTPUT vH).

   ASSIGN
         pick-value = ""
         in-contract = ENTRY(1,vH:PRIVATE-DATA)
         in-cont-code = ENTRY(2,vH:PRIVATE-DATA) 
   NO-ERROR.
   
   IF NOT VALID-HANDLE(vH) THEN 
      IF ReFindLoan (OUTPUT in-contract , OUTPUT in-cont-code ) = ? THEN 
         RETURN.
         
   FOR FIRST loan WHERE
             loan.contract EQ in-contract
         AND loan.cont-code EQ in-cont-code
   NO-LOCK:
     
     vTable = if (loan.cust-cat EQ "Ч") then "person" else
              if (loan.cust-cat EQ "Ю") then "cust-corp" else
              if (loan.cust-cat EQ "Б") then  "banks" else "person".
   
     pick-value = GetXAttrValueEx(vTable,STRING(loan.cust-id),vAttr,"").   
   END.

   &IF  DEFINED(PLOAN_LIB) > 0 &THEN
   pn = 1.
   pj = 2.            
   &else
   &Endif
   RUN Pars-SetCharResult (pick-value).
   
   is-ok = yes.
   
END PROCEDURE.

/*--------------------------------------------------------------------------
    * Что делает: Процедура поиска счета по Роли - используется для определения счета договора 
                  соглашения.
                  Роль  - роль счета в договоре транше или соглашении
                  Признак - копировать на транш от соглашения 
                  (не поставлен - не копировать, Любая строка - копировать (Да))                                     
    * Синтаксис : РольСоглП("<Роль>"[, <признак даты>])
    * Пример    : РольСоглП("Кредит", "Копировать")
  --------------------------------------------------------------------------*/
PROCEDURE РольСоглП:
   DEF OUTPUT PARAM  is-ok AS LOGICAL   NO-UNDO. /* успешно ли выполнена ? */

   DEF VAR in-contract  AS CHAR   NO-UNDO.
   DEF VAR in-cont-code AS CHAR   NO-UNDO.
   DEF VAR in-ContCode  AS CHAR   NO-UNDO.
   DEF VAR vFindRole    AS CHAR   NO-UNDO.
   DEF VAR vFlagOper    AS CHAR   NO-UNDO.
   DEF VAR vH           AS HANDLE NO-UNDO.
   DEF VAR vDate        AS DATE  NO-UNDO. 

   DEF BUFFER xloan-acct FOR loan-acct .
   DEF BUFFER NewLA      FOR loan-acct. /* Для копирования привязки с охватывающего */

   /* Должно быть 1 или более параметров */
   IF pn LT 1 THEN RETURN.
   
   ASSIGN
      vFindRole = Pars-GetString(1)
      vFlagOper = IF pn GT 1 THEN Pars-GetString(2)
                             ELSE "0"
      &IF  DEFINED(PLOAN_LIB) > 0 &THEN
      vDate          =  wop.con-date         
      &else
      vDate          =  in-op-date     
      &Endif
      /* Почемуто не подхватывается ОД, для транзакций на основе sozschet */
      vDate = if vDate EQ ? then GetBaseOpDate() else vDate
      .

/* Определение правильного применения функции,
         ** формат private-data */
   RUN LOAN_VALID_HANDLE IN THIS-PROCEDURE (INPUT-OUTPUT vH).

   ASSIGN
         pick-value = ""
         in-contract = ENTRY(1,vH:PRIVATE-DATA)
         in-cont-code = ENTRY(2,vH:PRIVATE-DATA) 
   NO-ERROR.
   
   IF NOT VALID-HANDLE(vH) THEN 
      IF ReFindLoan (OUTPUT in-contract , OUTPUT in-cont-code ) = ? THEN 
         RETURN.
         
   FIND LAST xloan-acct WHERE xloan-acct.contract  EQ in-contract
                          AND xloan-acct.cont-code EQ in-cont-code
                          AND xloan-acct.acct-type EQ vFindRole
                          AND xloan-acct.since     LE vDate NO-LOCK NO-ERROR.

   IF NOT AVAIL xloan-acct THEN
   DO: 
   
      /* Если подан транш, то ищем счёт на охвате */
      IF NUM-ENTRIES(in-cont-code, " ") EQ 2 THEN
      DO:
         /* то ищем на охватывающем */
         in-ContCode = ENTRY(1, in-cont-code ," ").
         
         FIND LAST xloan-acct WHERE xloan-acct.contract  EQ in-contract
                                AND xloan-acct.cont-code EQ in-ContCode
                                AND xloan-acct.acct-type EQ vFindRole
                                AND xloan-acct.since     LE vDate NO-LOCK NO-ERROR.
      END.
      ELSE
         in-ContCode = in-cont-code.
   
      
      IF NOT AVAIL xloan-acct THEN
      DO:
      
         RUN  createbill.p(in-ContCode,in-contract,vDate,vFindRole,LOGICAL(FGetSetting("ViewAcctLog", ?, "NO"))).
         IF {assigned pick-value} THEN
         FIND LAST xloan-acct WHERE xloan-acct.contract  EQ in-contract
                                AND xloan-acct.cont-code EQ in-ContCode
                                AND xloan-acct.acct-type EQ vFindRole
                                AND xloan-acct.since     LE vDate NO-LOCK NO-ERROR.
      END.
      ELSE
         pick-value = xloan-acct.acct.

      IF     AVAIL xloan-acct
         AND vFlagOper NE "0" THEN /* копируем привязку на транш */
      DO:
         CREATE NewLA.
         BUFFER-COPY xloan-acct EXCEPT cont-code since TO NewLA
            ASSIGN
               NewLA.cont-code = in-cont-code
               NewLA.since     = vDate
         NO-ERROR.
         IF ERROR-STATUS:ERROR THEN
            RUN Fill-SysMes IN h_tmess ("", "-1", "", ERROR-STATUS:GET-MESSAGE (1)).
      END.
      ELSE
         IF NOT AVAIL xloan-acct THEN 
            RUN Fill-Sysmes IN h_tmess (
               "", 
               "", 
               "0", 
               "Не открылся счет с ролью " + vFindRole + "~n( " + in-ContCode + " ) !").
   END.
   ELSE
      pick-value = xloan-acct.acct.
      
   pn = 1.
   pj = 2.
   
   RUN Pars-SetACCTResult (pick-value).
   
   is-ok = yes.
   
END PROCEDURE.
&Endif

/*--------------------------------------------------------------------------
    * Что делает: Возвращает резидентность клиента по счету
    * Синтаксис : РезидентПоСчету(<счет>)
    * Пример    : РезидентПоСчету("4081781010000000001")
  --------------------------------------------------------------------------*/
PROCEDURE РезидентПоСчету:
   DEF OUTPUT PARAM  is-ok AS LOGICAL   NO-UNDO. /* успешно ли выполнена ? */
   
   DEF VAR vAcctNumber AS CHAR   NO-UNDO.
   DEF VAR vSCountry   AS CHAR   NO-UNDO.
   DEF VAR vCliCountry AS CHAR   NO-UNDO.
   
   IF NOT Pars-ValidParam(1) THEN RETURN.
   is-ok = YES.
   ASSIGN
      pick-value = ""
      vAcctNumber = Pars-GetString(0)
      /* определяем код страны резиденства */
      vSCountry = FGetSetting("КодРез",?,"RUS").

   IF NOT {assigned vAcctNumber} THEN RETURN.
   {find-act.i
       &bact   = acct
       &acct   = vAcctNumber
   }
   IF NOT AVAIL acct THEN RETURN.

   /* клиент */
    IF LOOKUP(acct.cust-cat,"Ю,Б,Ч") > 0 THEN DO:
      vCliCountry = getValueAttr(getCustClass(acct.cust-cat),
                                 STRING(acct.cust-id),
                                 "country-id") NO-ERROR.
      IF {assigned vCliCountry} THEN
         pick-value = IF vCliCountry EQ vSCountry THEN "Да" ELSE "Нет".
    END.

   RUN Pars-SetCharResult (pick-value).
END PROCEDURE.

/*--------------------------------------------------------------------------
    * Что делает: Возвращает вид клиента по счету
    * Синтаксис : ВидКлиентаПоСчету(<счет>)
    * Пример    : ВидКлиентаПоСчету("4081781010000000001")
  --------------------------------------------------------------------------*/
PROCEDURE ВидКлиентаПоСчету:
   DEF OUTPUT PARAM  is-ok AS LOGICAL   NO-UNDO. /* успешно ли выполнена ? */
   
   DEF VAR vAcctNumber AS CHAR   NO-UNDO.
   DEF VAR vCatOnAcct  AS CHAR   NO-UNDO.
   DEF VAR vMask       AS CHAR   NO-UNDO.
   DEF VAR vI          AS INT64  NO-UNDO.
   DEF VAR vResult     AS CHAR   NO-UNDO.
   
   IF NOT Pars-ValidParam(1) THEN RETURN.
   is-ok = YES.
   ASSIGN
      pick-value = ""
      vAcctNumber = Pars-GetString(0)
      vCatOnAcct  = FGetSetting("СтандТр","CatOnAcct","").

   IF NOT {assigned vAcctNumber} THEN RETURN.
   FIND FIRST acct WHERE
              acct.number EQ vAcctNumber
   NO-LOCK NO-ERROR.
   IF NOT AVAIL acct THEN RETURN.

   DO vI = 1 TO NUM-ENTRIES(vCatOnAcct,";"):
       vMask = GetEntries(2,ENTRY(vI,vCatOnAcct,";"),":","").
       IF CAN-DO(vMask,STRING(acct.bal-acct)) THEN 
         vResult = GetEntries(1,ENTRY(vI,vCatOnAcct,";"),":","").
   END.

   IF {assigned vResult} THEN
     RUN Pars-SetCHARResult (vResult).
   ELSE
     RUN Pars-SetCHARResult (acct.cust-cat).

END PROCEDURE.


/*--------------------------------------------------------------------------
    * Что делает: Сохраняет параметр 
    * Синтаксис : SaveOpParam(<имя_параметра>,<значение>,<тип>(integer,decimal,character))
                  (тип - необязательный параметр)
    * Пример    : SaveOpParam(a,1,integer)
                  SaveOpParam(b,"текст")
  --------------------------------------------------------------------------*/
PROCEDURE SaveOpParam:
   DEF OUTPUT PARAM  is-ok AS LOGICAL   NO-UNDO. /* успешно ли выполнена ? */
   DEF VAR vParamCode  AS CHAR NO-UNDO.
   DEF VAR vParamValue AS CHAR NO-UNDO.
   DEF VAR vParamType  AS CHAR NO-UNDO.
   DEF VAR vShowValue  AS LOG  NO-UNDO.
   PROCBLOCK:
   DO:
      IF pn < 2 OR pn > 4 THEN 
      DO:
         RUN Fill-SysMes IN h_tmess ("", "", "-1", "Некорректные входные параметры").
         LEAVE PROCBLOCK.
      END.
      IF NOT Pars-ValidParam(pn) THEN 
         LEAVE PROCBLOCK.
      IF pn = 1 THEN 
         vParamType = {&CharType}.
      ELSE DO:
         vParamType = Pars-GetString(2).
         IF NOT CAN-DO({&DataTypeList}, vParamType) THEN
         DO:
            RUN Fill-SysMes IN h_tmess ("", "", "-1", 
                SUBSTITUTE("Некорректное значение '&1', параметр должен быть из списка '&2'",
                           vParamType,
                           {&DataTypeList})).
            LEAVE PROCBLOCK.
         END.
         IF pn = 3 THEN
         DO:
            vShowValue = LOGICAL(Pars-GetString(3)) NO-ERROR.
            IF ERROR-STATUS:ERROR THEN
               LEAVE PROCBLOCK.
         END.
      END.

      ASSIGN
         pick-value  = ""
         vParamCode  = Pars-GetString(0)
         vParamValue = Pars-GetString(1)
         is-ok       = SaveOpKindParam(vParamCode,vParamValue,vParamType).
      RUN Pars-SetCHARResult (IF vShowValue THEN vParamValue ELSE " ").
   END. /* PROCBLOCK */
END PROCEDURE.


/*--------------------------------------------------------------------------
    * Что делает: Загружает параметр
    * Синтаксис : GetOpParam(<имя_параметра>)
    * Пример    : GetOpParam(a)
  --------------------------------------------------------------------------*/
PROCEDURE GetOpParam:
   DEF OUTPUT PARAM  is-ok AS LOGICAL   NO-UNDO. /* успешно ли выполнена ? */
   DEF VAR vParamCode  AS CHAR NO-UNDO.
   DEF VAR vParamType  AS CHAR NO-UNDO.
   DEF VAR vRetVal     AS CHAR NO-UNDO.

   PROCBLOCK:
   DO:
      IF NOT Pars-ValidParam(1) THEN 
         LEAVE PROCBLOCK.

      ASSIGN
         vParamCode = Pars-GetString(0)
         vRetVal    = GetOpKindParam(vParamCode) 
      NO-ERROR.
      IF ERROR-STATUS:ERROR THEN
         LEAVE PROCBLOCK.

      IF NUM-ENTRIES(vRetVal,CHR(1)) = 2 THEN
         ASSIGN
            vParamType = ENTRY(2,vRetVal,CHR(1))
            vRetVal    = ENTRY(1,vRetVal,CHR(1))
         .
      ELSE 
         vParamType = {&CharType}.

      CASE vParamType: 
         WHEN {&CharType} THEN 
         DO:
            IF NOT {assigned vRetVal} THEN vRetVal = " ".
            RUN Pars-SetCHARResult (vRetVal).
         END.
         WHEN {&IntType}  THEN RUN Pars-SetResult(vRetVal).
         WHEN {&DecType}  THEN RUN Pars-SetResult(vRetVal).
      END CASE.

      is-ok = YES.

   END. /* PROCBLOCK */
END PROCEDURE.
/* $LINTFILE='g-pfunc.def' */
/* $LINTMODE='1' */
/* $LINTENV ='common' */
/* $LINTVSS ='$/ws3-dpl/common/bq/' */
/* $LINTUSER='muta' */
/* $LINTDATE='08/08/2016 10:49:37.500+03:00' */
/*prosignN64GaLwWvBuoFPhzEM9xHg*/