{t-otch.i NEW}
{svarloan.def NEW}
{sh-defs.i}
{intrface.get loan}
{intrface.get i254}
{loan_par.def &new = new}
{omsk.pro}

{globals.i}
{intrface.get xclass}
{intrface.get lv}
{intrface.get refer}
{intrface.get date}
{intrface.get db2l}
{intrface.get pogcr}
{lshpr.pro}
{debug.equ}
{profile.def}




    {cust-adr.obj
          &def-vars     = YES
    }


DEFINE TEMP-TABLE ttLoans
    FIELD r-loan   AS ROWID
    FIELD need-export AS CHAR
    FIELD date-prev AS DATE
    FIELD date-rep AS DATE
    INDEX ttiloan IS UNIQUE r-loan
.

DEFINE TEMP-TABLE ttGuarant
    FIELD cont-code LIKE loan.cont-code
    FIELD cust-id LIKE person.person-id
    FIELD cust-cat AS CHAR
    FIELD loanUpd  AS DATE
    FIELD recStatus AS INT
    .
    
DEF VAR cCurrCol AS CHAR NO-UNDO.


/*----------------------------------------------------------------------------*/
/* Определяет дату возникновения неоплаченной просрочки ОД/процентов          */
/*----------------------------------------------------------------------------*/
PROCEDURE GetFirstDueDate_:
   DEF INPUT PARAM  iContract  AS CHAR NO-UNDO. /* Назначение договора */
   DEF INPUT PARAM  iContCode  AS CHAR NO-UNDO. /* Номер договора */
   DEF INPUT PARAM  iDate      AS DATE NO-UNDO. /* Дата выгрузки */
   DEF OUTPUT PARAM oDate      AS DATE NO-UNDO. /* Дата выноса на просрочку */
   DEF VAR vPeriod    AS INT64   NO-UNDO.
   DEF BUFFER bloan FOR loan.

    vPeriod = MAX(
        LN_GetPrsDolgDays ( iContract, iContCode, iDate),
        LN_GetPrsProcDays ( iContract, iContCode, iDate)).

    FOR EACH bloan
        WHERE bloan.contract EQ iContract
        AND bloan.cont-code BEGINS iContCode + " " NO-LOCK:

    /* нельзя вызывать, не чухает что просрочка уже нулевая */
    vPeriod = MAX( vPeriod,
        MAX(
            LN_GetPrsDolgDays ( iContract, iContCode, iDate),
            LN_GetPrsProcDays ( iContract, iContCode, iDate))
        ).
    END.
    IF vPeriod EQ 0
        THEN oDate = ?.
    ELSE oDate = iDate - vPeriod.
END.

/*----------------------------------------------------------------------------*/
/* Возвращает сумму по параметру или операции с учетом течений                */
/*----------------------------------------------------------------------------*/
PROCEDURE GetSummUnv_:
   DEF INPUT  PARAM iContract AS CHARACTER NO-UNDO.
   DEF INPUT  PARAM iContCode AS CHARACTER NO-UNDO.
   DEF INPUT  PARAM iOper     AS INT64   NO-UNDO.
   DEF INPUT  PARAM iDate     AS DATE      NO-UNDO.
   DEF INPUT  PARAM iNameProc AS CHARACTER NO-UNDO.
   DEF OUTPUT PARAM oAmtRes   AS DECIMAL   NO-UNDO.
   DEF OUTPUT PARAM oAmtDb    AS DECIMAL   NO-UNDO.
   DEF OUTPUT PARAM oAmtCr    AS DECIMAL   NO-UNDO.

   DEF BUFFER bloan FOR loan.
   DEF VAR vAmtCur AS DECIMAL NO-UNDO.
   DEF VAR vAmtDbCur AS DECIMAL NO-UNDO.
   DEF VAR vAmtCrCur AS DECIMAL NO-UNDO.

   RUN VALUE(iNameProc)(iContract,
                        iContCode,
                        iOper,
                        iDate,
                        OUTPUT oAmtRes,
                        OUTPUT oAmtDb,
                        OUTPUT oAmtCr).
   /* Ищем договор */
   FIND FIRST bLoan WHERE
              bLoan.contract  EQ iContract
          AND bLoan.cont-code EQ iContCode
              NO-LOCK NO-ERROR.
   ASSIGN
      vAmtCur   = 0.00
      vAmtDbCur = 0.00
      vAmtCrCur = 0.00
   .

/*----------- Если это охватывающий договор-течение, то ищем все его транши --*/
   IF AVAIL bloan                  AND
      bloan.cont-type EQ "Течение" THEN
      FOR EACH bloan WHERE
               bloan.contract  = iContract
           AND bloan.cont-code BEGINS iContCode + " "
           AND bloan.cont-code <> iContCode
               NO-LOCK:
         RUN VALUE(iNameProc)(bloan.contract,
                              bloan.cont-code,
                              iOper,
                              iDate,
                              OUTPUT vAmtCur,
                              OUTPUT vAmtDbCur,
                              OUTPUT vAmtCrCur).
         ASSIGN
            oAmtRes = oAmtRes + vAmtCur
            oAmtDb  = oAmtDb  + vAmtDbCur
            oAmtCr  = oAmtCr  + vAmtCrCur
         .
      END.

END PROCEDURE.

/*----------------------------------------------------------------------------*/
/* озвращение оборота за определенный день проведения операции по ID операции    */
/*----------------------------------------------------------------------------*/
PROCEDURE GetLastSummOper.
    DEF INPUT PARAM iContract  AS CHAR NO-UNDO.
    DEF INPUT PARAM iContCode  AS CHAR NO-UNDO.
    DEF INPUT PARAM iOper      AS INT64  NO-UNDO.   /* ид операции */
    DEF INPUT PARAM iDate      AS DATE NO-UNDO.   /* ата отчета */
    DEF OUTPUT PARAM oAmtPrm   AS DEC  NO-UNDO.
    DEF OUTPUT PARAM oAmtDb    AS DEC  NO-UNDO.   /* атычки */
    DEF OUTPUT PARAM oAmtCr    AS DEC  NO-UNDO.   /* атычки */

    DEFINE BUFFER b_chowhe FOR chowhe.
    DEFINE BUFFER b_lint   FOR loan-int.

    ASSIGN
    oAmtPrm = 0.00
    oAmtDb  = 0.00
    oAmtCr  = 0.00
        .

    FIND FIRST b_chowhe WHERE
        b_chowhe.id-op EQ iOper
        NO-LOCK NO-ERROR.

    /* последний платеж мог быть только проценты, ищем последнюю сумму по данному параметру, а не в конкретную дату */
    IF AVAIL b_chowhe THEN
        FOR EACH b_lint WHERE
            b_lint.contract  EQ iContract     AND
            b_lint.cont-code EQ iContCode     AND
            b_lint.id-d      EQ b_chowhe.id-d AND
            b_lint.id-k      EQ b_chowhe.id-k AND
            b_lint.mdate     EQ iDate
            NO-LOCK  BREAK BY b_lint.mdate DESC:
            oAmtPrm = oAmtPrm + b_lint.amt-rub.
            IF LAST-OF( b_lint.mdate) THEN LEAVE.
        END.
END.
/*
FUNCTION WRITEDATAELEMENT (hSAXWriter AS HANDLE, strWrite AS CHAR, bWrite AS LOGICAL):
    IF bWrite THEN 
END FUNCTION.
*/

FUNCTION GetFinanceType RETURN CHAR
    ( iCh AS CHAR):
    RETURN TRIM( iCh).
END FUNCTION.

FUNCTION XmlDate RETURN CHAR
    ( iDate AS DATE):
IF iDate EQ ? THEN RETURN "".
RETURN	    STRING( DAY( iDate), "99") + "." +
	    STRING( MONTH( iDate), "99") + "." + 
	    STRING( YEAR( iDate), "9999").
END FUNCTION.

FUNCTION XmlDec RETURN CHAR
    ( iD AS DEC):
    RETURN TRIM( STRING( iD, "->>>>>>>>>>>>>>9.99")).
END FUNCTION.

FUNCTION GetCodeZal RETURN CHAR
    (strCode AS CHAR):
     DEF VAR strResult AS CHAR INIT '20'.
        CASE strCode:
            WHEN "Автомобиль" THEN strResult = '01'.
            WHEN "ЦенныеБумаги" THEN strResult = '13'.
        END CASE.
    RETURN strResult.
END FUNCTION.

FUNCTION CREcalcParams RETURN DEC
    ( BUFFER loan FOR loan,
      iDateRep AS DATE,
      iPrmNo AS CHAR
    ):
/*
{loan.pro}
{sh-defs.i}
{intrface.get loan}

*/

    def var dat-per as date no-undo.
    DEF VAR vR AS DEC NO-UNDO.
    def var mInter AS CHAR NO-UNDO.
    def var mI AS INT64 NO-UNDO.
    def var date1 AS DATE NO-UNDO.
 
    vR = 0.
    mInter = FGetSettingEx("InterCurrent", "", "", NO).
    mI = LOOKUP( iPrmNo, mInter).

/*put unformatted 
loan.cont-code + " iPrmNo=" + iPrmNo + " " + STRING(iDateRep)
 + " mInter=" + mInter skip.
put unformatted 
"mI=" + string(mI) skip.*/

    IF mI >0 THEN DO ON ERROR UNDO, THROW:
	{ch_dat_p.i}
	{empty otch1}
	date1 = loan.open-date.
        FOR EACH loan-var
         WHERE loan-var.contract  EQ loan.contract
           AND loan-var.cont-code EQ loan.cont-code
           AND loan-var.since <= iDateRep
           AND loan-var.amt-id EQ INT(iPrmNo)
           NO-LOCK BY loan-var.since DESC
            ON ERROR UNDO, THROW:
            date1 = loan-var.since + 1.
            vR = loan-var.balance.
        END.
/*put unformatted 
"date1=" string(date1) + " " + string(vR) skip.*/
        IF date1 < iDateRep THEN DO ON ERROR UNDO, THROW:
/* put unformatted 
loan.contract + " " + loan.cont-code + " " + string(date1) + " " + 
string(iDateRep) + " " + string(dat-per) + " " + string(mI) skip.*/
	    RUN lnscheme.p ( loan.contract, loan.cont-code, date1, iDateRep, dat-per, mI, 1).
	    for each otch1:
		vR = vR + otch1.summ_pr.
	    end.
/*put unformatted 
"vR+otch1=" + string(vR) skip.*/
            FOR EACH loan-int
             WHERE loan-int.contract EQ loan.contract
               AND loan-int.cont-code EQ loan.cont-code
               AND id-k EQ INT(iPrmNo)
               AND loan-int.mdate >= date1
               AND loan-int.mdate <= iDateRep
               NO-LOCK ON ERROR UNDO, THROW:
    	           vR = vR - loan-int.amt-rub.
            END.
        END.
    END.

/*put unformatted 
"R=" + string(vR) skip.*/

    RETURN vR.
END FUNCTION.

FUNCTION CREListGetSummByIntVar RETURNS DECIMAL
    (BUFFER loan FOR loan,  /* кредитный договор */
     iDate     AS DATE,     /* дата выгрузки */
     iListOper AS CHAR):    /* список параметров классификатора НБКИ_КодОпер */

   DEF VAR vDatePay  AS DATE NO-UNDO. /* Дата последней выплаты */
   DEF VAR vAmtCur   AS DEC  NO-UNDO. /* сумма по одной операции */
   DEF VAR vAmt      AS DEC  NO-UNDO. /* общая сумма */
   DEF VAR vI        AS INT64  NO-UNDO. /* счетчик */
   DEF VAR vY        AS INT64  NO-UNDO. /* счетчик */
   DEF BUFFER bcode FOR CODE.

   ASSIGN vAmt      = 0.00.

   DO vI = 1 TO NUM-ENTRIES(iListOper):


	IF NOT GetCodeBuff("НБКИ_КодОпер", ENTRY(vI,iListOper), BUFFER bcode)
	   THEN RETURN 0. /* RETURN ERROR "В классификаторе НБКИ_КодОпер нет параметра " + ENTRY(vI,iListOper).*/

	/* список параметров, остатки по которым нужно сложить */
	IF bcode.misc[3] > "" THEN
	DO vY = 1 TO NUM-ENTRIES(bcode.misc[3]):
    	    vAmtCur = CREcalcParams
    		(BUFFER loan, iDate, ENTRY(vY,bcode.misc[3])).
    	    vAmt = vAmt + vAmtCur.
    	END.
   END.
/*put unformatted 
loan.cont-code + " " + iListOper + " " + STRING(iDate) + " " + string(vAmt) skip.*/
   RETURN vAmt.
END FUNCTION.

/* своевременность платежей, украдено из pp-bki */
FUNCTION BKIMOP2 RETURNS CHAR
    (iContract AS CHAR,               /* кредитный договор */
     iContCode AS CHAR,
     iDate AS DATE):                  /* дата выгрузки */

   DEF VAR vAcctMOP   AS CHAR    NO-UNDO. /* доп. реквизит на договоре */
   DEF VAR vDueDate   AS DATE    NO-UNDO. /* дата выноса на просрочку */
   DEF VAR vOpDate    AS DATE    NO-UNDO. /* дата операции погашения ОД в счет обеспечения */
   DEF VAR vPeriod    AS INT64   NO-UNDO.
   DEF VAR vVersion   AS DECIMAL NO-UNDO.
   DEF VAR vNBKISvMes AS LOG     NO-UNDO. /* НП НБКИ_Св_Мес */

   vVersion = DECIMAL(FGetSetting("НБКИ","Версия","")) NO-ERROR.
   vNBKISvMes = FGetSetting("НБКИ_Св_Мес","","Нет") EQ "Да".

   {profile BK351}
   vAcctMOP = GetXattrValueEx("loan",
                              iContract + "," + iContCode,
                              "НБКИ_Своевременн",
                              "").

   /* если доп. реквизит не задан, то вычисляем его */
   IF vAcctMOP = "" THEN DO:
      /* проверяем, была ли оплата в счет обепечения */
      RUN GetFirstDateUnv(iContract,
                          iContCode,
                          iDate,
                          ?,
                          "PayByOB",
                          OUTPUT vOpDate).
      IF vOpDate <> ?  THEN vAcctMOP = "8".
      ELSE DO:
            /* Определяем дату неоплаченного выноса на просрочку */
          RUN GetFirstDueDate(iContract,
                              iContCode,
                              iDate,
                              OUTPUT vDueDate).
          vPeriod = iDate - vDueDate.
             /* Если задана настройка, то опрелеяем период по-другому */
          IF vNBKISvMes THEN
             IF vDueDate EQ ? THEN
                vPeriod = 0.
             ELSE
                vPeriod =  iDate - MAX(vDueDate, FirstMonDate(iDate)) + 1.

          IF     NOT vNBKISvMes 
             AND vDueDate = ? THEN DO:
              /* определяем дату последней выплаты - если нет, то новый */
              IF BKIDateOFLstPay(iContract,
                                 iContCode,
                                 iDate) = ?
                 THEN vAcctMOP = "0".      /* новый */
              ELSE vAcctMOP = "0".         /* оплата без просрочек */
          END.
          ELSE IF vPeriod < 31
                  THEN vAcctMOP = "A".
          ELSE IF vPeriod > 30 AND
                  vPeriod < 61
                  THEN vAcctMOP = "1".
          ELSE IF vPeriod > 60 AND
                  vPeriod < 91
                  THEN vAcctMOP = "2".
          ELSE IF vPeriod > 90 AND
                  vPeriod < 121
                  THEN vAcctMOP = "3".
          ELSE IF vPeriod > 120 AND
                  vPeriod < 151
                  THEN vAcctMOP = "4".
          ELSE IF vPeriod > 150 AND
                  vPeriod < 181
                  THEN vAcctMOP = "5".
          ELSE IF vPeriod >= 180
                  THEN vAcctMOP = "6".
      END.
   END.
   {profile BK360}
   RETURN vAcctMOP.
END FUNCTION.

PROCEDURE CREexportCorp:
    DEFINE INPUT PARAMETER hSAXWriter AS HANDLE NO-UNDO.
    DEFINE PARAMETER BUFFER cust-corp FOR cust-corp.
    DEF VAR lOk AS LOG NO-UNDO.

    lOK = hSAXWriter:START-ELEMENT("Business").
    lOK = hSAXWriter:WRITE-DATA-ELEMENT("ReferenceCode", {&ULPREFIX} + STRING(cust-corp.cust-id)).
    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Name", cust-corp.name-short).
    lOK = hSAXWriter:WRITE-DATA-ELEMENT("RegistrationNumber", 
	GetXAttrValueEx("cust-corp", STRING(cust-corp.cust-id), "огрн", "")).
    lOK = hSAXWriter:WRITE-DATA-ELEMENT("INN", cust-corp.inn).
    IF GetXAttrValue( "cust-corp", STRING(cust-corp.cust-id), "country-id2") NE "RUS" THEN
	lOK = hSAXWriter:WRITE-DATA-ELEMENT("Resident", "0").
    lOK = hSAXWriter:WRITE-DATA-ELEMENT("CountryReg", 
		string( 
		    GetXAttrValue( "country",
			string( GetXAttrValue( "cust-corp", STRING(cust-corp.cust-id), "country-id2")),
			"ALFA-2"),
		    'x(2)')).

    lOK = hSAXWriter:START-ELEMENT("Addresses").
    DEF VAR vAdrType AS INT NO-UNDO.
    DO vAdrType = 1 TO 2:
		FIND FIRST cust-ident
		     WHERE cust-ident.cust-cat       EQ "ю"
	               AND cust-ident.cust-id        EQ cust-corp.cust-id
	               AND cust-ident.class-code     EQ "p-cust-adr"
	               AND cust-ident.cust-code-type EQ ENTRY( vAdrType, "адрюр,адрфакт")
		     NO-LOCK NO-ERROR.
		IF NOT AVAIL cust-ident AND vAdrType EQ 2 THEN DO:
		    FIND FIRST cust-ident
		     WHERE cust-ident.cust-cat       EQ "ю"
	               AND cust-ident.cust-id        EQ cust-corp.cust-id
	               AND cust-ident.class-code     EQ "p-cust-adr"
	               AND cust-ident.cust-code-type EQ ENTRY( 1, "адрюр,адрфакт")
		     NO-LOCK NO-ERROR.
		END.
		IF NOT AVAIL cust-ident THEN NEXT.
		DO ON ERROR UNDO, LEAVE:
		DEF VAR vRegion AS CHAR NO-UNDO.
		vRegion = GetXAttrValue( 'cust-ident',
		    cust-ident.cust-code-type + ',' + cust-ident.cust-code + ',' + STRING(cust-ident.cust-type-num),
		    'КодРегГНИ').
		lOK = hSAXWriter:START-ELEMENT("Address").
		
		{cust-adr.obj 
		     &addr-to-vars = YES
		     &tablefield   = "TRIM(cust-ident.issue)"
		}

		IF vRegion EQ "77" AND vGorChar EQ "" THEN vGorChar = "Москва г".
		IF vRegion EQ "78" AND vGorChar EQ "" THEN vGorChar = "Санкт-Петербург г".

		/* 09/07/14
		IF vUlChar EQ "" THEN
	    	    ASSIGN
	    	      vUlChar = vPunktChar
	    	      vPunktChar = ""
	    	      .
		IF vUlChar EQ "" THEN
	    	    ASSIGN
	    	      vUlChar = vGorChar
	    	      vGorChar = ""
	    	      .
		*/
		
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Type", string(vAdrType + 2)).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Location", vGorChar + (IF vPunktChar <> "" AND vGorChar <> "" THEN ", " ELSE "") + vPunktChar ).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Street", vUlChar).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("PostalCode", IF vAdrIndInt EQ 0 THEN "" ELSE string(vAdrIndInt)).
		DEF VAR vAdrCountry AS CHAR NO-UNDO.
		vAdrCountry = GetXattrValue("cust-ident",
                                                  cust-ident.cust-code-type + ',' + 
                                                  cust-ident.cust-code      + ',' + 
                                                  STRING(cust-ident.cust-type-num),
                                                  "country-id"
                                                 ).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Country", 
		    string(GetXAttrValue( "country",
			string( vAdrCountry),
			"ALFA-2"))).
		IF vRegion Ne ? THEN
		    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Region", vRegion).
		/*lOK = hSAXWriter:WRITE-DATA-ELEMENT("Area", vOblChar).
		  lOK = hSAXWriter:WRITE-DATA-ELEMENT("District", vOblChar).
		  lOK = hSAXWriter:WRITE-DATA-ELEMENT("StreetType", "").
		*/
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("HouseNumber", vDomChar).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Block", vKorpChar).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Building", vStrChar).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Apartment", vKvChar).
		/*lOK = hSAXWriter:WRITE-DATA-ELEMENT("Status", "").*/
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Since", 
		    XmlDate( cust-ident.open-date)).
		lOK = hSAXWriter:END-ELEMENT("Address").
		END. /* DO */
    END.
    lOK = hSAXWriter:END-ELEMENT("Addresses").
    DEF VAR vTel AS CHAR NO-UNDO.
    vTel = GetXAttrValueEx("cust-corp", STRING(cust-corp.cust-id), "tel", "").
    IF vTel NE "" OR cust-corp.fax NE "" THEN DO:
	lOK = hSAXWriter:START-ELEMENT("Phones").
	IF vTel NE "" THEN DO:
    	    lOK = hSAXWriter:START-ELEMENT("Phone").
    	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Type", "1").
    	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Number", vTel).
    	    lOK = hSAXWriter:END-ELEMENT("Phone").
	END.
	IF cust-corp.fax NE "" THEN DO:
    	    lOK = hSAXWriter:START-ELEMENT("Phone").
    	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Type", "3").
    	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Number", cust-corp.fax).
    	    lOK = hSAXWriter:END-ELEMENT("Phone").
	END.
	lOK = hSAXWriter:END-ELEMENT("Phones").
    END.
END.

PROCEDURE CREexportPerson:
    DEFINE INPUT PARAMETER hSAXWriter AS HANDLE NO-UNDO.
    DEFINE PARAMETER BUFFER person FOR person.
    DEF VAR lOk AS LOG NO-UNDO.

	    lOK = hSAXWriter:START-ELEMENT("Person").
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("ReferenceCode", {&FLPREFIX} + STRING(person.person-id)).
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("LastName", string(person.name-last)).
	    DEF VAR FirstName AS CHAR NO-UNDO.
	    FirstName = string(ENTRY(1,person.first-names,' ')).
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("FirstName", string(trim(FirstName))).
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("MiddleName", string(trim(substring( person.first-names, LENGTH(FirstName) + 1)))).
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("BirthDate", 
		    XmlDate( person.birthday)).
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("BirthPlace", 
		string( 
		    GetXAttrValue("person", STRING(person.person-id), "BirthPlace")
		    )).

	    /* CRE: 1 - мужской, 2 - женский 
	       BIS: 1 - мужской, 0 - женский */
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT( "Gender", (IF person.gender THEN "1" ELSE "2")).
	     
	    /* гражданство: 99 - неизвестно */
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Citizenship", 
		string( 
		    GetXAttrValue( "country",
			string( GetXAttrValue( "person", STRING(person.person-id), "country-id2")),
			"ALFA-2"),
		    'x(2)')).
	    /* 1 холост,2 женат/замужем,3 овдовевший,4 разведенный,5 повторно женился/замужем,6 иное
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("MaritalStatus", ). 
	    кол-во иждивенцев
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Dependants", ). */
	    IF GetXAttrValueEx("person", STRING(person.person-id), "BirthPlace", "Нет") = "Да"
		THEN lOK = hSAXWriter:WRITE-DATA-ELEMENT("Remarks", "1").
	    DEF VAR strr AS CHAR NO-UNDO.
	    strr = GetXAttrValueEx("person", STRING(person.person-id), "ИзмФИПредФам", "").
	    IF strr <> "" 
		THEN lOK = hSAXWriter:WRITE-DATA-ELEMENT("OldLastName", strr).
	    strr = GetXAttrValueEx("person", STRING(person.person-id), "ИзмФИПредИмя", "").
	    IF strr <> "" 
		THEN lOK = hSAXWriter:WRITE-DATA-ELEMENT("OldFirstName", strr).
	    IF person.inn NE "" AND person.inn NE ?
		THEN lOK = hSAXWriter:WRITE-DATA-ELEMENT("INN", person.inn).
	    DEF VAR doc_cnt AS INT NO-UNDO.
	    doc_cnt = 0.
	    FOR EACH cust-ident
	     WHERE cust-ident.cust-cat       EQ "Ч"
               AND cust-ident.cust-id        EQ Person.person-id
               AND cust-ident.class-code     EQ "p-cust-ident"
	     NO-LOCK BREAK BY cust-ident.cust-id ON ERROR UNDO, THROW:
		IF FIRST(cust-ident.cust-id) THEN DO:
		    lOK = hSAXWriter:START-ELEMENT("Documents").
		END.
		lOK = hSAXWriter:START-ELEMENT("Document").
		/* тип документа совпадает с классификатором фнс , 99 - иной,
		  31 нет в фнс, но есть в CRE */
		DEF VAR vDocType AS CHAR NO-UNDO.
		vDocType = GetCode("КодДокум", cust-ident.cust-code-type).
		IF vDocType EQ ? OR vDocType EQ "" THEN vDocType = "91".
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Type", vDocType).
		DEF VAR vCustCode AS CHAR NO-UNDO.
		DEF VAR vCustCodeNum AS CHAR NO-UNDO.
		DEF VAR vCustCodeSer AS CHAR NO-UNDO.
		
		vCustCode  = TRIM (cust-ident.cust-code).
		vCustCodeNum = ENTRY(NUM-ENTRIES(vCustCode," "),vCustCode," ").
		vCustCodeSer = TRIM(SUBSTR(vCustCode, 1, 
                                               LENGTH(vCustCode) - LENGTH(vCustCodeNum))).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Series", vCustCodeSer).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Number", vCustCodeNum).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("IssueDate",
		    XmlDate( cust-ident.open-date)).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("IssueAuthority", string(cust-ident.issue)).
		/*lOK = hSAXWriter:WRITE-DATA-ELEMENT("IssuePlace", ).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("OldNumber", ).
		*/
		lOK = hSAXWriter:END-ELEMENT("Document").
		doc_cnt = doc_cnt + 1.
	    END.
	    /*DEF VAR vOGRN AS CHAR NO-UNDO.
	    vOGRN = GetXattrValue("person", STRING(iCustID),"огрн").
	    IF {assigned vOGRN} THEN DO:
		lOK = hSAXWriter:START-ELEMENT("Document").
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Type", "33").
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Series", "").
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Number", vOGRN).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("IssueDate",
		    XmlDate( cust-ident.open-date)).
		lOK = hSAXWriter:END-ELEMENT("Document").
		
		doc_cnt = doc_cnt + 1.
	    END.*/
	    IF doc_cnt > 0 THEN
		lOK = hSAXWriter:END-ELEMENT("Documents").

	    /*
	    {cust-adr.obj
	          &def-vars     = YES
	    }
	    */
	    lOK = hSAXWriter:START-ELEMENT("Addresses").
	    DEF VAR vAdrType AS INT NO-UNDO.
	    DO vAdrType = 1 TO 2:
		FIND FIRST cust-ident
		     WHERE cust-ident.cust-cat       EQ "Ч"
	               AND cust-ident.cust-id        EQ Person.person-id
	               AND cust-ident.class-code     EQ "p-cust-adr"
	               AND cust-ident.cust-code-type EQ ENTRY( vAdrType, "адрпроп,адрфакт")
	               AND (cust-ident.close-date EQ ? OR cust-ident.close-date > TODAY)
		     NO-LOCK NO-ERROR.
		IF NOT AVAIL cust-ident AND vAdrType EQ 2 THEN DO:
		    FIND FIRST cust-ident
		     WHERE cust-ident.cust-cat       EQ "Ч"
	               AND cust-ident.cust-id        EQ Person.person-id
	               AND cust-ident.class-code     EQ "p-cust-adr"
	               AND cust-ident.cust-code-type EQ ENTRY( 1, "адрпроп,адрфакт")
	               AND (cust-ident.close-date EQ ? OR cust-ident.close-date > TODAY)
		     NO-LOCK NO-ERROR.
		END.
		IF NOT AVAIL cust-ident THEN NEXT.
		DO ON ERROR UNDO, LEAVE:
		DEF VAR vRegion AS CHAR NO-UNDO.
		vRegion = GetXAttrValue( 'cust-ident',
		    cust-ident.cust-code-type + ',' + cust-ident.cust-code + ',' + STRING(cust-ident.cust-type-num),
		    'КодРегГНИ').
		lOK = hSAXWriter:START-ELEMENT("Address").
		
		{cust-adr.obj 
		     &addr-to-vars = YES
		     &tablefield   = "TRIM(cust-ident.issue)"
		}
		IF vRegion EQ "77" AND vGorChar EQ "" THEN vGorChar = "Москва г".
		IF vRegion EQ "78" AND vGorChar EQ "" THEN vGorChar = "Санкт-Петербург г".

		/* 09/07/14
		IF vUlChar EQ "" THEN
	    	    ASSIGN
	    	      vUlChar = vPunktChar
	    	      vPunktChar = ""
	    	      .
		IF vUlChar EQ "" THEN
	    	    ASSIGN
	    	      vUlChar = vGorChar
	    	      vGorChar = ""
	    	      .
		*/
		
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Type", string(vAdrType)).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Location", vGorChar + (IF vPunktChar <> "" AND vGorChar <> "" THEN ", " ELSE "") + vPunktChar ).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Street", vUlChar).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("PostalCode", IF vAdrIndInt EQ 0 THEN "" ELSE string(vAdrIndInt)).
		DEF VAR vAdrCountry AS CHAR NO-UNDO.
		vAdrCountry = GetXattrValue("cust-ident",
                                                  cust-ident.cust-code-type + ',' + 
                                                  cust-ident.cust-code      + ',' + 
                                                  STRING(cust-ident.cust-type-num),
                                                  "country-id"
                                                 ).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Country", 
		    string(GetXAttrValue( "country",
			string( vAdrCountry),
			"ALFA-2"))).
		IF vRegion Ne ? THEN
		    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Region", vRegion).
		/*lOK = hSAXWriter:WRITE-DATA-ELEMENT("Area", vOblChar).
		  lOK = hSAXWriter:WRITE-DATA-ELEMENT("District", vOblChar).
		  lOK = hSAXWriter:WRITE-DATA-ELEMENT("StreetType", "").
		*/
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("HouseNumber", vDomChar).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Block", vKorpChar).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Building", vStrChar).
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Apartment", vKvChar).
		/*lOK = hSAXWriter:WRITE-DATA-ELEMENT("Status", "").*/
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("Since", 
		    XmlDate( cust-ident.open-date)).
		lOK = hSAXWriter:END-ELEMENT("Address").
		END. /* DO */
	    END.
	    lOK = hSAXWriter:END-ELEMENT("Addresses").
	    DEF VAR ph AS CHAR EXTENT 4 NO-UNDO.
	    ph[1] = ENTRY(1, person.phone[2]).
	    ph[2] = IF NUM-ENTRIES( person.phone[1]) > 1 THEN ENTRY(2, person.phone[1]) ELSE "".
	    IF ph[2] EQ "" THEN ph[2] = ENTRY(1, person.phone[1]).
	    IF ph[2] EQ "" THEN ph[2] = GetXattrValueEx("person", STRING(person.person-id), "phone-home", "").
	    ph[3] = person.fax.
	    ph[4] = IF NUM-ENTRIES( person.phone[2]) > 1 THEN ENTRY(2, person.phone[2]) ELSE "".
	    IF ph[4] EQ "" THEN ph[4] = GetXattrValueEx("person", STRING(person.person-id), "cell-phone", "").
	    IF ph[1] NE "" OR ph[2] NE "" OR ph[3] NE "" OR ph[4] NE "" THEN DO:
		DEF VAR ik AS INT NO-UNDO.
		lOK = hSAXWriter:START-ELEMENT("Phones").
		DO ik = 1 TO 4:
		    IF ph[ik] NE "" THEN DO:
			IF LENGTH(ph[ik]) > 14 THEN DO:
			    DEF VAR iu AS INT NO-UNDO.
			    iu = 15.
			    strr = ph[ik].
			    DO WHILE ASC(substr(strr, iu, 1)) >= ASC('0') AND
			             ASC(substr(strr, iu, 1)) <= ASC('9') AND
				     ASC(substr(strr, iu - 1, 1)) >= ASC('0') AND 
				     ASC(substr(strr ,iu - 1, 1)) <= ASC('9') AND
				     iu > 2:
				iu = iu - 1.
			    END.
			    DO WHILE LOOKUP( substr( strr, iu - 1, 1), ",x x;x-", "x") > 0 AND
				     iu > 2 :
				iu = iu - 1.
			    END.
			    ph[ik] = substr( strr, 1, (IF iu >= 5 THEN iu - 1 ELSE 14)).
			END.
			lOK = hSAXWriter:START-ELEMENT("Phone").
			lOK = hSAXWriter:WRITE-DATA-ELEMENT("Type", STRING(ik)).
			lOK = hSAXWriter:WRITE-DATA-ELEMENT("Number", ph[ik]).
			lOK = hSAXWriter:END-ELEMENT("Phone").
		    END.
		END.
		lOK = hSAXWriter:END-ELEMENT("Phones").
	    END.
END.

PROCEDURE CREexportTrade:
    DEFINE INPUT PARAMETER hSAXWriter AS HANDLE NO-UNDO.
    DEFINE INPUT  PARAMETER iCustCat AS CHAR NO-UNDO.
    DEFINE INPUT  PARAMETER iCustID AS INT64 NO-UNDO.
    DEFINE INPUT  PARAMETER iDateRep AS DATE NO-UNDO.
    DEFINE PARAMETER BUFFER loan FOR loan.
    DEFINE PARAMETER BUFFER bTerm FOR term-obl.
    DEFINE INPUT  PARAMETER bGuar AS LOGICAL NO-UNDO.
    DEFINE INPUT PARAMETER dPoruc AS DATE NO-UNDO.


    DEF VAR strDatePoruch AS CHAR NO-UNDO. /* дата, с которой по кредиту платит поручитель, а не заемщик */ 
    DEF VAR datePoruch AS DATE NO-UNDO. /* дата, с которой по кредиту платит поручитель, а не заемщик */
    DEF VAR lOk AS LOG NO-UNDO.
    DEFINE VAR vAccRelation AS CHARACTER      NO-UNDO.
    DEF VAR vLoanType AS CHAR NO-UNDO.
    DEFINE VAR vRegNum      AS CHARACTER      NO-UNDO.
    DEF VAR vPaymentFrequency AS CHAR NO-UNDO.

    lOK = hSAXWriter:START-ELEMENT("Trade").
    DO ON ERROR UNDO, THROW:
	    DEF VAR vDateRep AS DATE NO-UNDO.
	    /* если договор закрыт и это первая выгрузка, то выгружаем с текущей датой *
	    IF loan.close-date NE ? AND loan.close-date < TODAY AND GetXAttrValueEx('loan',
	                      loan.contract + "," + loan.cont-code, "CREsince", "?") EQ "?"
	     THEN vDateRep = TODAY. ELSE */ vDateRep = iDateRep.
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT( "DateReported",
	    	XmlDate( vDateRep)).
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("MemberCode", {&NBKICODE}).
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Account", REPLACE( loan.cont-code, '@', '/')).
	    /* тип кредита
	    код начение
	    1	кредит на автомобиль
	    4	лизинг
	    6	ипотека
	    7	кредитная карта
	    9	потребительский кредит
	    10	на развитие бизнеса
	    11	на пополнение оборотных средств
	    12	на покупку оборудования
	    13	на строительство
	    14	на покупку акций
	    15	межбанковский кредит */
	    vLoanType = BKIAccType( BUFFER loan).
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Type", vLoanType).

	    /*4.17 отношение к счету
	    код значение
	    1 физическое лицо
	    2 дополнительная карта (только для кредитных карт)
	    3 авторизованный пользователь (доверенное лицо)
	    4 совместный
	    5 поручитель
	    9 юридическое лицо*/
	    /*lOK = hSAXWriter:WRITE-DATA-ELEMENT("Relationship", IF loan.cust-cat EQ "Ч" THEN "1" ELSE "9").*/
	    IF iCustCat EQ "Ч" THEN
    	      vRegNum = /*GetXattrValue("person", STRING(iCustID),"огрн").*/
    	         ENTRY(1,GetXattrValue("person", STRING(iCustID),"СведРегПред")).
	    vAccRelation = BKIAccRelation (BUFFER loan, BUFFER bTerm, IF AVAIL(bTerm) THEN (bTerm.symbol + "," + STRING(bTerm.fop)) ELSE " ",
		 IF (iCustCat EQ "ю" OR {assigned vRegNum}) THEN YES ELSE NO).
	    FOR EACH cust-role
	         WHERE cust-role.file-name EQ "loan"
	           AND cust-role.surrogate EQ loan.contract + "," + loan.cont-code
	           AND cust-role.class-code EQ "созаемщик"
	           NO-LOCK:
		IF (cust-role.cust-cat EQ iCustCat AND cust-role.cust-id EQ STRING(iCustID))
		   OR vAccRelation EQ "1"
		 THEN DO:
	    	    vAccRelation = "4". /* созаемщик сам или у заемщика есть любой созаемщик,тогда ставим 4 - совместный */
	    	    LEAVE.
		END.
	    END.
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Relationship", vAccRelation).

	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("DateOpened", 
		XmlDate( loan.open-date)).

	    /*{n-mess.i "STRING(ij) + ' ' + '7'"}*/
	    /* 7. дата последней выплаты * - необяз */
	    DEF VAR vDateLastPayment AS DATE NO-UNDO.
	  /*  message loan.contract + ' ' + loan.cont-code +  string(iDateRep,"99.99.9999") view-as alert-box. */
	  /* message string(loan.since)  view-as alert-box. */
	    vDateLastPayment = BKIDateOFLstPay( loan.contract, loan.cont-code, iDateRep).
/*	    message string(vDateLastPayment) view-as alert-box. */
	    IF vDateLastPayment EQ ? THEN vDateLastPayment = DATE( 1, 2, 1900).
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("DateLastPayment", 
		XmlDate( vDateLastPayment)).

	    /*4.18 состояние счета
	    код значение
	    00 либо 0	активный
	    12		оплачен за счет обеспечения
	    13		счет закрыт
	    14		передан на обслуживание в другой банк
	    21		спор
	    52		просрочен
	    61		проблемы с возвратом*/
	    DEF VAR oAccRat AS CHAR NO-UNDO.
	    DEF VAR oDateAccRat AS DATE NO-UNDO.
	    
	    RUN BKIAccRating( BUFFER loan, iDateRep, ?, vDateLastPayment, 
		OUTPUT oAccRat, OUTPUT oDateAccRat).
	    IF oAccRat EQ "00" THEN DO ON ERROR UNDO, THROW:
		RUN GetLastDueDate( loan.contract, loan.cont-code, iDateRep, OUTPUT oDateAccRat).
		IF oDateAccRat EQ ? THEN oDateAccRat = loan.open-date.
	    END.
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("AccountState", oAccRat).
	
	    FIND FIRST currency WHERE currency.currency EQ loan.currency NO-LOCK NO-ERROR.
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Currency", 
		IF AVAIL currency THEN currency.i-currency ELSE "").
        DEF VAR dLimit AS DECIMAL NO-UNDO.
        dLimit = BKICredLimitAmt( BUFFER loan). 
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT( "Limit", 
		XmlDec(dLimit)).

	    /* 11. общая выплаченная сумма, включая
	    проценты и пени на дату, указанную в поле дата
	    последней выплаты. значение может быть только
	    неотрицательным.*/
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("Balance", 
		XmlDec( BKICredBalance(BUFFER loan, iDateRep, vDateLastPayment))).

	    /* 12. сумма просрочки на последнюю дату
	       обновления, указанную в поле даты отчёта.*/
	    DEF VAR vPastDue AS DEC NO-UNDO.
	    /* vPastDue = BKIPastDue(BUFFER loan, iDateRep, vDateLastPayment).*/
	    vPastDue = ListGetSummByIntVar(BUFFER loan,
                              iDateRep,
                              "ЗадолжОД,ЗадолжПр").
	    /*IF iDateRep EQ loan.since THEN*/
		vPastDue = vPastDue + CREListGetSummByIntVar(BUFFER loan,
                              iDateRep,
                              "ПеняОД,ПеняПР").
	    
	    DEF VAR vMannerOfPayment AS CHAR NO-UNDO.
	    vMannerOfPayment = BKIMOP( loan.contract, loan.cont-code, iDateRep).
	    DEF VAR vPastDueNoExtra AS DEC NO-UNDO.
	    vPastDueNoExtra = ListGetSummByIntVar(BUFFER loan, iDateRep, "ЗадолжОД").
	    IF vMannerOfPayment EQ "1" AND vPastDue > 0 THEN DO:
		IF vPastDueNoExtra <= 0 /* если просрочка од равна нулю, то обнуляем пени */
		  THEN vPastDue = 0.
	    END.
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("PastDue",
		XmlDec( MAXIMUM( 0, vPastDue))).

	    /* 13. своевременность платежей (справочник
	       воевременность платежей)\состояние платежа
	       по счету на дату отчета DateReported.
	       4.19 своевременность платежей
	    код значение
	    0 новый, оценка невозможна
	    1 оплата без просрочек
	    A просрочка от 1 до 29 дней
	    2 просрочка от 30 до 59 дней
	    3 просрочка от 60 до 89 дней
	    4 просрочка от 90 до 119 дней
	    5 просрочка более 120 дней
	    7 регулярные консолидированные платежи
	    (значение ставится в том случае, если произведена реструктуризация
	    долга заемщика по причине сложностей с его возвратом)
	    8 взыскание оплаты залогом
	    (огашение по кредиту произведено с использованием залога. начение
	    ставится и в том случае, если часть кредита была погашена залогом)
	    9 безнадёжный долг/ передано на взыскание/ пропущенный платеж
	    (значение ставится в том случае, если кредит признан безнадежным)*/
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("MannerOfPayment", 
		vMannerOfPayment).

	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("DateContractTermination", 
		XmlDate(loan.end-date)).

	    /* 15. договорная дата финального платежа.может отличаться или совпадать с датой
	    окончания срока договора.*/
	    DEF VAR vBKIDatePayDue AS DATE NO-UNDO.
	    vBKIDatePayDue = BKIDatePayDue( loan.contract, loan.cont-code, iDateRep).
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("DatePaymentDue", 
		XmlDate(vBKIDatePayDue)).

	    /* договорная дата финальной выплаты процентов 
	       гр-к процентов бисом пересчитывается, поэтому берем максимум между платежами по долгу и по процентам
	     */
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("DateInterestPaymentDue",
		XmlDate(MAXIMUM( vBKIDatePayDue, BKIDateInterPayDue( loan.contract, loan.cont-code, iDateRep)))).
	    /* 17. */
	    lOK = hSAXWriter:WRITE-DATA-ELEMENT("DateAccountState", XmlDate(oDateAccRat)).
	    /* 18. TR(14) сумма следующего очередного платежа */
      DEF VAR vNextPayment AS DEC NO-UNDO.
      DEF VAR vAmountOutstandingNoExtra AS DEC NO-UNDO.
      DEF VAR vAmountOutstanding AS DEC NO-UNDO.
      vAmountOutstandingNoExtra =  ListGetSummByIntVar(BUFFER loan, iDateRep, "ТекОД,ЗадолжОД").
      vAmountOutstanding = vAmountOutstandingNoExtra
     + ListGetSummByIntVar(BUFFER loan, iDateRep, "Текпроц,ЗадолжПР")
     + /*IF iDateRep EQ loan.since THEN*/ CREListGetSummByIntVar(BUFFER loan, iDateRep, "пеняод,пеняпр")
        /*ELSE 0*/ .
      vNextPayment = MINIMUM( vAmountOutstanding, BKINextPayment( loan.contract, loan.cont-code, iDateRep)).
      lOK = hSAXWriter:WRITE-DATA-ELEMENT("NextPayment",
     XmlDec(vNextPayment)).


        /* 19. TR(15) частота выплат по основному долгу
        (справочник частоты выплат). при экспорте в Equifax 3.0 это обязательное поле.*/
        vPaymentFrequency = BKICredPayFreq( loan.contract, loan.cont-code, iDateRep).
        if vPaymentFrequency NE ? AND vPaymentFrequency NE ''
            THEN lOK = hSAXWriter:WRITE-DATA-ELEMENT("PaymentFrequency", vPaymentFrequency).

        /* 20. TR(18) код залога по кредиту (справочник код залога) */
        DEF VAR vCollateral AS CHAR INIT '0' NO-UNDO.
        FOR EACH signs WHERE signs.file-name = 'term-obl' 
            AND signs.surrogate BEGINS Loan.contract + "," + loan.cont-code + ',5'
            AND signs.code = 'виддогоб'
            AND (signs.xattr-value = 'КредЦБум' OR signs.xattr-value = 'КредОб') NO-LOCK: 
	    IF signs.xattr-value = 'КредЦБум' THEN
	            vCollateral = '20'.
	    ELSE vCollateral = '01'.
            LEAVE.
        END.
            /*
        DEF VAR vCollateral AS CHAR NO-UNDO.
        vCollateral = "".
        FOR EACH TERM-OBL
        WHERE TERM-OBL.CONTRACT = LOAN.CONTRACT
        AND TERM-OBL.CONT-CODE = LOAN.CONT-CODE
        AND TERM-OBL.IDNT = 5
        AND TERM-OBL.CLASS-CODE = "term-obl-gar"
        AND TERM-OBL.FOP-DATE <= iDateRep
        AND TERM-OBL.END-DATE >= iDateRep
        NO-LOCK:
            IF GetXattrValue( "term-obl", 
            GetSurrogate("term-obl",ROWID(term-obl)),
                "ВидДогОб") NE "КредОб"
                    THEN NEXT.
                    IF vCollateral EQ "" THEN
            vCollateral = GetCodeZal( BUFFER TERM-OBL, iDateRep).
            ELSE vCollateral = "20".
        END.
        IF vCollateral NE "" THEN
        */
        IF vCollateral NE '0' THEN
          lOK = hSAXWriter:WRITE-DATA-ELEMENT("Collateral", vCollateral).
        

	    
	    /*
	      lOK = hSAXWriter:WRITE-DATA-ELEMENT("InterestPaymentFrequency", "").
	      */


/*	    /* 23. TR(24) старый номер счета */
	    IF loan.open-date <= DATE( 4, 17, 2014) AND (loan.filial-id <> '0300' OR loan.filial-id <> '0500') THEN
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("OldAccount", loan.cont-code).
*/

	DEF VAR oldAcc AS CHAR NO-UNDO.
	oldAcc = loan.cont-code.
	IF loan.open-date <= DATE( 12, 31, 2013) THEN oldAcc = Replace(oldAcc,'@0000','@0400').
	IF loan.open-date > DATE( 12, 31, 2013) AND loan.open-date < DATE( 05, 01, 2015) THEN oldAcc = Replace(oldAcc,'@0000','/0400').
	IF loan.open-date > DATE( 05, 01, 2015) THEN oldAcc = Replace(oldAcc,'@0000','').
	IF loan.filial-id <> '0300' THEN
		lOK = hSAXWriter:WRITE-DATA-ELEMENT("OldAccount", oldAcc).



	    /* 24. TR(25) текущая задолженность */
	      lOK = hSAXWriter:WRITE-DATA-ELEMENT("AmountOutstanding", 
		XmlDec( vAmountOutstanding)).


        /* 30. op_cred_sum_payout сумма последнего факт погаш од */
        DEF VAR oAmt     AS DECIMAL    NO-UNDO.
        DEF VAR vAmtCur  AS DECIMAL    NO-UNDO.
        DEF VAR vAmtDb   AS DECIMAL    NO-UNDO.
        DEF VAR vAmtCr   AS DECIMAL    NO-UNDO.
        DEF VAR vI       AS INT64  NO-UNDO.
        DEF VAR vJ       AS INT64  NO-UNDO.
        DEF BUFFER bcode FOR code.
        DEF BUFFER bloan-int FOR loan-int.
        DEF BUFFER bloan FOR loan.

        IF NOT GetCodeBuff("НБКИ_КодОпер", "ПогашОД", BUFFER bcode) THEN
             UNDO, THROW NEW Progress.Lang.AppError( "в классификаторе нбки_кодопер").
        /* список операций, которые нужно сложить */
        oAmt = 0.
        DEF VAR vdlp AS DATE NO-UNDO.
        vdlp = ?. /*vDateLastPayment.*/
        RUN GetDateByIntVar(loan.contract,
                          loan.cont-code,
                          iDateRep,
                           "ПогашОД",
                          OUTPUT vdlp).
        IF bcode.misc[1] > "" AND vdlp NE ? THEN
        DO vI = 1 TO NUM-ENTRIES(bcode.misc[1]):
            RUN GetSummUnv_(loan.contract, loan.cont-code,
                    INT64(ENTRY(vI,bcode.misc[1])),
                    vdlp, "GetLastSummOper", OUTPUT vAmtCur, OUTPUT vAmtDb, OUTPUT vAmtCr).
        oAmt = oAmt + vAmtCur.
        END.
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("LastPayment", XmlDec(oAmt)). 
        
        /* поле .cred_sum_limit.. текущий неиспользованный лимит.
           заполняется для кредитов в форме кредитной линии и овердрафт,
           если выданный кредит предполагает выдачу */
        RUN GetSummByIntVar(BUFFER loan,
        iDateRep, "НеиспЛим", OUTPUT oAmt).
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("CurLimit", XmlDec(oAmt)). 
       
        /* 34. cумма просрочки по основному долгу. */
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("PastDueNoExtra",
        XmlDec( vPastDueNoExtra)).
       
            /* 37. текущая задолженность по основному долгу (од + пр.од) */
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("AmountOutstandingNoExtra",
        XmlDec( vAmountOutstandingNoExtra)).

        /* 38. дата последней выплаты по основному долгу */
        DEF VAR vDateLastPaymentNoExtra AS DATE NO-UNDO.
        RUN GetDateByIntVar(loan.contract,
                       loan.cont-code,
                       iDateRep,
                       "ПогашОд",
                       OUTPUT vDateLastPaymentNoExtra).
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("DateLastPaymentNoExtra",
        XmlDate( vDateLastPaymentNoExtra)).
/*        
        /* 40. флаг страховки кредита */
        DEF BUFFER iloan FOR loan.
        FIND FIRST iloan
         WHERE iloan.parent-contract EQ loan.contract
           AND iloan.parent-cont-code EQ loan.cont-code
           AND iloan.class-code  = "insurance"
           AND iloan.open-date <= iDateRep
           AND iloan.end-date >= iDateRep
           AND (iloan.close-date EQ ? OR iloan.close-date >= iDateRep) NO-ERROR.
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("InsuredFlag",(IF AVAIL iloan THEN "1" ELSE "0")).

        /* InsuredAmount сумма страховки кредита */
        IF AVAIL iloan THEN DO:
          DEF BUFFER iterm-obl FOR term-obl.
          FIND FIRST iterm-obl WHERE 
            iterm-obl.idnt EQ 1 AND 
            iterm-obl.cont-code EQ iloan.cont-code AND 
            iterm-obl.contract EQ 'СТРАХ' NO-ERROR.
          IF AVAIL(iterm-obl) THEN DO:
            lOK = hSAXWriter:WRITE-DATA-ELEMENT("InsuredAmount", XmlDec(iterm-obl.amt-rub)).
          END.
        END.
*/
                /* 42. MissedPaymentDate
           дата последнего пропущенного платежа. в случае
           отсутствия хотя бы одного пропущенного платежа
           заполняется датой .01.02.1900. */
        DEF VAR vListOper  AS CHAR INIT "ЗадолжОД,ЗадолжПР" NO-UNDO.
        DEF VAR vListP   AS CHAR INIT "7,10,48" NO-UNDO.
        DEF VAR vDateP   AS DATE NO-UNDO.
        DEF BUFFER xloan-int FOR loan-int.
        /*
        IF vListP EQ ? THEN DO ON ERROR UNDO,THROW:
        vListP = "".
        * все эти параметры активные *
        DO vJ = 1 TO NUM-ENTRIES( vListOper):
            IF NOT GetCodeBuff("НБКИ_КодОпер", ENTRY(vJ, vListOper), BUFFER bcode) THEN
             UNDO, THROW NEW Progress.Lang.AppError( " в классификаторе НБКИ_КодОпер").
            DO vI = 1 TO NUM-ENTRIES(bcode.misc[3]):
            vListP = vListP + (IF LENGTH(vListP)>0 THEN "," ELSE "") + ENTRY(vI, bcode.misc[3]).
            END.
        END.
        END.*/
        vDateP = DATE( 2, 1, 1900).

        /* по основному договору */
        FOR EACH bloan-int
             WHERE (bloan-int.contract  EQ loan.contract
                      AND bloan-int.cont-code EQ loan.cont-code
                      AND bloan-int.mdate     LE iDateRep)
               AND CAN-DO(vListP, STRING(bloan-int.id-d))
        NO-LOCK BY bloan-int.mdate DESC:
        /* есть зачисление просроч/%, 
           но ведь это мог быть перенос с в.б. на баланс */
        IF bloan-int.id-d = 10 AND bloan-int.id-k <> 33 THEN NEXT.
        vDateP = bloan-int.mdate.
        LEAVE.
        END.

        /* теперь транши */
        FOR EACH bloan-int
             WHERE (bloan-int.contract  EQ loan.contract
                      AND bloan-int.cont-code BEGINS (loan.cont-code + " ")
                      AND bloan-int.mdate     LE iDateRep)
               AND CAN-DO(vListP, STRING(bloan-int.id-d))
        NO-LOCK BY bloan-int.mdate DESC:
        /* есть зачисление просроч/%, 
           но ведь это мог быть перенос с в.б. на баланс */
        IF bloan-int.id-d = 10 AND bloan-int.id-k <> 33 THEN NEXT.
        ASSIGN
            vDateP = bloan-int.mdate WHEN vDateP < bloan-int.mdate.
        LEAVE.
        END.
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("MissedPaymentDate", XmlDate( vDateP)).

        /*{n-mess.i "STRING(ij) + ' ' + '43'"}*/
        /* 43. баланс по основному долгу. бщая сумма, заплаченная заемщиком по
           кредиту по основному долгу.*/
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("BalanceNoExtra",
        XmlDec(ListGetSummByIntVar(BUFFER loan, iDateRep, "погашод"))).
        
        /*{n-mess.i "STRING(ij) + ' ' + '44'"}*/
        /* 44. дата возникновения просрочки по основному долгу.
           если текущая просрочка по основному долгу отсутствует,
           заполняется датой 01.02.1900. */
        /* а надо еще учитывать транши !!!*/
        DEF VAR vCurrentOverdueNoExtraDate AS DATE NO-UNDO.
        DEF VAR vPrsDolgDays AS INT NO-UNDO.
        IF vPastDueNoExtra > 0 THEN DO:
        vPrsDolgDays = LN_GetPrsDolgDays (loan.contract, loan.cont-code, iDateRep).
        vCurrentOverdueNoExtraDate = iDateRep - vPrsDolgDays.
        END. ELSE DO:
        vPrsDolgDays = 0.
        vCurrentOverdueNoExtraDate = DATE( 2, 1, 1900).
        END.
        /*
        vPrsDolgDays = IF vPastDue EQ 0 THEN 0 ELSE LN_GetPrsDolgDays (loan.contract, loan.cont-code, iDateRep).
        vCurrentOverdueNoExtraDate = IF vPrsDolgDays > 0 THEN iDateRep - vPrsDolgDays ELSE DATE( 2, 1, 1900).
        */
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("CurrentOverdueNoExtraDate", 
        XmlDate( vCurrentOverdueNoExtraDate)).
        
        /*{n-mess.i "STRING(ij) + ' ' + '45'"}*/
        /* 45. следующий платеж по основному долгу */
        /* Определяем сумму с учетом траншей */
        DEF VAR vNextPaymentNoExtra AS DEC NO-UNDO.
        DEF VAR vNextPaymentNoExtraDate AS DATE NO-UNDO.
        /*DEF BUFFER bloan FOR loan.*/
        DEF VAR dr AS DATE NO-UNDO.
        dr = iDateRep.
        DO WHILE TRUE ON ERROR UNDO, THROW:
        RUN GetFirstAmtUnv(loan.contract,
                      loan.cont-code,
                      3,
                      dr,
                      "BKINextPayment1",
                      OUTPUT vNextPaymentNoExtra,
                      OUTPUT vNextPaymentNoExtraDate).
            IF vNextPaymentNoExtraDate NE ? AND vNextPaymentNoExtra EQ 0 THEN dr = vNextPaymentNoExtraDate.
            ELSE LEAVE.
            END.
/* put unformatted loan.cont-code + " " + string(iDateRep) + " " + string(vNextPaymentNoExtraDate) + " " + string(vNextPaymentNoExtra) skip. */

        IF FGetSetting("НБКИ","TR14","") EQ "Нет" THEN DO:
          vNextPaymentNoExtra = BKIAmountOutst(BUFFER loan,
                            INPUT  vNextPaymentNoExtraDate).
        END.
        vNextPaymentNoExtra = MIN( vNextPaymentNoExtra, vAmountOutstandingNoExtra).
        IF vNextPaymentNoExtra <= 0 THEN vNextPaymentNoExtraDate = DATE( 2, 1, 1900).
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("NextPaymentNoExtra", 
        XmlDec( vNextPaymentNoExtra)).

        /*{n-mess.i "STRING(ij) + ' ' + '46'"}*/
        /* 46. */
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("NextPaymentNoExtraDate",
        XmlDate( vNextPaymentNoExtraDate)).
        
                /* 47. сумма фактического исполнения обязательств заемщика в
           неполном размере (последний платеж)
           сумма последнего платежа. в текущую сумму должны входить:
           основной долг, %, комиссии и др. в случае отсутствия платежей
           по договору заполняется .0.
           - это просто сумма последнего платежа который фактически
           платил заемщик.
        */
        IF NOT GetCodeBuff("нбки_кодопер", "погашобщ", BUFFER bcode) THEN
             UNDO, THROW NEW Progress.Lang.AppError( "в классификаторе нбки_кодопер").
        /* список операций, которые нужно сложить */
        oAmt = 0.
        IF bcode.misc[1] > "" THEN
        DO vI = 1 TO NUM-ENTRIES(bcode.misc[1]):
            RUN GetSummUnv_(loan.contract, loan.cont-code,
                    INT64(ENTRY(vI,bcode.misc[1])),
                    /*iDateRep */ vDateLastPayment, "GetLastSummOper", OUTPUT vAmtCur, OUTPUT vAmtDb, OUTPUT vAmtCr).
        oAmt = oAmt + vAmtCur.
        END.
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("TotalLastPayment", XmlDec( oAmt)).
        
         /* 48. дата возникновения текущей просрочки. если
           текущая просрочка отсутствует, заполняется датой .01.02.1900..*/
        DEF VAR vCurrentOverdueDate AS DATE NO-UNDO.
        DEF VAR vPrsProcDays AS INT NO-UNDO.
        DEF VAR vPrsDays AS INT NO-UNDO.
        IF vPastDue > 0 THEN DO:
        IF LN_GetParams (loan.contract,
                         loan.cont-code,
                         "10,48,210,248",
                         iDateRep) > 0 THEN DO ON ERROR UNDO, THROW:
            vPrsProcDays = LN_GetPrsProcDays ( loan.contract, loan.cont-code, iDateRep).
        END. ELSE DO ON ERROR UNDO, THROW:
            vPrsProcDays = 0.
        END.
        vPrsDays = MAX( vPrsProcDays, vPrsDolgDays).
        vCurrentOverdueDate = iDateRep - vPrsDays.
        END. ELSE DO:
        vPrsProcDays = 0.
        vPrsDays = 0.
        vCurrentOverdueDate = DATE( 2, 1, 1900).
        END.

        
        /*
        vPrsProcDays = IF vPastDue EQ 0 THEN 0 ELSE LN_GetPrsProcDays ( loan.contract, loan.cont-code, iDateRep).
        vPrsDays = MAX( vPrsProcDays, vPrsDolgDays).
        
        vCurrentOverdueDate = IF vPrsDays > 0 THEN iDateRep - vPrsDays ELSE DATE( 2, 1, 1900).
        */
        
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("CurrentOverdueDate", 
        XmlDate(vCurrentOverdueDate)).

        /*{n-mess.i "STRING(ij) + ' ' + '49'"}*/
        /* 49. поле "ta_cred_date_nextpayout". дата следующего платежа.
           в случае отсутствия следующего платежа (к примеру, текущая
           транзакция, закрывает кредит) заполняется датой. 01.02.1900.*/
        DEF VAR vNextPaymentNoExtraPrc AS DEC NO-UNDO.
        DEF VAR vNextPaymentNoExtraDatePrc AS DATE NO-UNDO.
        DEF VAR vDate2 AS DATE NO-UNDO.
        RUN GetFirstAmtUnv(loan.contract,
                      loan.cont-code,
                      1,
                      iDateRep,
                      "BKINextPayment1",
                      OUTPUT vNextPaymentNoExtraPrc,
                      OUTPUT vNextPaymentNoExtraDatePrc).
        vDate2 = vNextPaymentNoExtraDate.
        IF vDate2 EQ ? OR vNextPaymentNoExtraDatePrc < vNextPaymentNoExtraDate
         THEN vDate2 = vNextPaymentNoExtraDatePrc.
        IF vNextPayment <= 0 THEN vDate2 = DATE( 2, 1, 1900).
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("NextPaymentDate",
        XmlDate( vDate2)).
        
        /* 89 PaymentLimit Поле Credit Limit (Лимит Кредитования). */
        
        IF loan.cont-type = 'Течение' THEN DO:
            FIND LAST term-obl WHERE term-obl.contract = loan.contract
            AND term-obl.cont-code = loan.cont-code
            AND term-obl.idnt = 2
            AND term-obl.nn = 0 
            AND term-obl.end-date >= loan.open-date
            AND term-obl.end-date <= iDateRep
            NO-LOCK NO-ERROR.
            IF AVAIL term-obl THEN DO:
                 lOK = hSAXWriter:WRITE-DATA-ELEMENT("PaymentLimit", XmlDec(term-obl.amt-rub)).
            END.
        END.
        
        /* 90. FinanceType тип финансирования */
        DEF VAR vFinanceType AS CHAR NO-UNDO.
        IF vCollateral <> '0' THEN vFinanceType = '01'.
            ELSE vFinanceType = '02'.

        FIND FIRST loan-acct
         WHERE loan-acct.contract EQ loan.contract
           AND loan-acct.cont-code EQ loan.cont-code
           AND loan-acct.acct-type EQ 'кредлин'
           NO-LOCK NO-ERROR.
        IF AVAIL loan-acct THEN vFinanceType = '21'.
        
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("FinanceType",
        vFinanceType).
        
        
        /* 91 Поле Purpose Of Finance (Цель кредитования).  */
        DEF VAR vPF as CHAR NO-UNDO. 
        DEF VAR vPurposeOfFinance as CHAR NO-UNDO.
        vPF = GetXattrValueEx( "loan", Loan.contract + "," + Loan.cont-code, "ЦельКред", "").
            vPurposeOfFinance = '99'.
            CASE vPF:
                WHEN "Автомобиль" THEN vPurposeOfFinance = '01'.
            END CASE.
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("PurposeOfFinance",vPurposeOfFinance).
        
        /* 92 Поле Account Payment Status(Статус выплат по счету).  */
        DEF VAR vAccPaymentStatus as CHAR NO-UNDO.
        vAccPaymentStatus = '0'.
        IF vPrsDays > 0 AND vPrsDays < 31 THEN
            vAccPaymentStatus = 'A'. 
        IF vPrsDays > 30 AND vPrsDays < 61 THEN
            vAccPaymentStatus = '1'.   
        IF vPrsDays > 60 AND vPrsDays < 91 THEN
            vAccPaymentStatus = '2'. 
        IF vPrsDays > 90 AND vPrsDays < 121 THEN
            vAccPaymentStatus = '3'. 
        IF vPrsDays > 120 AND vPrsDays < 151 THEN
            vAccPaymentStatus = '4'.                  
        IF vPrsDays > 150 AND vPrsDays < 181 THEN
            vAccPaymentStatus = '5'.                  
        IF vPrsDays > 180 THEN
            vAccPaymentStatus = '6'.                  
                 

        vAccPaymentStatus = BKIMOP2( loan.contract, loan.cont-code, iDateRep).      
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("AccPaymentStatus",vAccPaymentStatus).

        /* 93 Поле Interest rate (Процентная ставка, числовое значение годовой процентной ставки, указанной в договоре)  */
        DEF VAR vInterestRate as DECIMAL NO-UNDO.
        vInterestRate = 0.
        FIND LAST comm-rate WHERE comm-rate.kau = Loan.contract + "," + Loan.cont-code
            AND comm-rate.commission = '%Кред' 
            AND comm-rate.since <= iDateRep NO-LOCK NO-ERROR.
        IF AVAIL comm-rate THEN vInterestRate = comm-rate.rate-comm.
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("InterestRate", XmlDec(vInterestRate)).
        
        /* 94 Поле Reason for closure (Причина закрытия). */
	IF oAccRat = '14' THEN lOK = hSAXWriter:WRITE-DATA-ELEMENT("ReasonForClosure",'19').
        ELSE lOK = hSAXWriter:WRITE-DATA-ELEMENT("ReasonForClosure",'99').
        
        
        /* 24 Уникальный номер кредитной заявки Обязательно для ФЛ (для осуществления связки с секцией InfoPart)ЭКС: /fch/info/credit/applicationid */ 
        DEF VAR vAppNum as CHAR NO-UNDO.
        vAppNum = GetXattrValueEx( "loan", Loan.contract + "," + Loan.cont-code, "PLDealID", "").
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("ApplicationNumber", vAppNum).
        
        /* 25 Дата и время кредитной заявки Обязательно для ФЛ ЭКС: /fch/info/credit/applicationdate */ 
        DEF VAR vAppDate as CHAR NO-UNDO.
        vAppDate = GetXattrValueEx( "loan", Loan.contract + "," + Loan.cont-code, "PLDealDate", "").
        IF vAppDate <> '' THEN DO:
        	/* в ДР PLDealDate выгружается datetime (DD/MM/YYYY HH:MM:SS.MMM), 
        	   выгружаем в CreReg в нужном формате (DD.MM.YYYY HH:MM:SS)      */
        /*	vAppDate = REPLACE(ENTRY(1,vAppDate,'.'),'/','.'). */

        	IF length(vAppDate) > 19 then vAppDate = substring(vAppDate,1,19).
        	vAppDate = REPLACE(vAppDate,'/','.').
            lOK = hSAXWriter:WRITE-DATA-ELEMENT("ApplicationDate", vAppDate).
		END.         
  
  
        /* TwoConsPayMissed    I   C   Информация об отсутствии двух и более подряд платежей в течение 120 календарных дней
         с даты наступления срока исполнения обязательства по договору займа (кредита)
        Код Информация об отсутствии двух и более подряд платежей в течение 120 календарных дней с даты наступления срока исполнения обязательства
        0   Не было двух подряд пропущенных платежей в течение 120 календарных дней с даты наступления срока выплаты первого платежа 
        1   Было два подряд пропущенных платежа в течение 120 календарных дней с даты наступления срока выплаты первого платежа
        2   Время исполнения обязательств по договору займа (кредита) еще не наступило
        3   Не известно
        Обязательно для ФЛ. По умолчанию считается равным 3.
        НБКИ: IP(17)
        */
        DEF BUFFER bufLoan-acct FOR loan-acct.
        DEF VAR iTwoConsPayMissed AS INT NO-UNDO.
        DEF VAR i AS INT NO-UNDO.
        DEF VAR dStartDate AS DATE NO-UNDO.
        iTwoConsPayMissed = 3.
        dStartDate = ?.
        i = 0.

        FOR EACH term-obl WHERE term-obl.contract = loan.contract
            AND term-obl.cont-code = loan.cont-code
            AND term-obl.idnt = 1
            AND term-obl.nn = 1 NO-LOCK BY term-obl.end-date:
            dStartDate = term-obl.end-date.
            LEAVE.
        END.
        
        IF dStartDate <> ? THEN DO: 
            IF dStartDate >= iDateRep THEN DO: 
            FIND FIRST loan-acct WHERE loan-acct.contract = loan.contract 
                AND loan-acct.cont-code = loan.cont-code
                AND loan-acct.acct-type = 'КредПр' NO-LOCK NO-ERROR.
                IF AVAIL loan-acct THEN DO:
                    FIND FIRST bufloan-acct WHERE bufloan-acct.contract = loan.contract 
                    AND bufloan-acct.cont-code = loan.cont-code
                    AND bufloan-acct.acct-type = 'Кредит' NO-LOCK NO-ERROR.
                    IF AVAIL bufloan-acct THEN DO:
                        FOR EACH op-entry WHERE op-entry.acct-db = loan-acct.acct
                            AND op-entry.acct-cr = bufLoan-acct.acct 
                            AND op-entry.op-status >= "√"
                            AND op-entry.op-date >= dStartDate
                            AND op-entry.op-date <= (dStartDate + 120) NO-LOCK:
                        i = i + 1.
                        END.
                        IF i >= 2 THEN iTwoConsPayMissed = 1.
                        ELSE iTwoConsPayMissed = 0.
                    END.
                END.
            END.
            ELSE iTwoConsPayMissed = 2.
        END. /* IF dStartDate <> ? THEN DO:  */
        
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("TwoConsPayMissed", STRING(iTwoConsPayMissed)).

        /* 27. 1 - Признак погашения кредита в полном объеме.  Обязательно для ФЛ, если кредит погашен в полном объеме.  */
        IF loan.close-date <> ? THEN DO:
            lOK = hSAXWriter:WRITE-DATA-ELEMENT("FullyPaidOff", '1').
        END.
        
        /* 28. TR(37) Полная стоимость кредита (Overall value of credit) с точностью до третьего знака после */
        DEF VAR vPSK as CHAR NO-UNDO.
        vPSK = GetXattrValueEx( "loan", Loan.contract + "," + Loan.cont-code, "ПСК", "").
        IF vPSK = "" THEN vPSK = GetXattrValueEx( "loan", Loan.contract + "," + Loan.cont-code, "ЭПС", "").
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("TotalCredCost", vPSK).
        
        /* 30. Номер договора займа, ОКБ: Legal Account Number */ 
        lOK = hSAXWriter:WRITE-DATA-ELEMENT("Contract", loan.doc-ref).
         
        strDatePoruch = GetXattrValueEx( "loan", Loan.contract + "," + Loan.cont-code, "datePoruch", "").
        IF strDatePoruch <> '' THEN datePoruch = DATE(strDatePoruch).
            ELSE datePoruch = ?.

        
        /* 31. TR(26) Флаг о наличии поручителя (Guarantor indicator) Обязателен по заемщику. По поручителю и принципалу игнорируется (в бюро не передается) */
        DEF VAR iGuarant AS INT64 NO-UNDO.
        DEF VAR strSurrTerm AS CHAR NO-UNDO.
        DEF BUFFER bsigns FOR signs.
        iGuarant = 0.
    IF vAccRelation <> '5' THEN DO:
        FOR EACH signs WHERE signs.file-name = 'term-obl' 
            AND signs.surrogate BEGINS Loan.contract + "," + Loan.cont-code + ',5'
            AND signs.code = 'видоб'
            AND signs.xattr-value = 'Поручит' NO-LOCK: 
            strSurrTerm = signs.surrogate.
            IF iGuarant = 0 THEN
                lOK = hSAXWriter:WRITE-DATA-ELEMENT("GuaranteeIndicator", '1'). /* 28_12_2015 */
        
            FIND FIRST bsigns WHERE bsigns.file-name = 'term-obl' 
                AND bsigns.surrogate = strSurrTerm
                AND bsigns.code = 'номдогоб' NO-LOCK NO-ERROR.
            IF AVAIL signs AND bGuar THEN DO:
                lOK = hSAXWriter:WRITE-DATA-ELEMENT("GuaranteeNumber", bsigns.xattr-value).
            END.
            FIND FIRST term-obl WHERE term-obl.contract = ENTRY(1,strSurrTerm)
                AND term-obl.cont-code = ENTRY(2,strSurrTerm)
                AND term-obl.idnt = INT(ENTRY(3,strSurrTerm))
                AND term-obl.end-date = DATE(ENTRY(4,strSurrTerm))
                AND term-obl.nn = INT(ENTRY(5,strSurrTerm))
                NO-LOCK NO-ERROR.
            IF AVAIL term-obl THEN DO:
                IF NOT bGuar AND (dPoruc = ? OR (datePoruch <> ? AND datePoruch < iDateRep) ) THEN DO:
                CREATE ttGuarant.
                ASSIGN
                    ttGuarant.cont-code = term-obl.cont-code
                    ttGuarant.cust-id   = term-obl.fop
                    ttGuarant.cust-cat  = term-obl.symbol
                    ttGuarant.loanUpd   = iDateRep
                    ttGuarant.recStatus = 0
                    .
                END.
                IF dLimit > term-obl.amt-rub THEN iGuarant = 2. ELSE iGuarant = 1.
                IF bGuar THEN DO:
                    lOK = hSAXWriter:WRITE-DATA-ELEMENT("GuaranteeVolume", STRING(iGuarant)).
                    lOK = hSAXWriter:WRITE-DATA-ELEMENT("GuaranteeSum", XmlDec(term-obl.amt-rub)).
                    IF term-obl.currency <> '' THEN DO:
                    CASE term-obl.currency:
                        WHEN '398' THEN 
                            cCurrCol = 'KZT'.
                        WHEN '840' THEN 
                            cCurrCol = 'USD'.
                        WHEN '978' THEN 
                            cCurrCol = 'EUR'.
                    END CASE.                        
                        lOK = hSAXWriter:WRITE-DATA-ELEMENT("GuaranteeSumCurrency", cCurrCol).
                        /* lOK = hSAXWriter:WRITE-DATA-ELEMENT("GuaranteeSumCurrency", term-obl.currency). */
                    END.
                    lOK = hSAXWriter:WRITE-DATA-ELEMENT("GuaranteeDate", XmlDate(term-obl.fop-date)).
                    lOK = hSAXWriter:WRITE-DATA-ELEMENT("GuaranteeEndDate", XmlDate(term-obl.end-date)).
                END.
            END.
            iGuarant = 1.
          /*   LEAVE. */
        END.
    END.
        IF iGuarant = 0 THEN
            lOK = hSAXWriter:WRITE-DATA-ELEMENT("GuaranteeIndicator", '0').
/*
        ELSE 
            lOK = hSAXWriter:WRITE-DATA-ELEMENT("GuaranteeIndicator", '1').
*/           
       
	    /* сохраняем информацию о выгрузке *
	    def var mPacketID as int64 no-undo.
	    def var mTable as char init 'loan' no-undo.
	    def var mKind as char no-undo.
	    mKind = "XMLCliUpdAKI".
	    	    
	    {pack-crt.i
    	     &Packet      = Packet
    	     &PacketID    = mPacketID
    	     &SeanceID    = 0
    	     &MailUserID  = 0
    	     &State       = "'СОЗД'"
    	     &AbonentID   = 0
    	     &Kind        = mKind
    	     &Format      = mKind
	     &ClassCode   = "'Packet'"
	     &ParentID    = 0
	    }
          *
          RUN PacketCreate (Seance.SeanceID,
                        0,
                        Mail-User.Mail-User-num,
                        mKind,
                        OUTPUT mPacketID) NO-ERROR.
          *
          RUN PacketCreateLink(mPacketID,  
                           mTable, 
                           STRING(loan.contract + ',' + loan.cont-code), 
                           mKind).

          RUN PacketTextClear(mPacketID).
          def var i_ as int64 no-undo.
	  def var j as int64 no-undo.
          def var k as int64 no-undo.
          def var a as char init 'text' NO-UNDO.
          def var mResult as char NO-UNDO.
          def var mBuf as char no-undo.
          mResult = ''.
          j=1.
          k=32000.
          do i_ = 1 to TRUNCATE(length(a) / k,0) + 1:
             mBuf = substr(a,j,k).
             RUN PacketTextKeep (mPacketID,
                             mBuf,
                             INPUT-OUTPUT mResult).
             j = j + k.
          end.
          RUN PacketTextSave (mPacketID, mResult).
*/

		DEF VAR bCollaterals AS LOGICAL NO-UNDO.
        bCollaterals = FALSE.
                
        FOR EACH signs WHERE signs.file-name = 'term-obl' 
            AND signs.surrogate BEGINS Loan.contract + "," + loan.cont-code + ',5'
            AND signs.code = 'виддогоб'
            AND CAN-DO('КредЦБум,КредОб',signs.xattr-value) NO-LOCK: 
            strSurrTerm = signs.surrogate.
            IF bCollaterals = FALSE THEN DO:
                lOK = hSAXWriter:START-ELEMENT("TradeCollaterals").
                bCollaterals = TRUE.
            END.
            
            lOK = hSAXWriter:START-ELEMENT("TradeCollateral").
            
            FIND FIRST bsigns WHERE bsigns.file-name = 'term-obl' 
                AND bsigns.surrogate = strSurrTerm
                AND bsigns.code = 'НомДогОб' NO-LOCK NO-ERROR.
            IF AVAIL bsigns THEN DO:
                lOK = hSAXWriter:WRITE-DATA-ELEMENT("CollateralContract", TRIM(bsigns.xattr-value)).   
            END.
            
            FIND FIRST term-obl WHERE term-obl.contract = ENTRY(1,strSurrTerm)
                AND term-obl.cont-code = ENTRY(2,strSurrTerm)
                AND term-obl.idnt = INT(ENTRY(3,strSurrTerm))
                AND term-obl.end-date = DATE(ENTRY(4,strSurrTerm))
                AND term-obl.nn = INT(ENTRY(5,strSurrTerm))
                NO-LOCK NO-ERROR.
            IF AVAIL term-obl THEN DO:
                lOK = hSAXWriter:WRITE-DATA-ELEMENT("CollateralDate", XmlDate(term-obl.fop-date)).
                lOK = hSAXWriter:WRITE-DATA-ELEMENT("CollateralEndDate", XmlDate(term-obl.end-date)).
                FIND FIRST bsigns WHERE bsigns.file-name = 'term-obl' 
                    AND bsigns.surrogate = strSurrTerm
                    AND bsigns.code = 'видоб' NO-LOCK NO-ERROR.
                IF AVAIL bsigns THEN DO:
                    lOK = hSAXWriter:WRITE-DATA-ELEMENT("CollateralType", GetCodeZal(bsigns.xattr-value)).   
                END.                
                lOK = hSAXWriter:WRITE-DATA-ELEMENT("CollateralAssessment", XmlDec(term-obl.amt-rub)).
                IF term-obl.currency <> '' THEN  DO:
                    CASE term-obl.currency:
                        WHEN '398' THEN 
                            cCurrCol = 'KZT'.
                        WHEN '840' THEN 
                            cCurrCol = 'USD'.
                        WHEN '978' THEN 
                            cCurrCol = 'EUR'.
                    END CASE.                        
                    lOK = hSAXWriter:WRITE-DATA-ELEMENT("CollateralCurrency", cCurrCol).
                END.
                lOK = hSAXWriter:WRITE-DATA-ELEMENT("CollateralAssessmentDate", XmlDate(term-obl.fop-date)).
                IF term-obl.symbol = 'Ч' THEN DO:
                    FIND FIRST person WHERE person.person-id = term-obl.fop NO-LOCK NO-ERROR.
                    IF AVAIL person THEN
                        lOK = hSAXWriter:WRITE-DATA-ELEMENT("CollateralPledgorName", person.name-last + ' ' + person.first-names).
                END.
                ELSE IF term-obl.symbol = 'Ю' THEN DO:
                    FIND FIRST cust-corp WHERE cust-corp.cust-id = term-obl.fop NO-LOCK NO-ERROR.
                    IF AVAIL cust-corp THEN
                        lOK = hSAXWriter:WRITE-DATA-ELEMENT("CollateralPledgorName", cust-corp.name-short).
                END.
                FIND FIRST bsigns WHERE bsigns.file-name = 'term-obl' 
                    AND bsigns.surrogate = strSurrTerm
                    AND bsigns.code = 'TCVIN' NO-LOCK NO-ERROR.
                IF AVAIL bsigns AND bsigns.xattr-value <> 'отсутствует' THEN DO:
                    lOK = hSAXWriter:WRITE-DATA-ELEMENT("CollateralID", bsigns.xattr-value).   
                END.                
                FIND FIRST bsigns WHERE bsigns.file-name = 'term-obl' 
                    AND bsigns.surrogate = strSurrTerm
                    AND bsigns.code = 'местонахождение' NO-LOCK NO-ERROR.
                IF AVAIL bsigns AND bsigns.xattr-value <> '' THEN DO:
                    lOK = hSAXWriter:WRITE-DATA-ELEMENT("CollateralAddress", bsigns.xattr-value).   
                END. 
                FIND FIRST bsigns WHERE bsigns.file-name = 'term-obl' 
                    AND bsigns.surrogate = strSurrTerm
                    AND bsigns.code = 'описание' NO-LOCK NO-ERROR.
                IF AVAIL bsigns AND bsigns.xattr-value <> ? AND bsigns.xattr-value <> '' THEN DO:
                    lOK = hSAXWriter:WRITE-DATA-ELEMENT("CollateralDescription", SUBSTRING(bsigns.xattr-value,1,150)).   
                END. 
            END.
            lOK = hSAXWriter:END-ELEMENT("TradeCollateral").
        END.
            
        IF bCollaterals THEN DO:    
            lOK = hSAXWriter:END-ELEMENT("TradeCollaterals").
        END.
        
        FINALLY:
        lOK = hSAXWriter:END-ELEMENT("Trade").
        
	    END.
    END.
END.
  FINALLY:
        lOK = hSAXWriter:END-ELEMENT("Trade").
        
	    END.
    END.
END.
