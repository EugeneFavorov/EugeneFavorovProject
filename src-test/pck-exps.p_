/*
               Банковская интегрированная система БИСквит
    Copyright: (C) 1992-2014 ЗАО "Банковские информационные системы"
     Filename: PCK-EXPS.P
      Comment: Создает  из множества (SET) транспортных объектов итоговые
               сообщения XML
               Является методом (код EXPORT) класса, унаследованого от Packet
   Parameters: iClass      - код класса
               iInstance   - содержимое класса iClass
         Uses:
      Used BY:
      Created: 30.04.2005 NIK
     Modified: 17.07.2006 NIK Создание "головного" сообщения
     Modified: 18.08.2006 NIK Добавлен  параметр $SortBy
     Modified:
*/
{globals.i}

DEFINE INPUT PARAMETER iClass       AS CHAR     NO-UNDO.
DEFINE INPUT PARAMETER iInstance    AS handle   NO-UNDO.

{form.def}
{g-trans.equ}
{exchange.equ}

{intrface.get xclass}
{intrface.get strng}
{intrface.get tmess}

{intrface.get pbase}
{intrface.get trans}

DEFINE BUFFER bCode     FOR Code.
DEFINE VAR mFlagSet     AS LOGICAL INIT ? NO-UNDO.
DEFINE VAR hPack        AS handle         NO-UNDO.
DEFINE VAR hOBJ         AS handle         NO-UNDO.
DEFINE VAR hObjQuery    AS handle         NO-UNDO.

DEFINE VAR mKindLst     AS CHAR           NO-UNDO.
DEFINE VAR mKindMain    AS CHAR           NO-UNDO.
DEFINE VAR mKindObj     AS CHAR           NO-UNDO.

DEFINE VAR hMain        AS handle         NO-UNDO.
DEFINE VAR mSeanceID    AS INT64        NO-UNDO.
DEFINE VAR mParentID    AS INT64        NO-UNDO.
DEFINE VAR mOpDate      AS DATE           NO-UNDO.
DEFINE VAR mKeepMode    AS CHAR           NO-UNDO.
DEFINE VAR mMainFormat  AS CHAR           NO-UNDO.
DEFINE VAR mSortBy      AS CHAR           NO-UNDO.
DEFINE VAR mSendREF     AS CHAR           NO-UNDO.
DEFINE VAR mFileName    AS CHAR           NO-UNDO.
DEFINE VAR mSurrogate   AS CHAR           NO-UNDO.
DEFINE VAR mRoleMain    AS CHAR           NO-UNDO.


DEFINE VAR mProcCrt     AS CHAR           NO-UNDO.
DEFINE VAR mHndlCrt     AS HANDLE         NO-UNDO.
DEFINE VAR mFake        AS CHAR           NO-UNDO.
DEFINE VAR mCount       AS INT64        NO-UNDO.

DEFINE VAR mXMLInit     AS CHAR     NO-UNDO.
DEFINE VAR mProcIni     AS CHAR     NO-UNDO.
DEFINE VAR mProcDwn     AS CHAR     NO-UNDO.

DEFINE VAR mBreak       AS CHAR     NO-UNDO.
DEFINE VAR hBreak       AS HANDLE   NO-UNDO.
DEFINE VARIABLE mStr__ID   AS CHAR     NO-UNDO.
DEFINE VAR hPackBrk     AS HANDLE   NO-UNDO.
DEFINE VAR hAllDoc      AS handle      NO-UNDO.
DEFINE VAR mCodePage    AS CHAR        NO-UNDO.


DEFINE VARIABLE mWhere      AS CHARACTER   NO-UNDO.
DEFINE VARIABLE mExtraWhere AS CHARACTER   NO-UNDO.

{profile P09}

{intrface.get exch}
{intrface.get pack}
{intrface.get rfrnc}
/*============================================================================*/
MAIN:
DO ON ERROR UNDO MAIN, RETRY MAIN:
   {do-retry.i MAIN}

   RUN ObjectValueInit.

   ASSIGN
      hPack     = iInstance:default-buffer-handle
      mKindLst  = hPack:buffer-field("Kind"):buffer-value
      mXMLInit    = TRNSettingValue("", "$XMLSessionInit","YES")
      mKeepMode   = TRNSettingValue("", "XMLKeepMode",    "BASE")
      mSortBy     = TRNSettingValue("", "$SortBy",        "")
      mExtraWhere = TRNSettingValue("", "Where",          "") /* доп. условие */
      mBreak      = GetAttrValue2(GetBaseOpKind(),GetBaseTemplate(),"$UsBreak") 
   NO-ERROR. {&ON-ERROR}

   ASSIGN
      mKindObj  = ENTRY(1,mKindLst)
      mKindMain = ENTRY(2,mKindLst)             WHEN NUM-ENTRIES(mKindLst) EQ 2
      hObj      = ObjectValueHandle(mKindObj)
      hMain     = ObjectValueHandle(mKindMain)  WHEN NUM-ENTRIES(mKindLst) EQ 2
      hBreak    = ObjectValueHandle(hObj::ExchMain) WHEN mBreak EQ "YES"
   NO-ERROR. {&ON-ERROR}

/*----------------------------------------------- Определим методы экспорта --*/
   RUN GetExchMethod (INPUT  iClass,
                      INPUT  "",
                      INPUT  "Update",
                      OUTPUT mProcCrt,
                      OUTPUT mHndlCrt).
   IF NOT {assigned mProcCrt}  OR
      mProcCrt EQ {&NO-METHOD} THEN DO:
      RUN Fill-SysMes("","ComnExc42","","%s=" + iClass +
                                        "%s=" + "Update").
      UNDO MAIN, RETRY MAIN.
   END.

   IF mXMLInit EQ "YES" OR
      mXMLInit EQ "ДА"  THEN DO:

      RUN GetClassMethod (INPUT  iClass,
                          INPUT  "Initial",
                          INPUT  "",
                          INPUT  "",
                          OUTPUT mProcIni,
                          OUTPUT mFake).

      RUN GetClassMethod (INPUT  iClass,
                          INPUT  "ShutDown",
                          INPUT  "",
                          INPUT  "",
                          OUTPUT mProcDwn,
                          OUTPUT mFake).

      IF NOT {assigned mProcIni} OR
         NOT {assigned mProcDwn} THEN
         mXMLInit = "".
      ELSE
         mXMLInit = "YES".
   END.

   &IF DEFINED(IS-DEBUG) &THEN
   RUN dbgprint.p ("pck-exps.p","mProcCrt:" + GetNullStr(mProcCrt) +
                               " mProcIni:" + GetNullStr(mProcIni) +
                               " iClass:" + GetNullStr(iClass) +
                               " mProcDwn:" + GetNullStr(mProcDwn)).
   &ENDIF

   IF NOT auto THEN DO:
      mCount = 0.
      PUT screen ROW 24 COL 1 PADR("Создание текстов сообщений",30).
   END.

/*---------------------- Выполним выборку и обработку транспортных объектов --*/
   CREATE widget-pool "PCK-EXPS-P".
   CREATE QUERY  hObjQuery IN widget-pool "PCK-EXPS-P".

   mWhere = "for EACH " + hObj:Name + " WHERE " + hObj:Name + ".__id GT 0".
   IF {assigned mExtraWhere} THEN
      mWhere = mWhere + " AND (" + mExtraWhere + ") ".
   IF {assigned mSortBy} 
      THEN mWhere = mWhere + " BY " + mSortBy.

   hObjQuery:add-buffer(hObj).
   hObjQuery:query-prepare(mWhere).

   &IF DEFINED(IS-DEBUG) &THEN
   RUN dbgprint.p ("pck-exps.p","prepare:" + FormWhereToPrint(hObjQuery:prepare-string)).
   &ENDIF

   hObjQuery:query-open().
   mFlagSet = hObjQuery:get-first(NO-LOCK).

   RUN AddAttr2TableEx IN h_trans ("", 0, -1, "", 0, "ReqType", 
                                      STRING(mFlagSet)) NO-ERROR.


   IF mFlagSet NE YES THEN DO:
      mFlagSet = YES.
      LEAVE MAIN.
   END.
   ELSE
      mFlagSet = ?.

/*--- Выполним инициализацию процесса экспорта (только если есть сообщения) --*/
   IF mXMLInit EQ "YES" THEN DO:
      {exch-run.i &Proc = mProcIni
      } {&ON-ERROR}
   END.

/*------ Создадим головное сообщение (только если есть вложенные сообщения) --*/
   &IF DEFINED(IS-DEBUG) &THEN
   RUN dbgprint.p ("pck-exps.p main","mKindLst:" + mKindLst).
   RUN dbgprint.p ("pck-exps.p main","mKeepMode:" + mKeepMode).
   RUN dbgprint.p ("pck-exps.p main","valid:" + string(valid-handle(hMain))).
   &ENDIF

   IF NUM-ENTRIES(mKindLst) EQ 2       AND
      mKeepMode             EQ "MAIN"  AND
      valid-handle(hMain)              THEN DO:

      ASSIGN
         mMainFormat = hMain:buffer-field("mail-format"):buffer-value
         mSeanceID   = hPack:buffer-field("SeanceID"):buffer-value
      NO-ERROR. {&ON-ERROR}

      IF NOT EXCH-MSGBuff(mMainFormat, BUFFER bCode) THEN UNDO MAIN, RETRY MAIN.

      RUN PacketCreateF (INPUT  mSeanceID,
                         BUFFER bCode,
                         OUTPUT mParentID).
      RUN PacketTextClear(mParentID).

      ASSIGN
         mOpDate  = hMain:buffer-field("op-date"):buffer-value
         mSendREF = hMain:buffer-field("SendREF"):buffer-value
      NO-ERROR.

      IF {assigned mSendREF}                 AND
         {assigned bCode.Misc[{&RKC-BEGIN}]} THEN DO:

         RUN PacketCreateRef (mOpDate,
                              mParentID,
                              bCode.Misc[{&RKC-BEGIN}],
                              ReferenceFormatValue(bCode.Misc[{&RKC-BEGIN}],
                                                   mSendREF)).
      END.

      ASSIGN
         mFileName  = hMain:buffer-field("file-name"):buffer-value
         mSurrogate = hMain:buffer-field("Surrogate"):buffer-value
         mRoleMain  = ENTRY(1,bCode.Description[1])
      NO-ERROR.

      IF {assigned mFileName}  AND
         {assigned mSurrogate} AND
         {assigned mRoleMain}  THEN
         RUN PacketCreateLink (mParentID,
                               mFileName,
                               mSurrogate,
                               mRoleMain).

      ASSIGN
         hMain:buffer-field("PacketID"):buffer-value = mParentID
      NO-ERROR. {&ON-ERROR}
   END.

/*--------------------------------- Выполним цикл по подготовленной выборке --*/
   DO WHILE NOT hObjQuery:query-off-end:


IF mBreak EQ "YES" AND
   NOT CAN-DO(STRING(mStr__ID), STRING(hObj::__UpID)) AND
   valid-handle(hBreak) THEN
DO:

   &IF DEFINED(IS-DEBUG) &THEN
   RUN dbgprint.p ("pck-exps.p"," mStr__ID:" + GetNullStr(string(mStr__ID)) +
                               " hObj::__UpID:" + GetNullStr(string(hObj::__UpID)) +
                               " hObj::__UpID:" + GetNullStr(string(hObj::__UpID)) +
                               " hBreak-name:" + GetNullStr(hBreak:name)).
   &ENDIF
   {additem.i mStr__ID "STRING(hObj::__UpID)"}
   ASSIGN
      mMainFormat = hBreak:buffer-field("mail-format"):buffer-value
      mSeanceID   = hPack:buffer-field("SeanceID"):buffer-value
   NO-ERROR. {&ON-ERROR}

   IF NOT EXCH-MSGBuff(mMainFormat, BUFFER bCode) THEN UNDO MAIN, RETRY MAIN.

   RUN PacketCreateF (INPUT  mSeanceID,
                      BUFFER bCode,
                      OUTPUT mParentID).
   RUN PacketTextClear(mParentID).

   hBreak:find-first("where __ID EQ " + string(hObj::__UpID)) NO-ERROR. {&ON-ERROR}
   IF hBreak:AVAILABLE THEN 
      ASSIGN
         hBreak:buffer-field("PacketID"):buffer-value = mParentID
         mOpDate  = hBreak:buffer-field("op-date"):buffer-value
         mSendREF = hBreak:buffer-field("SendREF"):buffer-value
      NO-ERROR. {&ON-ERROR}


   ASSIGN
   NO-ERROR.

   IF {assigned mSendREF}                 AND
      {assigned bCode.Misc[{&RKC-BEGIN}]} THEN DO:

      RUN PacketCreateRef (mOpDate,
                           mParentID,
                           bCode.Misc[{&RKC-BEGIN}],
                           ReferenceFormatValue(bCode.Misc[{&RKC-BEGIN}],
                                                mSendREF)).
   END.

   IF hBreak:AVAILABLE THEN 
   ASSIGN
      mFileName  = hBreak:buffer-field("file-name"):buffer-value
      mSurrogate = hBreak:buffer-field("Surrogate"):buffer-value
      mRoleMain  = ENTRY(1,bCode.Description[1])
   NO-ERROR.

   IF {assigned mFileName}  AND
      {assigned mSurrogate} AND
      {assigned mRoleMain}  THEN
      RUN PacketCreateLink (mParentID,
                            mFileName,
                            mSurrogate,
                            mRoleMain).


END.
ELSE IF mBreak EQ "YES" AND
     valid-handle(hBreak) THEN
DO:
   hBreak:find-first("where __ID EQ " + string(hObj::__UpID)) NO-ERROR. {&ON-ERROR}
   /*IF hBreak:AVAILABLE THEN */

END.
/*------------------------------------------------------ Создание сообщения --*/
      {exch-run.i &Proc     = mProcCrt
                  &ProcHndl = mHndlCrt
                  &Parm     = "iClass, hPack:table-handle"
                  &RunNoDef = YES
      } {&ON-ERROR}

      hObjQuery:get-next(NO-LOCK).

      IF NOT auto THEN DO:
         mCount = mCount + 1.
         IF mCount modulo 50 EQ 0 THEN
            PUT screen ROW 24 COL 35 string(mCount,{&COUNT-FMT}).
      END.
   END.

   mFlagSet = YES.
END.

IF mXMLInit EQ "YES" THEN DO:
   {exch-run.i &Proc     = mProcDwn
               &RunNoDef = YES
   }
END.

RUN ObjectValueDown.
DELETE widget-pool "PCK-EXPS-P" NO-ERROR.

{profile P10}

{intrface.del}
{doreturn.i mFlagSet}
/******************************************************************************/
/* $LINTUSER='VASOV' */
/* $LINTENV ='dpl' */
/* $LINTVSS ='$/ws3-dpl/bq' */
/* $LINTDATE='08/12/2014 12:02:50.178+04:00' */
/* $LINTFILE='pck-exps.p' */
/*prosignwHwYwaeKuzE6Pe8CdHwlRg*/