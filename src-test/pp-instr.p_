/*
               Банковская интегрированная система БИСквит
    Copyright: (C) 1992-2004 ТОО "Банковские информационные системы"
     Filename: PP-INSTR.P
      Comment: библиотека функций для работы с фин. инструментами
   Parameters:
         Uses:
      Used by:
      Created: ?   
     Modified: 10.02.2004 17:12 kolal    Добавлены инструменты по работе с курсами
                                         в разрезе подразделений и времени.
                                         Заявка 23442.
     Modified: 01.03.2004 14:51 kolal    Добавлена процедура GetRateDateTime, функции
                                         ChkRateTime и BaseRateTime. Заявка 26301.
     Modified: 01.03.2004 18:38 kolal    26301
     Modified: 12.03.2004 12:08 rija     
     Modified: 12.03.2004 12:43 rija     24152 : Реализовать кассовую операцию "Конверсия".
     Modified: 12.08.2004 16:37 ligp     Добавлена процедура GetPeriodRateDateTime
     Modified: 18.08.2004 15:29 ligp     31277: Доработка в модуле ВОК в свете Инструкции 113-И
                                         (замена реестров)
     Modified: 20.10.2004 17:15 ligp     35309: Из Функции CrossRateTimeR сделана процедура
     Modified: 22.10.2004 16:34 ligp     35309: Курс в транзакциях покупки и продажи валюты
     Modified:
*/

&GLOBAL-DEFINE PP-INSTR

{globals.i}
{intrface.get date}     /* Инструменты для работы с датами. */
{intrface.get separate} /* Библиотека для работы с категориями. */
{intrface.get tmess}    /* Инструменты обработки сообщений. */
{intrface.get xclass}   /* Библиотека инструментов метасхемы. */

DEF VAR mCacheBaseRate AS CHAR   NO-UNDO.  /* Кэш значений вазовой валюты для типов валют */
DEF VAR mCacheChkRate  AS CHAR   NO-UNDO.  /* Кэш признака прямой/обратный курс для типов валют */
DEF VAR mRatePer       AS DEC    NO-UNDO.

{instrum.fun}
{instrum.pro}
{breaktab.def}  /* Определение временной таблицы для диапазонов действия курсов в irate-time */
{timeleft.i2}

/* Запускается при загрузке интерфейса */
PROCEDURE StartInterface.
                        /* Кэширование классификатора "Курсы" для функций BaseRate,ChkRate  */
   FOR EACH code WHERE code.class EQ "Курсы"
   NO-LOCK:
      {additem.i mCacheBaseRate "code.code + ',' + code.val"}
      {additem.i mCacheChkRate  "code.code + ',' + STRING(code.misc[1] NE 'Обр')"}
   END.
   RETURN.
END PROCEDURE.

FUNCTION BaseRateVok RETURN char                     /* код валюты */
    (INPUT cType AS CHAR):                        /* тип курса */

    def buffer code for code.

    find first code where code.class = 
    "Курсы Вок" and code.code = cType no-lock no-error.
    if  avail code then  RETURN code.val.
    return baserate(ctype) .
END.

/* возврат базовой валюты */
FUNCTION BaseRateTime RETURN char                 /* код валюты */
    (INPUT cType AS CHAR):                        /* тип курса */

    def buffer code for code.

    find first code where code.class = "Курсы ВОК" and code.code = cType no-lock no-error.
    if not avail code then RETURN ?.
                      else RETURN code.val.
END.

/* проверка, прямой курс или обратный (280 -> Руб)*/
FUNCTION ChkRateTime RETURN logical                   /* прямой/обратный */
    (INPUT cType AS CHAR):                        /* тип курса */

    def buffer code for code.

    find first code where code.class = "Курсы ВОК" and code.code = cType no-lock no-error.
    if not avail code       then RETURN ?.
    RETURN if code.misc[1] = "Обр" then no
                                   else yes.
END.

/* Инструменты для работы с курсами в разрезе даты и времени (таблица irate-time) */
/* поиск курса */
FUNCTION FindRateTimeSimple RETURN DECIMAL       /* значение курса (прямое) */
    (INPUT iType      AS CHARACTER,              /* тип курса */
     INPUT iCurr      AS CHARACTER,              /* код валюты */
     INPUT iBranchId  AS CHARACTER,              /* Подразделение */
     INPUT iSince     AS DATE,                   /* дата */
     INPUT iSinceTime AS INT64,                /* Время */
     INPUT iBound     AS DECIMAL):                

   DEFINE BUFFER bIRate-Time FOR irate-time.
   DEFINE BUFFER xIRate-Time FOR irate-time.
   DEFINE BUFFER share-lock-IRate-Time FOR irate-time.

   DEFINE VARIABLE mBoundSumm       AS DECIMAL     NO-UNDO.
   DEFINE VARIABLE mIrateDateTime   AS DATETIME    NO-UNDO.
   DEFINE VARIABLE oRate            AS DECIMAL     NO-UNDO.

   oRate          = ?.
   mIrateDateTime = DATETIME(iSince,iSinceTime * 1000).
   mBoundSumm     = IF (iBound EQ ?) OR (iBound EQ 0) THEN 0 ELSE iBound.


   FOR EACH bIRate-Time WHERE 
          bIRate-Time.instr-cat     EQ "currency"
      AND bIRate-Time.rate-type     EQ iType
      AND bIRate-Time.instr-code    EQ iCurr
      AND bIRate-Time.branch-id     EQ iBranchId
      AND bIRate-Time.bound-summ    EQ 0
      AND bIRate-Time.IrateDateTime <= mIrateDateTime
      NO-LOCK
      BY bIRate-Time.IrateDateTime DESC:
find first share-lock-IRate-Time WHERE recid(share-lock-IRate-Time) = recid(bIRate-Time) share-lock no-wait no-error.
if not avail share-lock-IRate-Time then next.
      oRate = bIRate-Time.rate-instr / bIRate-Time.per.
      mRatePer = bIRate-Time.per.
      LEAVE.
   END.
   
   IF mBoundSumm > 0 THEN
   DO:
      FOR EACH xIRate-Time WHERE 
             xIRate-Time.instr-cat     EQ "currency"
         AND xIRate-Time.rate-type     EQ iType
         AND xIRate-Time.instr-code    EQ iCurr
         AND xIRate-Time.branch-id     EQ iBranchId
         AND xIRate-Time.IrateDateTime EQ bIRate-Time.IrateDateTime
         NO-LOCK
         BY xIRate-Time.bound-summ DESC
         BY xIRate-Time.IrateDateTime DESC:

find first share-lock-IRate-Time WHERE recid(share-lock-IRate-Time) = recid(xIRate-Time) share-lock no-wait no-error.
if not avail share-lock-IRate-Time then next.
         IF xIRate-Time.bound-summ <= iBound THEN
         DO:
            oRate = xIRate-Time.rate-instr / xIRate-Time.per.
            mRatePer = xIRate-Time.per.
            LEAVE.
         END.
      END.
   END.

   oRate = IF oRate NE ? THEN 
              oRate 
           ELSE 
              /* Возвращаем общий курс */
              FindRateSimple(iType, iCurr, iSince).

   RETURN oRate.
END.

/* поиск курса в зависимости от типа (прямой/обратный) (280 -> Руб)*/
FUNCTION FindRateTime RETURN DECIMAL            /* значение курса */
   (INPUT iType      AS CHARACTER,              /* тип курса */
    INPUT iCurr      AS CHARACTER,              /* код валюты */
    INPUT iBranchId  AS CHARACTER,              /* Подразделение */
    INPUT iSince     AS DATE,                   /* дата */
    INPUT iSinceTime AS INT64,                /* Время */
    INPUT iBound     AS DECIMAL):                

   IF ChkRateTime(iType) = ? THEN  
      RETURN ?.          /* Нет такого курса */
   RETURN (IF ChkRateTime(iType) THEN 
              FindRateTimeSimple(iType,
                                 iCurr,
                                 iBranchId,
                                 iSince,
                                 iSinceTime,
                                 iBound)
           ELSE 
              1 / FindRateTimeSimple(iType,
                                     iCurr,
                                     iBranchId,
                                     iSince,
                                     iSinceTime,
                                     iBound)).
END.

PROCEDURE GetCrossRatePer:
   DEFINE OUTPUT PARAMETER oCrossPer AS DECIMAL     NO-UNDO.
   oCrossPer = mRatePer.
END PROCEDURE.

/* поиск кросскурса (280 -> Руб -> 840) */
FUNCTION CrossRateTime RETURN DECIMAL            /* значение кросскурса */
    (INPUT iType AS CHARACTER,                   /* тип курса */
     INPUT iInCurr AS CHARACTER,                 /* код валюты1 */
     INPUT iOutCurr AS CHARACTER,                /* код валюты2 */
     INPUT iBranchId  AS CHARACTER,              /* Подразделение */
     INPUT iSince     AS DATE,                   /* дата */
     INPUT iSinceTime AS INT64,                /* Время */
     INPUT iBound     AS DECIMAL):                          

   IF ChkRateTime(iType) = ? THEN 
      RETURN ?.          /* Нет такого курса */
   RETURN (IF ChkRateTime(iType) THEN 
              FindRateTimeSimple(iType,
                                 iInCurr,
                                 iBranchId,
                                 iSince,
                                 iSinceTime,
                                 iBound) / 
              FindRateTimeSimple(iType,
                                 iOutCurr,
                                 iBranchId,
                                 iSince,
                                 iSinceTime,
                                 iBound)
           ELSE
              FindRateTimeSimple(iType,
                                 iOutCurr,
                                 iBranchId,
                                 iSince,
                                 iSinceTime,
                                 iBound) / 
              FindRateTimeSimple(iType,
                                 iInCurr,
                                 iBranchId,
                                 iSince,
                                 iSinceTime,
                                 iBound)).
END.

/* преобразование в базовую валюту (Сум(280) -> Сум(Руб))*/
FUNCTION CurToBaseTime RETURN DECIMAL            /* сумма в базовой валюте */
    (INPUT iType AS CHARACTER,                   /* тип курса */
     INPUT iCurr AS CHARACTER,                   /* код валюты */
     INPUT iBranchId  AS CHARACTER,              /* Подразделение */
     INPUT iSince AS DATE,                       /* дата */
     INPUT iSinceTime AS INT64,                /* Время */ 
     INPUT iVal AS DECIMAL):                     /* что надо перевести */

     IF BaseRateTime(iType) = ? THEN 
        RETURN ?.   /* Нет такого курса */
     RETURN (IF iCurr = BaseRateTime(iType) THEN 
                iVal
             ELSE 
                iVal * FindRateTime(iType,
                                    iCurr,
                                    iBranchId,
                                    iSince,
                                    iSinceTime,
                                    DEC(0))).
END.

/* преобразование в базовую валюту в зависимости от суммы (Сум(280) -> Сум(Руб))*/
FUNCTION CurToBaseTimeBound RETURN DECIMAL            /* сумма в базовой валюте */
    (INPUT iType AS CHARACTER,                   /* тип курса */
     INPUT iCurr AS CHARACTER,                   /* код валюты */
     INPUT iBranchId  AS CHARACTER,              /* Подразделение */
     INPUT iSince AS DATE,                       /* дата */
     INPUT iSinceTime AS INT64,                /* Время */ 
     INPUT iVal AS DECIMAL):                     /* что надо перевести */

     IF BaseRateTime(iType) = ? THEN 
        RETURN ?.   /* Нет такого курса */
     RETURN (IF iCurr = BaseRateTime(iType) THEN 
                iVal
             ELSE 
                iVal * FindRateTime(iType,
                                    iCurr,
                                    iBranchId,
                                    iSince,
                                    iSinceTime,
                                    iVal)).
END.

/* преобразование из базовой валюты (Сум(Руб) -> Сум(840))*/
FUNCTION CurFromBaseTime RETURN DECIMAL         /* сумма в указанной валюте */
   (INPUT iType AS CHARACTER,                   /* тип курса */
    INPUT iCurr AS CHARACTER,                   /* код валюты */
    INPUT iBranchId  AS CHARACTER,              /* Подразделение */
    INPUT iSince AS DATE,                       /* дата */
    INPUT iSinceTime AS INT64,                /* Время */ 
    INPUT iVal AS DECIMAL):                     /* что надо перевести */

     IF BaseRateTime(iType) = ? THEN 
        RETURN ?.   /* Нет такого курса */
     RETURN (IF iCurr = BaseRateTime(iType) THEN 
                iVal
             ELSE  
                iVal / FindRateTime(iType,
                                    iCurr,
                                    iBranchId,
                                    iSince,
                                    iSinceTime,
                                    DEC(0))).
END.

/* преобразование из базовой валюты в звисимости от суммы (Сум(Руб) -> Сум(840))*/
FUNCTION CurFromBaseTimeBound RETURN DECIMAL         /* сумма в указанной валюте */
   (INPUT iType AS CHARACTER,                   /* тип курса */
    INPUT iCurr AS CHARACTER,                   /* код валюты */
    INPUT iBranchId  AS CHARACTER,              /* Подразделение */
    INPUT iSince AS DATE,                       /* дата */
    INPUT iSinceTime AS INT64,                /* Время */ 
    INPUT iVal AS DECIMAL):                     /* что надо перевести */

     IF BaseRateTime(iType) = ? THEN 
        RETURN ?.   /* Нет такого курса */
     RETURN (IF iCurr = BaseRateTime(iType) THEN 
                iVal
             ELSE  
                iVal / FindRateTime(iType,
                                    iCurr,
                                    iBranchId,
                                    iSince,
                                    iSinceTime,
                                    iVal)).
END.


/* преобразование из валюты1 в валюту2 (Сум(280) -> Сум(Руб) -> Сум(840))*/
FUNCTION CurToCurTime RETURN DECIMAL             /* сумма */
   (INPUT iType AS CHARACTER,                    /* тип курса */
    INPUT iInCurr AS CHARACTER,                  /* код валюты1 */
    INPUT iOutCurr AS CHARACTER,                 /* код валюты2 */
    INPUT iBranchId  AS CHARACTER,               /* Подразделение */
    INPUT iSince     AS DATE,                    /* дата */
    INPUT iSinceTime AS INT64,                 /* Время */ 
    INPUT iVal AS DECIMAL):                      /* что надо перевести */

     IF BaseRateTime(iType) = ? THEN  
        RETURN ?.       /* Нет такого курса */
     RETURN (IF iInCurr = iOutCurr THEN 
                iVal
             ELSE  
                IF iInCurr = "" THEN  
                   CurFromBaseTime(iType,
                                   iOutCurr,
                                   iBranchId,
                                   iSince,
                                   iSinceTime,
                                   iVal)
                ELSE 
                   IF iOutCurr = "" THEN  
                      CurToBaseTime(iType,
                                    iInCurr,
                                    iBranchId,
                                    iSince,
                                    iSinceTime,
                                    iVal)
                   ELSE 
                      iVal * CrossRateTime(iType,
                                           iInCurr,
                                           iOutCurr,
                                           iBranchId,
                                           iSince,
                                           iSinceTime,
                                           iVal)).
END.

/* преобразование из валюты1 в валюту2 в зависимости от суммы (Сум(280) -> Сум(Руб) -> Сум(840))*/
FUNCTION CurToCurTimeBound RETURN DECIMAL             /* сумма */
   (INPUT iType AS CHARACTER,                    /* тип курса */
    INPUT iInCurr AS CHARACTER,                  /* код валюты1 */
    INPUT iOutCurr AS CHARACTER,                 /* код валюты2 */
    INPUT iBranchId  AS CHARACTER,               /* Подразделение */
    INPUT iSince     AS DATE,                    /* дата */
    INPUT iSinceTime AS INT64,                 /* Время */ 
    INPUT iVal AS DECIMAL):                      /* что надо перевести */

    DEFINE VARIABLE oRetVal AS DECIMAL INIT ?   NO-UNDO.
    DEFINE VARIABLE vRate   AS DECIMAL          NO-UNDO.
    DEFINE VARIABLE vDate   AS DATE             NO-UNDO.
    DEFINE VARIABLE vTime   AS INT64          NO-UNDO.
    RUN CrossRateTimeR(iType,iInCurr,iOutCurr,iBranchId,iSince,iSinceTime,iVal,OUTPUT vRate,OUTPUT vDate,OUTPUT vTime).

    xxx:
    DO ON ERROR UNDO xxx, LEAVE xxx:
       
       IF BaseRateTime(iType) = ? THEN  
          UNDO xxx, LEAVE xxx.       /* Нет такого курса */

       IF iInCurr = iOutCurr THEN 
          oRetVal = iVal.

       IF iInCurr = "" THEN  
          oRetVal = CurFromBaseTimeBound(iType,iOutCurr,iBranchId,iSince,iSinceTime,iVal).

       IF iOutCurr = "" THEN  
          oRetVal = CurToBaseTimeBound(iType,iInCurr,iBranchId,iSince,iSinceTime,iVal).

       IF (iInCurr <> "" AND iOutCurr <> "") AND (iInCurr <> iOutCurr) THEN
       DO:
          RUN CrossRateTimeR(iType,iInCurr,iOutCurr,iBranchId,iSince,iSinceTime,iVal,OUTPUT vRate,OUTPUT vDate,OUTPUT vTime).
          oRetVal = iVal * vRate.
       END.
    END.
    RETURN oRetVal.
END.

/* преобразование из валюты1 в валюту2 при разных типах курсов
   Базовые валюты курсов должны совпадать
   (Покупка -> Продажа: Сум(280) -> Сум(Руб) -> Сум(840))
*/
FUNCTION CurThroughCurTime RETURN DECIMAL        /* сумма */
    (INPUT iInType AS CHARACTER,                 /* тип курса  */
     INPUT iInCurr AS CHARACTER,                 /* код валюты1 */
     INPUT iOutType AS CHARACTER,                /* тип курса  */
     INPUT iOutCurr AS CHARACTER,                /* код валюты2 */
     INPUT iBranchId  AS CHARACTER,              /* Подразделение */
     INPUT iSince AS DATE,                       /* дата */
     INPUT iSinceTime AS INT64,                /* Время */ 
     INPUT iVal AS DECIMAL):                     /* что надо перевести */

     IF    BaseRateTime(iInType) = ? 
        OR BaseRateTime(iOutType) = ? 
        OR BaseRateTime(iInType) <> BaseRateTime(iOutType) THEN 
        RETURN ?.

     ASSIGN 
        iVal = CurToBaseTime(iInType, 
                             iInCurr, 
                             iBranchId,
                             iSince,
                             iSinceTime,
                             DEC(0))
        iVal = CurFromBaseTime(iOutType,
                               iOutCurr,
                               iBranchId,
                               iSince,
                               iSinceTime,
                               DEC(0))
     .
     RETURN iVal.
END.

/* преобразование из валюты1 в валюту2 при разных типах курсов в зависимости от суммы
   Базовые валюты курсов должны совпадать
   (Покупка -> Продажа: Сум(280) -> Сум(Руб) -> Сум(840))
*/
FUNCTION CurThroughCurTimeBound RETURN DECIMAL        /* сумма */
    (INPUT iInType AS CHARACTER,                 /* тип курса  */
     INPUT iInCurr AS CHARACTER,                 /* код валюты1 */
     INPUT iOutType AS CHARACTER,                /* тип курса  */
     INPUT iOutCurr AS CHARACTER,                /* код валюты2 */
     INPUT iBranchId  AS CHARACTER,              /* Подразделение */
     INPUT iSince AS DATE,                       /* дата */
     INPUT iSinceTime AS INT64,                /* Время */ 
     INPUT iVal AS DECIMAL):                     /* что надо перевести */

     IF    BaseRateTime(iInType) = ? 
        OR BaseRateTime(iOutType) = ? 
        OR BaseRateTime(iInType) <> BaseRateTime(iOutType) THEN 
        RETURN ?.

     ASSIGN 
        iVal = CurToBaseTime(iInType, 
                             iInCurr, 
                             iBranchId,
                             iSince,
                             iSinceTime,
                             iVal)
        iVal = CurFromBaseTime(iOutType,
                               iOutCurr,
                               iBranchId,
                               iSince,
                               iSinceTime,
                               iVal)
     .
     RETURN iVal.
END.


/* Определение Учетного курса по Евро-курсу для валют стран Евросоюза
   (Евро/Сум(280) => Евро/Руб => Сум(280)/Руб)
*/
FUNCTION StockThrEuroRateTime RETURN DECIMAL     /* сумма */
    (INPUT iInCurr AS CHARACTER,                 /* валюта */
     INPUT iBranchId  AS CHARACTER,              /* Подразделение */
     INPUT iSince AS DATE,                       /* дата */
     INPUT iSinceTime AS INT64,                /* Время */
     INPUT iBound     AS DECIMAL):

     IF    BaseRateTime("Учетный") = ? 
        OR BaseRateTime("Евро") = ? THEN 
        RETURN ?.

   RETURN FindRateTime("Учетный",
                       "978",
                       iBranchId,
                       iSince,
                       iSinceTime,
                       iBound) * 
          FindRateTime("Евро",
                       iInCurr,
                       iBranchId,
                       iSince,
                       iSinceTime,
                       iBound).

END.

/******************************************************************************/
/* ChkExistRateTime     - проверка существования курса */
FUNCTION ChkExistRateTime RETURN LOGICAL
    (iCat   AS CHARACTER,                   /* категория  */
     iCurr  AS CHARACTER,                   /* код валюты */
     iBranchId AS CHARACTER,                /* Подразделение */
     iSince AS DATE,                        /* дата */
     iSinceTime AS INT64,                 /* Время */
     iType  AS CHARACTER,                   /* тип курса */
     iBound     AS DECIMAL):
   DEFINE BUFFER bIRate-Time FOR irate-time.

   DEFINE VARIABLE mBoundSumm       AS DECIMAL     NO-UNDO.
   DEFINE VARIABLE mIrateDateTime   AS DATETIME    NO-UNDO.

   mIrateDateTime = DATETIME(iSince,iSinceTime * 1000).

   mBoundSumm  = IF (iBound EQ ?) OR (iBound EQ 0) THEN 0 ELSE iBound.

FIND FIRST bIRate-Time NO-LOCK NO-ERROR.
RELEASE bIRate-Time.

   CASE INT64(mBoundSumm):
      WHEN 0 THEN
      DO:
         FOR EACH bIRate-Time WHERE 
                bIRate-Time.instr-cat     EQ "currency"
            AND bIRate-Time.rate-type     EQ iType
            AND bIRate-Time.instr-code    EQ iCurr
            AND bIRate-Time.branch-id     EQ iBranchId
            AND bIRate-Time.bound-summ    EQ 0
            AND bIRate-Time.IrateDateTime <= mIrateDateTime
            NO-LOCK
            BY bIRate-Time.IrateDateTime DESC:
            
             LEAVE.
         END.
      END.
      OTHERWISE
      DO:
         FOR EACH bIRate-Time WHERE 
                bIRate-Time.instr-cat     EQ "currency"
            AND bIRate-Time.rate-type     EQ iType
            AND bIRate-Time.instr-code    EQ iCurr
            AND bIRate-Time.branch-id     EQ iBranchId
            AND bIRate-Time.IrateDateTime <= mIrateDateTime
            NO-LOCK
            BY bIRate-Time.bound-summ DESC
            BY bIRate-Time.IrateDateTime DESC:
          
            IF bIRate-Time.bound-summ <= iBound THEN
               LEAVE.
         END.
      END.
   END CASE.

  IF AVAIL bIRate-Time
  THEN  RETURN YES.
  RETURN NO.
END.

/* ChkExistRateMain     - проверка существования курса ВЕЗДЕ */
FUNCTION ChkExistRateMain RETURN LOGICAL
    (iCat   AS CHARACTER,                   /* категория  */
     iCurr  AS CHARACTER,                   /* код валюты */
     iBranchId AS CHARACTER,                /* Подразделение */
     iSince AS DATE,                        /* дата */
     iSinceTime AS INT64,                 /* Время */
     iType  AS CHARACTER,                   /* тип курса */
     iBound AS DECIMAL):

  DEFINE BUFFER bIRate-Time FOR irate-time.
  DEFINE BUFFER instr-rate FOR instr-rate .  
  IF  ChkExistRateTime(iCat,
                       iCurr,
                       iBranchId,
                       iSince ,
                       iSinceTime,
                       iType,
                       iBound)
  THEN RETURN YES .       
  FIND FIRST instr-rate WHERE instr-rate.instr-cat   EQ "currency"
                          AND instr-rate.rate-type   EQ iType
                          AND instr-rate.instr-code  EQ iCurr
                          AND instr-rate.since       <= iSince 
      NO-LOCK NO-ERROR .
  IF AVAIL instr-rate
  THEN RETURN YES.
  RETURN NO .
                       
END.

/*  ChkRightsOn_Change-rate     - проверяет, есть ли  у пользователя право на корректировку курса */
FUNCTION ChkRightsOn_Change-rate RETURN LOGICAL
    (iRateType   AS CHARACTER,   
     iUser       AS CHARACTER):

    IF CAN-DO(GetXAttrValueEx("_user", iUser, "ТипыКурсов", "*"), iRateType) THEN 
         RETURN YES. 
    ELSE RETURN NO.

END.

/* поиск кросскурса (280 -> Руб -> 840) и даты-времени этого курса
   если не находит то пересчитывает через рубли
*/
PROCEDURE CrossRateTimeR:
   DEFINE INPUT  PARAMETER iType      AS CHARACTER   NO-UNDO. /* тип курса */
   DEFINE INPUT  PARAMETER iInCurr    AS CHARACTER   NO-UNDO. /* код валюты1 */
   DEFINE INPUT  PARAMETER iOutCurr   AS CHARACTER   NO-UNDO. /* код валюты2 */
   DEFINE INPUT  PARAMETER iBranchId  AS CHARACTER   NO-UNDO. /* Подразделение */
   DEFINE INPUT  PARAMETER iSince     AS DATE        NO-UNDO. /* дата */
   DEFINE INPUT  PARAMETER iSinceTime AS INT64     NO-UNDO. /* Время */
   DEFINE INPUT  PARAMETER iBound     AS DECIMAL     NO-UNDO.
   DEFINE OUTPUT PARAMETER oCrossRate AS DECIMAL     NO-UNDO. /* значение кросскурса */
   DEFINE OUTPUT PARAMETER oRateDate  AS DATE        NO-UNDO. /* Дата установки кросскурса */
   DEFINE OUTPUT PARAMETER oRateTime  AS INT64     NO-UNDO. /* Время установки кросскурса */

   DEFINE VARIABLE choice    AS LOGICAL   INITIAL YES NO-UNDO.
   DEFINE VARIABLE vBaseCurr AS CHARACTER             NO-UNDO.

   DEFINE VARIABLE vRateIn    AS DECIMAL   NO-UNDO. /* Курс принимаемой валюты */
   DEFINE VARIABLE vRateOut   AS DECIMAL   NO-UNDO. /* Курс выдаваемой валюты */
   DEFINE VARIABLE vRatDatIn  AS DATE      NO-UNDO.
   DEFINE VARIABLE vRatTimIn  AS INT64   NO-UNDO.
   DEFINE VARIABLE vRatDatOut AS DATE      NO-UNDO.
   DEFINE VARIABLE vRatTimOut AS INT64   NO-UNDO.
   DEFINE VARIABLE vTypeIn    AS CHARACTER NO-UNDO. /* тип курса принимаемой валюты */
   DEFINE VARIABLE vTypeOut   AS CHARACTER NO-UNDO. /* тип курса выдаваемой валюты */

   DEFINE VARIABLE mLogTech  AS LOGICAL    NO-UNDO.
   DEFINE VARIABLE mOutStr   AS CHARACTER  NO-UNDO.
   
   IF iInCurr EQ iOutCurr THEN
   DO:
      oCrossRate = 1.
      RETURN.
   END.   

   choice = ChkRateTime(iType).
   IF choice = ? THEN 
   DO:
      oCrossRate = ?. /* Нет такого курса */
      oRateDate  = ?.
      oRateTime  = ?.
   END.              
    
    /*  Найдем базовую валюту */
   vBaseCurr = BaseRateVok(iType) .
   IF (ChkExistRateMain("currency",
                        iInCurr,
                        iBranchId,
                        iSince,
                        iSinceTime,
                        iType, 
                        iBound) EQ YES 
      OR vBaseCurr = iInCurr)
      AND               
      (ChkExistRateMain("currency",
                         iOutCurr,
                         iBranchId,
                         iSince,
                         iSinceTime,
                         iType,
                         iBound) EQ YES 
      OR
      vBaseCurr = iOutCurr)
      THEN
   DO:
      vRateIn  = FindRateTimeSimple(iType,
                                    iInCurr,
                                    iBranchId,
                                    iSince,
                                    iSinceTime,
                                    iBound).
      vRateOut = FindRateTimeSimple(iType,
                                    iOutCurr,
                                    iBranchId,
                                    iSince,
                                    iSinceTime,
                                    iBound).
      IF choice THEN
      DO:
         oCrossRate = vRateIn / vRateOut.
      END. /* IF choice THEN */
      ELSE
      DO:
         oCrossRate = vRateOut / vRateIn.
      END. /* IF choice ELSE */
      vTypeIn  = iType. 
      vTypeOut = iType.
   END.
   ELSE
   DO:
      RUN Fill-SysMes("", 
                   "", 
                   "4",
                   "Не найден кросс-курс для пары валют ~"" 
                    + iInCurr + "~" - ~"" + iOutCurr + "~"" + "~n" + 
                    "Использовать курс ЦБ, либо кросс-курс через рубли ?").  
      CASE pick-value:
         WHEN "YES" THEN
         DO:
            vRateIn  = FindRateTimeSimple("Покупка",
                                          iInCurr,
                                          iBranchId,
                                          iSince,
                                          iSinceTime,
                                          iBound).
            vRateOut = FindRateTimeSimple("Продажа",
                                          iOutCurr,
                                          iBranchId,
                                          iSince,
                                          iSinceTime,
                                          iBound).
            vTypeIn  = "Покупка". 
            vTypeOut = "Продажа".

/* Если какого-либо курса не обнаружено, то берем курс ЦБ */
            IF vRateIn EQ 1.00 OR vRateOut EQ 1.00 THEN
            DO:
               vRateIn  = FindRateTimeSimple("Учетный",
                                             iInCurr,
                                             iBranchId,
                                             iSince,
                                             iSinceTime,
                                             iBound).
               vRateOut = FindRateTimeSimple("Учетный",
                                             iOutCurr,
                                             iBranchId,
                                             iSince,
                                             iSinceTime,
                                             iBound).
               vTypeIn  = "Учетный". 
               vTypeOut = "Учетный".
            END. /* Если какого-либо курса не обнаружено */
            oCrossRate = vRateIn / vRateOut.
         END.
         WHEN "NO" THEN
         DO:
            oCrossRate = 1.00.
            vRatDatIn  = iSince.
            vRatTimIn  = iSinceTime.
            vRatDatOut = iSince.
            vRatTimOut = iSinceTime.
         END.
      END CASE.
   END.

/* Определим дату-время установки курса */
   RUN GetRateDateTime (vTypeIn,
                        iInCurr,
                        iBranchId,
                        iSince,
                        iSinceTime,
                        iBound,
                        OUTPUT vRatDatIn,
                        OUTPUT vRatTimIn).
   RUN GetRateDateTime (vTypeOut,
                        iOutCurr,
                        iBranchId,
                        iSince,
                        iSinceTime,
                        iBound,
                        OUTPUT vRatDatOut,
                        OUTPUT vRatTimOut).

   IF vRatDatIn = ? AND vRatDatOut <> ? THEN
   DO:
      oRateDate = vRatDatOut.
      oRateTime = vRatTimOut.
   END.   
   ELSE
   IF vRatDatIn <> ? AND vRatDatOut = ? THEN
   DO:
      oRateDate = vRatDatIn.
      oRateTime = vRatTimIn.
   END.                    
   ELSE
   IF (vRatDatIn < vRatDatOut) OR 
      ((vRatDatIn = vRatDatOut) AND (vRatTimIn < vRatTimOut)) THEN
   DO:
      oRateDate = vRatDatIn.
      oRateTime = vRatTimIn.
   END.
   ELSE
   DO:
      oRateDate = vRatDatOut.
      oRateTime = vRatTimOut.
   END.
   mLogTech = LOGICAL(fGetSetting("КонтрКурс","","Нет"),"Да/Нет") NO-ERROR.
   mOutStr = IF mLogTech AND iSince NE oRateDate THEN 
                                                      ("Операция будет выполнена по курсу на дату " 
                                                      + STRING(oRateDate) + " и время " 
                                                      + STRING(oRateTime,"HH:MM:SS") + "." + CHR(10) 
                                                      + "Продолжить операцию?")
                                                 ELSE 
                                                    "".
   RETURN mOutStr.
END PROCEDURE. /* CrossRateTimeR */

/* Возвращает дату и время начала действия курса */
PROCEDURE GetRateDateTime:
   DEFINE INPUT PARAMETER iType      AS CHARACTER NO-UNDO.      /* тип курса */
   DEFINE INPUT PARAMETER iCurr      AS CHARACTER NO-UNDO.      /* код валюты */
   DEFINE INPUT PARAMETER iBranchId  AS CHARACTER NO-UNDO.      /* Подразделение */
   DEFINE INPUT PARAMETER iSince     AS DATE      NO-UNDO.      /* дата */
   DEFINE INPUT PARAMETER iSinceTime AS INT64   NO-UNDO.      /* Время */
   DEFINE INPUT PARAMETER iBound     AS DECIMAL   NO-UNDO.
   DEFINE OUTPUT PARAMETER oDate     AS DATE      NO-UNDO.      /* Дата начала действия курса */
   DEFINE OUTPUT PARAMETER oTime     AS INT64   NO-UNDO.      /* Время начала действия */

   DEFINE BUFFER bIRate-Time FOR irate-time.

   DEFINE VARIABLE mBoundSumm       AS DECIMAL     NO-UNDO.
   DEFINE VARIABLE mIrateDateTime   AS DATETIME    NO-UNDO.

   mIrateDateTime = DATETIME(iSince,iSinceTime * 1000).

   mBoundSumm  = IF (iBound EQ ?) OR (iBound EQ 0) THEN 0 ELSE iBound.

FIND FIRST bIRate-Time NO-LOCK NO-ERROR.
RELEASE bIRate-Time.

   CASE INT64(mBoundSumm):
      WHEN 0 THEN
      DO:
         FOR EACH bIRate-Time WHERE 
                bIRate-Time.instr-cat     EQ "currency"
            AND bIRate-Time.rate-type     EQ iType
            AND bIRate-Time.instr-code    EQ iCurr
            AND bIRate-Time.branch-id     EQ iBranchId
            AND bIRate-Time.bound-summ    EQ 0
            AND bIRate-Time.IrateDateTime <= mIrateDateTime
            NO-LOCK
            BY bIRate-Time.IrateDateTime DESC:
          
               LEAVE.
         END.
      END.
      OTHERWISE
      DO:
         FOR EACH bIRate-Time WHERE 
                bIRate-Time.instr-cat     EQ "currency"
            AND bIRate-Time.rate-type     EQ iType
            AND bIRate-Time.instr-code    EQ iCurr
            AND bIRate-Time.branch-id     EQ iBranchId
            AND bIRate-Time.IrateDateTime <= mIrateDateTime
            NO-LOCK
            BY bIRate-Time.bound-summ DESC
            BY bIRate-Time.IrateDateTime DESC:

            IF bIRate-Time.bound-summ <= iBound THEN
               LEAVE.
         END.
      END.
   END CASE.

   IF AVAIL bIRate-Time THEN 
   DO:
        /* обработка типа DateTime - в DataServer такой тип данных теперь поддерживается! RSafiullin */
        oDate = DATE(bIRate-Time.IrateDateTime).
        /* этот код устарел (RSafiullin)
        oTime = TimeLeftInInt(ENTRY(2,STRING(bIRate-Time.IrateDateTime, "99/99/9999 HH:MM:SS"), " ")). */
        oTime = INT64( MTIME(bIRate-Time.IrateDateTime) / 1000 ).
   END.
   ELSE
   DO:
      oDate = GetLastCursDate("currency",
                              iCurr,
                              iSince,
                              iType).
      oTime = 0.
   END.
END PROCEDURE.

/*------------------------------------------------------------------------------
  Назначение:  возвращает временную таблицу диапазонов действия курсов в irate-time
  Параметры:   iCodVOK   - Код подразделения 
               iDateBeg  - Дата начала требуемого периода 
               iTimeBeg  - Время начала требуемого периода 
               iDateEnd  - Дата окончания требуемого периода 
               iTimeEnd  - Время начала требуемого периода 
               ttStable-Rate - таблица с результатом работы
  Примечание:  Когда меняется какой-либо курс, мы закрываем период и открываем новый     
------------------------------------------------------------------------------*/  
PROCEDURE GetPeriodRateDateTime:

   DEFINE INPUT  PARAMETER iCodVOK  AS CHARACTER NO-UNDO. /* Подразделение */
   DEFINE INPUT  PARAMETER iDateBeg AS DATE      NO-UNDO. /* Дата начала периода */
   DEFINE INPUT  PARAMETER iTimeBeg AS INT64   NO-UNDO. /* Время начала периода */
   DEFINE INPUT  PARAMETER iDateEnd AS DATE      NO-UNDO. /* Дата окончания периода */
   DEFINE INPUT  PARAMETER iTimeEnd AS INT64   NO-UNDO. /* Время начала периода */
   DEFINE OUTPUT PARAMETER TABLE FOR ttStable-Rate.     /* */

   DEFINE VARIABLE vNumRec      AS INT64  INITIAL 0 NO-UNDO.
   DEFINE VARIABLE vDateBeg     AS DATE     NO-UNDO. /* Дата начала периода */
   DEFINE VARIABLE vTimeBeg     AS INT64  NO-UNDO. /* Время начала периода */
  
   DEFINE VARIABLE vDateTimeBeg AS DATETIME NO-UNDO. /* Дата и Время начала периода */
   DEFINE VARIABLE vDateTimeCur AS DATETIME NO-UNDO. /* Дата и Время смены курса */
   DEFINE VARIABLE vDateTimeEnd AS DATETIME NO-UNDO. /* Дата и Время конца периода */  

   DEFINE VARIABLE i            AS INT64  NO-UNDO. /* Для цыкла */

   ASSIGN
      vDateTimeBeg = DATETIME(iDateBeg,iTimeBeg * 1000)
      vDateTimeEnd = DATETIME(iDateEnd,iTimeEnd * 1000) 
      vDateBeg     = iDateBeg
      vTimeBeg     = iTimeBeg
      .

   {empty ttStable-Rate} /* Почистим временную таблицу */

   DEFINE BUFFER bIrate-time FOR irate-time.

   /* Проверим есть ли у этого подразделения свои курсы */
   FOR EACH bIrate-time WHERE bIrate-time.branch-id  EQ iCodVOK
                          AND bIRate-Time.instr-cat  EQ "currency"
                          AND bIRate-Time.bound-summ EQ 0
      NO-LOCK USE-INDEX rate-instr
      BY bIrate-time.branch-id EQ iCodVOK
      BY bIRate-Time.instr-cat EQ "currency":
      LEAVE.
   END.

   IF AVAILABLE bIrate-time THEN /* Работаем с курсами ВОК */
   DO:
      /*-- Определяем временные диапазоны действия курсов в заданном периоде --*/
      FOR EACH bIrate-time WHERE 
              bIrate-time.branch-id    EQ iCodVOK
         AND bIRate-Time.instr-cat     EQ "currency"
         AND bIRate-Time.IrateDateTime GE vDateTimeBeg
         AND bIRate-Time.IrateDateTime LE vDateTimeEnd
         AND bIRate-Time.bound-summ    EQ 0
         NO-LOCK BREAK BY bIRate-Time.IrateDateTime :
         DO:
            DO WHILE DATE(bIRate-Time.IrateDateTime) > vDateBeg :
               vNumRec = vNumRec + 1.
               CREATE ttStable-Rate.
               ASSIGN
                  ttStable-Rate.ISN     = vNumRec
                  ttStable-Rate.DateBeg = vDateBeg
                  ttStable-Rate.TimeBeg = vTimeBeg
                  ttStable-Rate.DateEnd = vDateBeg
                  ttStable-Rate.TimeEnd = 86399
               .
               vDateBeg = vDateBeg + 1.
               vTimeBeg = 0.
            END.
            vNumRec = vNumRec + 1.
            CREATE ttStable-Rate.
            ASSIGN
               ttStable-Rate.ISN     = vNumRec
               ttStable-Rate.DateBeg = vDateBeg
               ttStable-Rate.TimeBeg = vTimeBeg
               ttStable-Rate.DateEnd = DATE(bIRate-Time.IrateDateTime)
               ttStable-Rate.TimeEnd = INT64( MTIME(bIRate-Time.IrateDateTime) / 1000 )
               .
               /* код устарел (RSafiullin) 
               ttStable-Rate.TimeEnd = TimeLeftInInt(ENTRY(2,STRING(bIRate-Time.IrateDateTime, "99/99/9999 HH:MM:SS"), " ")).
               */

            IF /* TimeLeftInInt(ENTRY(2,STRING(bIRate-Time.IrateDateTime, "99/99/9999 HH:MM:SS"), " ")) - устарело */
               INT64( MTIME(bIRate-Time.IrateDateTime) / 1000 ) EQ 86399 THEN
            DO: /* Если это была последняя секунда в сутках */
               vDateBeg = DATE(bIRate-Time.IrateDateTime) + 1.
               vTimeBeg = 0.
            END.
            ELSE
            DO: /* Если это была НЕпоследняя секунда в сутках */
               vDateBeg = DATE(bIRate-Time.IrateDateTime).
               vTimeBeg = INT64( MTIME(bIRate-Time.IrateDateTime) / 1000 ) + 1.
            END.

         END. /* IF vDateTimeBeg GE vDateTimeCur AND */
      END. /* FOR EACH bIrate-time */
   END. /* IF AVAILABLE bIrate-time */
   ELSE                        /* Работаем с курсами банка */
   DO:  /* а курс банка в течение опер. дня не менялся */
      CREATE ttStable-Rate.
      ASSIGN
         ttStable-Rate.ISN     = vNumRec
         ttStable-Rate.DateBeg = vDateBeg
         ttStable-Rate.TimeBeg = vTimeBeg
         ttStable-Rate.DateEnd = iDateEnd
         ttStable-Rate.TimeEnd = iTimeEnd
      .
   END.    

   DO WHILE iDateEnd > vDateBeg :
      vNumRec = vNumRec + 1.
      CREATE ttStable-Rate.
      ASSIGN
         ttStable-Rate.ISN     = vNumRec
         ttStable-Rate.DateBeg = vDateBeg
         ttStable-Rate.TimeBeg = vTimeBeg
         ttStable-Rate.DateEnd = vDateBeg
         ttStable-Rate.TimeEnd = 86399
      .
      vDateBeg = vDateBeg + 1.
      vTimeBeg = 0.
   END.
    /* Время окончания действия курса = введенному параметру */
   vNumRec = vNumRec + 1.
   CREATE ttStable-Rate.
   ASSIGN
      ttStable-Rate.ISN     = vNumRec
      ttStable-Rate.DateBeg = vDateBeg
      ttStable-Rate.TimeBeg = vTimeBeg
      ttStable-Rate.DateEnd = iDateEnd
      ttStable-Rate.TimeEnd = iTimeEnd
   .
END PROCEDURE. /* GetPeriodRateDateTime */

RETURN.

