/*                                        

               Банковская интегрированная система БИСквит
    Copyright: (C) 1992-2004 ТОО "Банковские информационные системы"
     Filename: exp-tax.p
      Comment: Экспорт подготовленного сообщения в текстовый файл
               Является методом (код EXPORT) класса, унаследованого от
               Packet -> PTax

               Выполняемые действия:
               1. Создается пакет данных с текстом сообщения
               2. Создается ссылка на созданный пакет
               3. Создается связь созданого пакета с экспортируемым сообщением

               К моменту вызова должны существовать инстансы:
               1. Текущего обрабатываемого класса
               2. Экспортируемого класса.

               Изменений в буфере транзакции не производится
   Parameters: iClass      - код класса
               iInstance   - содержимое класса iClass
         Uses:
      Used BY:
      Created: 30.03.2004 NIK
     Modified: 15.05.2004 Mike 29332
     Modified: 24/11/2005 NIK Добавлено поле Filial-ID
     Modified: 17/05/2006 NIK Реструктуризация pp-pack.p
     Modified: 25/05/2006 NIK Экспорт предписанных реквизитов
     Modified: 05.09.2008 17:34 MUTA 0098207
*/
{globals.i}

DEFINE INPUT PARAMETER iClass       AS CHAR     NO-UNDO.
DEFINE INPUT PARAMETER iInstance    AS handle   NO-UNDO.

DEFINE VAR hInstance    AS handle   NO-UNDO.
DEFINE VAR hTaxExpBank  AS handle   NO-UNDO.
DEFINE VAR hTaxExpCust  AS handle   NO-UNDO.
DEFINE VAR hTaxExpAcct  AS handle   NO-UNDO.

DEFINE VAR hTaxExpCommon  AS handle   NO-UNDO.
DEFINE VAR hTaxExpInf     AS handle   NO-UNDO.
DEFINE VAR hTaxExpInfB    AS handle   NO-UNDO.
DEFINE VAR hTaxExpTaxInsp AS handle   NO-UNDO.
DEFINE VAR hAcct          AS handle   NO-UNDO.

DEFINE VAR mAcct        AS CHAR     NO-UNDO.
DEFINE VAR mCurrency    AS CHAR     NO-UNDO.
DEFINE VAR mKind        AS CHAR     NO-UNDO.
DEFINE VAR mOpKindKind  AS CHAR     NO-UNDO.
DEFINE VAR mResult      AS CHAR     NO-UNDO.

DEFINE VAR mPacketID    AS INT64  NO-UNDO.
DEFINE VAR mSeanceID    AS INT64  NO-UNDO.

DEFINE VAR mFlagSet     AS LOGICAL  INIT ? NO-UNDO.
DEFINE VAR mRefValue    AS CHAR     NO-UNDO.
DEFINE VAR mVerFormat   AS CHAR     NO-UNDO.
DEFINE VAR mFlagError   AS LOGICAL  NO-UNDO.

DEFINE STREAM sExport.
DEFINE BUFFER xattr FOR xattr.

{g-trans.equ}
{exchange.equ}

{intrface.get xclass}
{intrface.get strng}

{intrface.get tmess}
{intrface.get pbase}
{intrface.get db2l}
{intrface.get trans}

{intrface.get swft}
{intrface.get filex}
{intrface.get rule}
{intrface.get pack}
{intrface.get exch}
{intrface.get rfrnc}
{intrface.get fx}

/*============================================================================*/
&IF DEFINED(IS-DEBUG) &THEN
RUN dbgprint.p ("exp-tax.p","START").
&ENDIF

{empty tterror}

MAKE:
DO TRANSACTION ON ERROR UNDO MAKE, RETRY MAKE:
   {do-retry.i MAKE}

   ASSIGN
      hInstance   = iInstance:default-buffer-handle
      mKind       = GetValue(hInstance,"Kind")              /* Класс сообщения           */
      mOpKindKind = GetValue(hInstance,"OpKindKind")        /* Вид транзакции экспорта   */
      mSeanceID   = INT64(GetValue(hInstance,"SeanceID")) /* Идентификатор сеанса      */
   NO-ERROR.
   IF ERROR-STATUS:ERROR THEN UNDO MAKE, RETRY MAKE.

   ASSIGN
      hAcct       = GetTransObject("acctb")
      hAcct       = hAcct:default-buffer-handle
      mAcct       = hAcct:buffer-field("acct"):buffer-value
      mCurrency   = hAcct:buffer-field("currency"):buffer-value
   NO-ERROR.
   IF ERROR-STATUS:ERROR THEN UNDO MAKE, RETRY MAKE.

   mVerFormat = REPLACE(mKind,"TaxExp","").

&IF DEFINED(IS-DEBUG) &THEN
RUN dbgprint.p ("exp-tax.p","VerFormat:" + GetNullStr(mVerFormat)).
&ENDIF

   RUN MakeBindMessage (INPUT  hInstance,
                        INPUT  mAcct,
                        INPUT  mCurrency,
                        INPUT  mSeanceID,
                        INPUT  mKind).       /* Создание пакета сообщения */

   mFlagSet = YES.
END.

{intrface.del}

&IF DEFINED(IS-DEBUG) &THEN
RUN dbgprint.p ("exp-tax.p","FINIS").
&ENDIF

{doreturn.i mFlagSet}
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE MakeBindMessage:
   DEFINE INPUT  PARAMETER iBuffer     AS handle   NO-UNDO.
   DEFINE INPUT  PARAMETER iAcct       AS CHAR     NO-UNDO.
   DEFINE INPUT  PARAMETER iCurrency   AS CHAR     NO-UNDO.
   DEFINE INPUT  PARAMETER iSeanceID   AS INT64  NO-UNDO.
   DEFINE INPUT  PARAMETER iKind       AS CHAR     NO-UNDO.

   DEFINE VAR vNameFile    AS CHAR     NO-UNDO.
   DEFINE VAR vNameMess    AS CHAR     NO-UNDO.
   DEFINE VAR vAbonentID   AS INT64  NO-UNDO.
   DEFINE VAR vMailUserID  AS INT64  NO-UNDO.
   DEFINE VAR vSeanceID    AS INT64  NO-UNDO.
   DEFINE VAR vRuleID      AS INT64  NO-UNDO.
   DEFINE VAR vFlagSet     AS LOGICAL  INIT ? NO-UNDO.
   DEFINE VAR vErrorClass  AS CHAR              NO-UNDO.
   DEFINE VAR vErrorList   AS CHAR              NO-UNDO.
   DEFINE VAR vRefValue    AS CHAR              NO-UNDO.
   DEFINE VAR vMessNum     AS CHAR              NO-UNDO.

   DEFINE BUFFER bCode        FOR Code.
   DEFINE BUFFER Packet       FOR Packet.
   DEFINE BUFFER Reference    FOR Reference.
   DEFINE BUFFER PackObject   FOR PackObject.

   mResult = "".

MAIN:
   DO TRANSACTION ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      FIND FIRST Seance WHERE Seance.SeanceID EQ iSeanceID
                          AND (IF   shMode
                               THEN Seance.Filial-ID EQ shFilial
                               ELSE YES)
      NO-LOCK NO-ERROR.
      {find-act.i
         &acct = iAcct
         &curr = iCurrency
      }

      FIND FIRST Mail-User WHERE Mail-User.op-kind-exp  EQ Seance.op-kind
                             AND (IF   shMode
                                  THEN Mail-User.Filial-ID EQ shFilial
                                  ELSE YES)
      NO-LOCK NO-ERROR.

      IF mVerFormat EQ "" OR mVerFormat EQ "4" THEN
      ASSIGN
         hTaxExpTaxInsp = GetTransObject("TaxExpTaxInsp" + mVerFormat) WHEN mVerFormat NE ""
         hTaxExpCommon  = GetTransObject("TaxExpCommon" + mVerFormat)
         hTaxExpBank    = GetTransObject("TaxExpBank"   + mVerFormat)
         hTaxExpCust    = GetTransObject("TaxExpCust"   + mVerFormat)
         hTaxExpAcct    = GetTransObject("TaxExpAcct"   + mVerFormat)
      NO-ERROR.
      ELSE IF mVerFormat EQ "5" OR mVerFormat EQ "CH" THEN
      ASSIGN
         hTaxExpCommon  = GetTransObject("TaxExpCommon" + mVerFormat)
         hTaxExpInf     = GetTransObject("TaxExpInf" + mVerFormat) 
      NO-ERROR.
      ELSE IF mVerFormat EQ "CH5" THEN
      ASSIGN
         hTaxExpCommon  = GetTransObject("TaxExpCommonCH")
         hTaxExpInf     = GetTransObject("TaxExpInfCH5") 
         hTaxExpInfB    = GetTransObject("TaxExpInfCHB")
      NO-ERROR.

&IF DEFINED(IS-DEBUG) &THEN
RUN dbgprint.p ("exp-tax.p","VerFormat:" + GetNullStr(mVerFormat)).
&ENDIF

      {&ON-ERROR}

      IF mVerFormat EQ "" OR mVerFormat EQ "4" THEN
      ASSIGN
         hTaxExpTaxInsp = hTaxExpTaxInsp:default-buffer-handle WHEN mVerFormat NE ""
         hTaxExpCommon  = hTaxExpCommon:default-buffer-handle
         hTaxExpBank    = hTaxExpBank:default-buffer-handle
         hTaxExpCust    = hTaxExpCust:default-buffer-handle
         hTaxExpAcct    = hTaxExpAcct:default-buffer-handle
         vErrorClass    = iBuffer:buffer-field("ClassError"):buffer-value
         vErrorList     = hTaxExpCommon:buffer-field("ErrorList"):buffer-value
      NO-ERROR.
      ELSE IF mVerFormat EQ "5" OR mVerFormat EQ "CH" THEN
      ASSIGN
         hTaxExpCommon  = hTaxExpCommon:default-buffer-handle
         hTaxExpInf     = hTaxExpInf:default-buffer-handle 
         vErrorClass    = iBuffer:buffer-field("ClassError"):buffer-value
         vErrorList     = hTaxExpCommon:buffer-field("ErrorList"):buffer-value
      NO-ERROR.
      ELSE IF mVerFormat EQ "CH5" THEN
      ASSIGN
         hTaxExpCommon  = hTaxExpCommon:default-buffer-handle
         hTaxExpInf     = hTaxExpInf:default-buffer-handle
         hTaxExpInfB    = hTaxExpInfB:default-buffer-handle
         vErrorClass    = iBuffer:buffer-field("ClassError"):buffer-value
         vErrorList     = hTaxExpCommon:buffer-field("ErrorList"):buffer-value
      NO-ERROR.
      {&ON-ERROR}

      IF mVerFormat EQ "" OR mVerFormat EQ "4" THEN DO:
         {additem.i vErrorList
                    hTaxExpBank:buffer-field(""ErrorList""):buffer-value}
         {additem.i vErrorList
                    hTaxExpCust:buffer-field(""ErrorList""):buffer-value}
         {additem.i vErrorList
                    hTaxExpAcct:buffer-field(""ErrorList""):buffer-value}
      END.
      ELSE 
         {additem.i vErrorList
                    hTaxExpInf:buffer-field(""ErrorList""):buffer-value}

         RUN FillErrorTable (INPUT        "ErrorTax",
                             INPUT        vErrorList,
                             OUTPUT TABLE ttError).

         mFlagError = CAN-FIND(FIRST ttError WHERE
                                     ttError.Type EQ "Ошибка").

 
      FOR FIRST PackObject WHERE 
                PackObject.surrogate EQ acct.acct + "," + acct.currency
                NO-LOCK,
           EACH Packet WHERE
                Packet.PacketID EQ PackObject.PacketID
                NO-LOCK:
           mPacketID = PackObject.PacketID.
      END.

      FOR FIRST Packet WHERE
                Packet.PacketID EQ mPacketID
                EXCLUSIVE-LOCK:
         DELETE Packet.
      END.

      CREATE Packet.                             /* Создаем пакет экспорта    */
      ASSIGN mPacketID            = next-value(pack-id)
             Packet.PacketID      = mPacketID
             Packet.AbonentID     = -1
             Packet.mail-user-num = mail-user.mail-user-num
             Packet.SeanceID      = iSeanceID
             Packet.State         = (IF mFlagError
                                        THEN {&STATE-ERR}
                                        ELSE {&STATE-CRT})
             Packet.PackDate      = today
             Packet.PackTime      = Time
             Packet.mail-format   = {&TAX-EXP}
             Packet.Kind          = iKind
             Packet.Class-Code    = "PTax"
             Packet.ClassError    = vErrorClass
             Packet.PackError     = vErrorList
             Packet.User-ID       = userid("bisquit")
             Packet.Filial-ID     = shFilial
      NO-ERROR.
      {&ON-ERROR}

      VALIDATE Packet NO-ERROR.
      {&ON-ERROR}


      RUN PacketCreateLink(Packet.PacketID,
                           "acct",
                            acct.acct + "," + acct.currency,
                            (IF acct.close-date EQ ? THEN {&CONF-EXP-TAX-OPEN}
                                                     ELSE {&CONF-EXP-TAX-CLOSE}))
                                                          NO-ERROR.

      {&ON-ERROR}

      IF (mVerFormat EQ "5" OR mVerFormat EQ "CH")
        AND NOT {assigned vErrorList} THEN DO:
         RUN CrReference(INPUT  today,
                         INPUT  "RTaxFile",
                         INPUT  Packet.PacketID).

      END.
      ELSE
         RUN CrReference(INPUT  DATE("01/01/" + string(year(gend-date),"99999")),
                         INPUT  "RTaxFile",
                         INPUT  Packet.PacketID).

      RUN CrReference(INPUT  DATE("01/01/" + string(year(gend-date),"99999")),
                      INPUT  "RTaxRec",
                      INPUT  Packet.PacketID).

      RUN SetSysConf IN h_base ("TaxAcctID",acct.cust-cat + "," +
                                STRING(acct.cust-id)      + "," + acct.acct).
      IF {assigned mOpKindKind} THEN
         RUN SetSysConf IN h_base ("TaxOpKindKind",mOpKindKind).

      CASE acct.cust-cat:
          WHEN "Ю" THEN
          DO:
             FIND FIRST cust-corp
                  WHERE cust-corp.cust-id EQ acct.cust-id NO-LOCK NO-ERROR.
             IF AVAIL   cust-corp THEN
                   vRefValue  = cust-corp.tax-insp.
          END.
          WHEN "Ч" THEN
          DO:
             FIND FIRST person
                  WHERE person.person-id EQ acct.cust-id NO-LOCK NO-ERROR.
             IF AVAIL   person THEN
                   vRefValue  = person.tax-insp.
          END.
      END CASE.

      RUN PacketCreateRef(today,
                          Packet.PacketID,
                          "RTaxCli",
                          vRefValue ).

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("CrReference","gend-date:" + STRING(gend-date) +
                                    " iClass:"   + "RTaxCli"         +
                                    " acct:"     + acct.acct         +
                                    " RefValue:" + vRefValue).
      &ENDIF


      ASSIGN
         vNameFile = GetMangledName("ИдФайл")
         vNameMess = GetMangledName("ИдДок")
         hTaxExpCommon:buffer-field(vNameFile):buffer-value =
            CalcMaskValue(hTaxExpCommon:buffer-field(vNameFile):buffer-value,
                          Packet.PacketID,
                          "",
                          gend-date) NO-ERROR.

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("CrReference","mask:" + hTaxExpCommon:buffer-field(vNameFile):buffer-value).
      &ENDIF

      IF mVerFormat EQ "" THEN
         ASSIGN
            hTaxExpCust:buffer-field(vNameMess):buffer-value =
                CalcMaskValue(hTaxExpCust:buffer-field(vNameMess):buffer-value,
                             Packet.PacketID,
                             "",
                             gend-date)
         NO-ERROR.
      ELSE IF mVerFormat EQ "4" THEN
         ASSIGN
            hTaxExpBank:buffer-field(vNameMess):buffer-value =
                CalcMaskValue(hTaxExpBank:buffer-field(vNameMess):buffer-value,
                             Packet.PacketID,
                             "",
                             gend-date)
         NO-ERROR.
      ELSE IF mVerFormat GE "5" OR mVerFormat EQ "CH" THEN
         ASSIGN
            hTaxExpInf:buffer-field(vNameMess):buffer-value =
                CalcMaskValue(hTaxExpCommon:buffer-field(vNameFile):buffer-value,
                             Packet.PacketID,
                             "",
                             today) + "000001"
         NO-ERROR.
      {&ON-ERROR}


       IF hTaxExpCommon:buffer-field(GetMangledName("ТипИнф")):buffer-value EQ "СООБЩИЗМЕН"
          AND GetMangledName("ПризнИзмСч") EQ "0"
          AND LOOKUP(GetMangledName("ПризнИзмКО"),"1,2,3,6,7") NE 0
          THEN hTaxExpCommon:buffer-field(GetMangledName("ТипИнф")):buffer-value = "ЕДИНСООБЩ".


      RUN PacketTextClear(mPacketID).

      RUN ExportOneClass (hTaxExpCommon, "TaxExpCommon"  + mVerFormat, mPacketID).
      IF mVerFormat EQ "4" THEN
         RUN ExportOneClass (hTaxExpTaxInsp,"TaxExpTaxInsp" + mVerFormat, mPacketID).

      IF mVerFormat EQ "" OR mVerFormat  EQ "4" THEN DO:
         RUN ExportOneClass (hTaxExpBank,   "TaxExpBank"    + mVerFormat, mPacketID).
         RUN ExportOneClass (hTaxExpCust,   "TaxExpCust"    + mVerFormat, mPacketID).
         RUN ExportOneClass (hTaxExpAcct,   "TaxExpAcct"    + mVerFormat, mPacketID).
      END.
      ELSE IF mVerFormat  EQ "5" OR mVerFormat EQ "CH" THEN DO:
         RUN ExportOneClass (hTaxExpInf,   "TaxExpInf"      + mVerFormat, mPacketID).
         vMessNum = GetMangledName("НомСооб").

         IF NOT UpdateSigns("Packet",         /* Сохранение статуса объекта*/
                            STRING(Packet.PacketID),
                            "StateOBJ",
                            hTaxExpInf:buffer-field(vMessNum):buffer-value, 
                            ?) THEN
            UNDO MAIN, RETRY MAIN.
      END.
      ELSE IF mVerFormat  EQ "CH5" THEN DO:
         RUN ExportOneClass (hTaxExpCommon, "TaxExpCommonCH", mPacketID).
         RUN ExportOneClass (hTaxExpInf,   "TaxExpInfCH5", mPacketID).
         RUN ExportOneClass (hTaxExpInfB,  "TaxExpInfCHB", mPacketID).
         vMessNum = GetMangledName("НомСооб").

         IF NOT UpdateSigns("Packet",         /* Сохранение статуса объекта*/
                            STRING(Packet.PacketID),
                            "StateOBJ",
                            hTaxExpInf:buffer-field(vMessNum):buffer-value, 
                            ?) THEN
            UNDO MAIN, RETRY MAIN.
      END.

&IF DEFINED(IS-DEBUG) &THEN
RUN dbgprint.p ("exp-tax.p","#").
&ENDIF

      RUN PacketTextSave (mPacketID, mResult).
      RUN SetValue in h_exch (hInstance,"PacketID",STRING(Packet.PacketID), 0) NO-ERROR.

      IF mVerFormat EQ "" OR mVerFormat  EQ "4" THEN DO:
         hTaxExpCommon:buffer-field ("ErrorList"):buffer-value  = "".
         hTaxExpBank:buffer-field   ("ErrorList"):buffer-value  = "".
         hTaxExpCust:buffer-field   ("ErrorList"):buffer-value  = "".
         hTaxExpAcct:buffer-field   ("ErrorList"):buffer-value  = "".
      END.
      ELSE IF mVerFormat  GE "5" OR mVerFormat EQ "CH" THEN
         hTaxExpInf:buffer-field    ("ErrorList"):buffer-value  = "".
      vFlagSet = YES.
   END.
   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE ExportOneClass:
   DEFINE INPUT PARAMETER iBuffer   AS handle   NO-UNDO.
   DEFINE INPUT PARAMETER iClass    AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iPacketID    AS INT64   NO-UNDO.


   DEFINE VAR vValue     AS CHAR    NO-UNDO.
   DEFINE VAR vAttr      AS CHAR    NO-UNDO.
   DEFINE VAR vTag       AS CHAR    NO-UNDO.
   DEFINE VAR vDate      AS DATE    NO-UNDO.
   DEFINE VAR vErrorList AS CHAR    NO-UNDO.
   DEFINE VAR vPrevErr   AS CHAR    NO-UNDO.
   DEFINE VAR i          AS INT64 NO-UNDO.
   DEFINE VAR oK         AS LOGICAL NO-UNDO.

   FIND FIRST Packet WHERE Packet.PacketID EQ iPacketID
        NO-LOCK NO-WAIT NO-ERROR.
   IF AVAIL Packet THEN            
      vPrevErr = Packet.PackError.

   IF {assigned vPrevErr} THEN             
   DO i = 1 TO NUM-ENTRIES(vPrevErr):
       RUN AddErrorFormat IN h_exch (iBuffer,ENTRY(i,vPrevErr)). 
   END.

   FOR EACH xattr WHERE
            xattr.class-code EQ iClass
        AND xattr.order      GE 1
        AND xattr.order      LT 999
            NO-LOCK BY xattr.order:

      vAttr  = GetMangledName(xattr.xattr-code).
      vTag   = IF   xattr.xattr-code BEGINS "Конец" THEN ""
               ELSE xattr.xattr-code + ":".
      vValue = GetValue(iBuffer,vAttr).

      IF NOT {assigned vValue}      AND
         xattr.xattr-label NE "П"   THEN NEXT.

      RUN CheckTaxAttr(BUFFER xattr,
                      INPUT   vValue,
                      OUTPUT  vErrorList,
                      OUTPUT  Ok).
      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("ExportOneClass"," iClass:"     + GetNullSTR(iClass)     +
                                       " vAttr:"      + GetNullSTR(vAttr)      +
                                       " vTag:"       + GetNullSTR(vTag)       +
                                       " vValue:"     + GetNullSTR(vValue)     +
                                       " vErrorList:" + GetNullSTR(vErrorList) +
                                       " ok:"     + STRING(ok)).
      &ENDIF

      IF {assigned vErrorList} THEN DO:
            RUN AddErrorFormat IN h_exch (iBuffer,vErrorList).
   
            RUN FillErrorTable (INPUT        "ErrorTax",
                                INPUT        GetValue (iBuffer,"ErrorList"),
                                OUTPUT TABLE ttError).
   
            mFlagError = CAN-FIND(FIRST ttError WHERE
                                        ttError.Type EQ "Ошибка").
         &IF DEFINED(IS-DEBUG) &THEN
         RUN dbgprint.p ("ExportOneClass"," vErrorList:" + GetNullSTR(vErrorList)  +
                                          " mFlagError:" + GetNullSTR(STRING(mFlagError))).
         &ENDIF
   
         FIND FIRST Packet WHERE Packet.PacketID EQ iPacketID
              EXCLUSIVE-LOCK NO-WAIT.
         IF AVAIL Packet THEN DO:

            {additem.i Packet.PackError vErrorList}
            ASSIGN Packet.State     = {&STATE-ERR} WHEN     mFlagError
                   Packet.State     = {&STATE-CRT} WHEN NOT mFlagError.
         END.
      END.
      IF NOT ok THEN NEXT.

      IF xattr.data-type EQ "date" THEN DO:
         ASSIGN vDate  = DATE(vVAlue) NO-ERROR.
         IF NOT ERROR-STATUS:ERROR THEN
         ASSIGN
            vValue = STRING(vDate,xattr.data-format).
      END.

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("ExportOneClass","mPacketID:" + GetNullSTR(string(mPacketID))  +
                                     " vTag:"   + GetNullSTR(vTag)                   +
                                     " vValue:" + GetNullSTR(string(vValue))         +
                                     " ok:"     + STRING(ok)).
      &ENDIF

      RUN PacketTextKeep (INPUT        mPacketID,
                          INPUT        vTag + vValue + "~n",
                          INPUT-OUTPUT mResult).
      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("ExportOneClass","mPacketID:" + GetNullSTR(string(mPacketID)) +
                                       " mResult:"  + GetNullSTR(mResult)  ).
      &ENDIF

   END.

END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE CheckTaxAttr.
   DEFINE PARAMETER BUFFER xattr      FOR xattr.
   DEFINE INPUT  PARAMETER iValue     AS CHAR    NO-UNDO.
   DEFINE OUTPUT PARAMETER oErrorList AS CHAR    NO-UNDO.
   DEFINE OUTPUT PARAMETER oK         AS LOGICAL NO-UNDO.

   DEFINE VAR vLength    AS INT64                  NO-UNDO.
   DEFINE VAR vProcName  AS CHAR                 NO-UNDO.
   DEFINE VAR vParams    AS CHAR                 NO-UNDO.
   DEFINE VAR vErrorList AS CHAR                 NO-UNDO.

   DEF BUFFER ErrXattr FOR xattr.
                                       /* на реквизите может быть несколько ошибок */    
   Ok = YES.
   FOR EACH ErrXattr WHERE
            ErrXattr.class-code  EQ "ErrorTax"
        AND CAN-DO(xattr.xattr-clabel,ErrXattr.xattr-code)
        AND ErrXattr.Initial NE "" NO-LOCK:
                                       /* общая проверка реквизита */
      RUN CheckFullFieldValue (xattr.class-code,
                               xattr.xattr-code,
                               "",
                               iValue).
      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("CheckTaxAttr","xattr.xattr-code:" + GetNullStr(xattr.xattr-code) +
                                     " RETURN-VALUE:" + GetNullStr(RETURN-VALUE)).
      &ENDIF

      IF {assigned RETURN-VALUE} THEN DO:
         vErrorList = ErrXattr.xattr-code + " "   +
                      RETURN-VALUE        + "~n[" +
                      xattr.class-code    + ":"   +
                      xattr.xattr-code    + "]".

         {additem.i oErrorList vErrorList}
         RUN Fill-SysMes("","","-1",vErrorList).
         Ok = NO.
         LEAVE.
      END.

      IF ErrXattr.xattr-code EQ "Tax-000" THEN DO:
                                         /*  строгая проверка формата */
         vLength = IF INDEX(xattr.data-format,"(") NE 0
                      THEN INT64(SUBSTR(xattr.data-format,
                                      INDEX(xattr.data-format,"(") + 1,
                                      LENGTH(xattr.data-format) - 3))
                      ELSE LENGTH(xattr.data-format).
   
         &IF DEFINED(IS-DEBUG) &THEN
         RUN dbgprint.p ("CheckTaxAttr","xattr.xattr-code:" + GetNullStr(xattr.xattr-code) +
                                        " iValue:" + GetNullStr(iValue)).
         &ENDIF
   
         IF LENGTH(iValue) > vLength THEN DO:
            RUN Fill-SysMes("","","",ErrXattr.xattr-code + "[" +
                                     ErrXattr.name       + " " +
                                     xattr.class-code    + ":" +
                                     xattr.xattr-code    + " " +
                                     ErrXattr.Initial    + " " +
                                     GetNullStr(iValue)  + "]").
   
            vErrorList = ErrXattr.xattr-code + CHR(1) +
                         xattr.class-code  + ":" + xattr.xattr-code.
            {additem.i oErrorList vErrorList}
            OK = ErrXattr.Initial NE "Ошибка".
            LEAVE.
         END.
      END.                                 /* индивидуальный метод на ошибке */
      RUN GetClassMethod IN h_xclass (INPUT  ErrXattr.class-code,
                                      INPUT  "chkupd",
                                      INPUT  ErrXattr.xattr-code,
                                      INPUT  "",
                                      OUTPUT vProcName,
                                      OUTPUT vParams).

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("ExportOneClass","vProcName:" + GetNullStr(vProcName)).
      &ENDIF

      IF {assigned vProcName} THEN DO:              /* Вызов найденного метода   */
         {exch-run.i &Proc      = vProcName
                     &Parm      = "iValue" 
                     &NoMessage = "YES"
         }
         IF ERROR-STATUS:ERROR THEN DO:
            RUN Fill-SysMes("","ComnExc01","","%s=" + vProcName +
                                              "%s=" + ERROR-STATUS:get-message(1)).
            Ok = NO.
            LEAVE.
         END.

         &IF DEFINED(IS-DEBUG) &THEN
         RUN dbgprint.p ("CheckTaxAttr","xattr.xattr-code:" + GetNullStr(xattr.xattr-code) +
                                        " RETURN-VALUE:" + GetNullStr(RETURN-VALUE) +
                        "vProcName:" + GetNullStr(vProcName)).
         &ENDIF
   
         IF {assigned RETURN-VALUE} THEN DO:
            RUN Fill-SysMes("","","", ErrXattr.xattr-code + "[" +
                                      ErrXattr.name       + " " +
                                      xattr.class-code    + ":" +
                                      xattr.xattr-code    + " " +
                                      ErrXattr.Initial    + " " +
                                      GetNullStr(iValue)  + "]").
            {additem.i oErrorList ErrXattr.xattr-code}
            Ok = ErrXattr.Initial NE "Ошибка".
            NEXT.
         END.
      END.
   END.
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE CrReference:
   DEFINE INPUT  PARAMETER iDate       AS DATE  NO-UNDO.
   DEFINE INPUT  PARAMETER iClassCode  AS CHAR  NO-UNDO.
   DEFINE INPUT  PARAMETER iPacketID   AS CHAR  NO-UNDO.

   DEFINE VAR vRefValue    AS INT64           NO-UNDO.
   DEFINE VAR vFlagSet     AS LOGICAL  INIT ?   NO-UNDO.

MAKE:
   DO TRANSACTION ON ERROR UNDO MAKE, RETRY MAKE:
      {do-retry.i MAKE}


      vRefValue = INT64(ReferenceGetLast(iClassCode,iDate)).

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("CrReference","iDate:" + string(iDate) +
                                  " iClass:" + iClassCode    +
                                " RefValue:" + string(vRefValue)).
      &ENDIF

      RUN PacketCreateRef(iDate,
                          iPacketID,
                          iClassCode,
                          ReferenceFormatValue(iClassCode,
                                STRING(vRefValue + 1))).
      vFlagSet = YES.
   END.

   {doreturn.i vFlagSet}
END PROCEDURE.
/******************************************************************************/
