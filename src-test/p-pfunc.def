/*
               Банковская интегрированная система БИСквит
    Copyright: (C) 1992-2006 ЗАО "Банковские информационные системы"
     Filename: P-PFUNC.DEF
      Comment: Парсерные функции модуля ЧВ для расчета процентов
   Parameters:
         Uses:
      Used by: dpspars.p
      Created: 26.10.2006 16:55 fEAk    
     Modified: 18.12.2007 14:49 fEAk     <comment>
*/

DEFINE VARIABLE vPPFuncList AS CHARACTER   NO-UNDO.
vPPFuncList = ",НачЗакр"
   + ",Начисл,НачислДень,НачислПр,НачислСчет"
   + ",НачШтраф,НачШтрНач"
   + ",НчВыдПроц,НчДень,НчПрогресс,НчПрогрессДт"
   + ",ПерерасчКап,ПерерасчПроц,ПерерасчПроцДт"
   + ",НачПрол,НачПрПрол"
   + ",ИзлишВыплачПроц,ИзлишВыплачПроцПрошл"
   + ",ИзлишПроцВалДЗ,ИзлишПроцРубДЗ,ИмеетПериодДЗ,ИзлишВыпНеотн,НуженПересч,выплачпроц,излишпроц".

&GLOBAL-DEFINE p-pfunc vPPFuncList

/* Вспомогательные процедуры */

/*Простейшая функция для поиска последнего начисления %% на счет клиента */
PROCEDURE last-nach-int.
   DEF INPUT PARAMETER rid1 as RECID NO-UNDO.
   DEF INPUT PARAMETER in-date as DATE NO-UNDO.
   DEF OUTPUT PARAMETER data AS DATE INIT ?.

   DEF VAR in-inter AS CHAR NO-UNDO.
   find first loan where recid(loan) = rid1 no-lock no-error .
   if not avail loan then RETURN.
   FIND LAST loan-acct of loan where loan-acct.acct-type = 'loan-dps-t'
                                 and loan-acct.since <= in-date NO-LOCK NO-ERROR.
   IF NOT AVAILABLE loan-acct THEN RETURN.
   FIND LAST kau-entry WHERE kau-entry.acct = loan-acct.acct AND
                             kau-entry.currency = loan-acct.currency AND
                             kau-entry.kau = loan.contract + ',' + loan.cont-code + ','  + 'НачПрС1'AND
                             NOT kau-entry.debit AND
                             kau-entry.op-date < in-date NO-LOCK NO-ERROR.
   IF AVAILABLE kau-entry THEN do:
      FIND op OF kau-entry NO-LOCK NO-ERROR.
      IF AVAIL op THEN ASSIGN data = op.contract-date.
   END.

END PROCEDURE.

/*Простейшая функция для поиска последней выплаты %% */
PROCEDURE last-nach-pay.
   DEF INPUT PARAMETER rid1 as RECID NO-UNDO.
   DEF INPUT PARAMETER in-date as DATE NO-UNDO.
   DEF INPUT PARAMETER beg-date as DATE NO-UNDO.
   DEF OUTPUT PARAMETER data AS DATE INIT ?.
   DEF OUTPUT PARAMETER amt AS DEC INIT 0.

   DEF VAR in-inter AS CHAR NO-UNDO.
   DEF VAR d1       AS DATE NO-UNDO.

   find first loan where recid(loan) = rid1 no-lock no-error .
   if not avail loan then RETURN.
   run Get_Last_Param in h_dpspc (rid1,in-date,in-date,'КодОпВыд',output in-inter).
   FIND LAST loan-acct of loan where loan-acct.acct-type = 'loan-dps-t'
                                 and loan-acct.since <= in-date NO-LOCK NO-ERROR.
   IF NOT AVAILABLE loan-acct THEN RETURN.
   FIND LAST kau-entry WHERE kau-entry.acct = loan-acct.acct AND
                             kau-entry.currency = loan-acct.currency AND
                             kau-entry.kau = loan.contract + ',' + loan.cont-code + ','  + 'НачПрС1'AND
                             kau-entry.debit AND
                             kau-entry.op-date < in-date AND
                             kau-entry.op-date > beg-date AND
                             CAN-FIND(op-entry OF kau-entry WHERE CAN-DO(in-inter,op-entry.op-cod)) NO-LOCK NO-ERROR.
   IF AVAILABLE kau-entry THEN do:
      ASSIGN
         d1 = kau-entry.op-date
         amt = 0.
      FOR EACH kau-entry WHERE kau-entry.acct = loan-acct.acct AND
                               kau-entry.currency = loan-acct.currency AND
                               kau-entry.kau = loan.contract + ',' + loan.cont-code + ','  + 'НачПрС1'AND
                               kau-entry.debit AND
                               kau-entry.op-date = d1 AND
                               CAN-FIND(op-entry OF kau-entry WHERE CAN-DO(in-inter,op-entry.op-cod)) NO-LOCK,
          FIRST op OF kau-entry NO-LOCK:
          ASSIGN
             data = op.contract-date
             amt = amt + (IF (loan.currency = FGetSetting("КодНацВал",?,?) OR loan.currency = "") THEN kau-entry.amt-rub ELSE kau-entry.amt-cur)
          .
      END.
   END.

END PROCEDURE.

FUNCTION nch RETURN DECIMAL (s1 AS DEC, beg-date AS DATE, end-date AS DATE,in-commi AS char, in-interest AS CHAR, in-acct AS CHAR ).
   DEF VAR ndays AS INT64 NO-UNDO.
   FIND FIRST acct WHERE acct.acct = in-acct NO-LOCK NO-ERROR.
  {findcom1.i &dir=LAST
               &comm-rate=comm-rate
               &rsum=0
               &rcom=in-commi
               &since1= " <= end-date "
    }
    ndays = end-date - beg-date + 1.
    {findsch.i &dir    = LAST
               &sch    = in-interest 
               &since1 =" LT end-date"}
    IF AVAIL comm-rate  AND AVAIL interest-sch-line 
    THEN RETURN round(s1 * comm-rate.rate-comm * ndays / (interest-sch-line.basis-time * 100) ,2) .
/*Прототип!!!*/
END FUNCTION.


/* Парсерные функции */ 

/*  Что делает: ф-ция НачЗакр при закрытии расчитывает проценты за период до даты
**              закрытия минус 1 день. При досрочном закрытии 1 день не вычитается. 
**  Синтаксис : НачЗакр(обязат назначение, 
                        обязат Тип. дог, 
                        необязат Печать):deicmal
**  Пример    : РефНач("dps",*,Да)
*/
PROCEDURE НачЗакр:
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   def var h_templ as handle no-undo.
   def var beg-date as date no-undo.
   def var in-surrogate as char no-undo.
   def var in-commi like commission.commi no-undo.
   def var in-interest like interest-sch.interest no-undo.
   def var str-kau like kau.kau no-undo.
   def var dat-t as date no-undo.
   def var result as decimal no-undo.
   def buffer cacct for acct.
   def var ii as INT64 no-undo.
   def var fl as INT64 init -1.
   def var cod-ost as char no-undo.
   def var result1 as decimal no-undo.
   def buffer yop-templ for op-templ.
   def var end-dat1 as date no-undo.
   def var e-dat as date no-undo.
   def var fl-print as logical init yes no-undo.
   def var nach_end as logical no-undo.
   def var d1 as INT64 init 0 no-undo.
   DEF VAR vResult AS    DECIMAL  NO-UNDO.
   /* --- */
   remove-amt = 0.
   
   IF param-count NE 2 AND param-count NE 3 THEN 
        RETURN.
   
   if param-count EQ 3 then
      if GetParam(3, param-str) EQ 'нет'  then fl-print = no.
   nach_end = FGetSetting("NachEndLoan",?,'Да') eq 'Да'.
   
   /* Определение правильного применения функции,
   ** формат private-data */
   run DPS_VALID_HANDLE (input-output h_templ).
   
   if not valid-handle(h_templ) then DO:
      pick-value = STRING(0).
      RETURN.
   END.

   FIND FIRST wop WHERE RECID(wop) EQ rid NO-LOCK NO-ERROR.
   IF NOT AVAIL wop THEN DO:
      pick-value = STRING(0).
      RETURN.
   END.
   
   run RE_B_LOAN (GetParam(1, param-str),
                  entry(1,substring(h_templ:private-data,6)),
                  buffer loan).
   
   if not avail loan then DO:
      pick-value = STRING(0).
      RETURN.
   END.
   in-surrogate = loan.contract + ',' + loan.cont-code.
   find op-templ where op-templ.op-kind eq loan.op-kind and
     op-templ.op-templ eq loan.op-templ no-lock no-error.
   if not avail op-template then DO:
      pick-value = STRING(0).
      RETURN.
   END.
   if not can-do(replace(replace(GetParam(2, param-str),"!",","),"'",""),loan.cont-type) then DO:
      pick-value = STRING(0).
      RETURN.
   END.
   cod-ost =  Get-ost(wop.op-kind).
   if cod-ost eq ? then DO:
      pick-value = STRING(0).
      RETURN.
   END.
   cod-ost = loan.contract + ',' + loan.cont-code + ',' + cod-ost.
   beg-date = Get-Beg-Date(cod-ost,in-op-date).
   if beg-date eq ? then DO:
      pick-value = STRING(0).
      RETURN.
   END.
   if loan.end-date eq ? then
     find last loan-acct of loan where loan-acct.acct-type eq 'loan-dps-p'
      and loan-acct.since le in-op-date no-lock no-error.
   else
    find last loan-acct of loan where loan-acct.acct-type eq  'loan-dps-t' and loan-acct.since le in-op-date
       no-lock no-error.
    if avail loan-acct then
     find first acct where acct.acct eq loan-acct.acct and
    acct.currency eq loan-acct.currency no-lock no-error.
   if not avail acct then DO:
      pick-value = STRING(0).
      RETURN.
   END.
   in-surrogate  =  op-templ.op-kind + ',' + string(op-templ.op-templ).
   d1 = INT64(GetXAttrValueEx("op-template",in-surrogate,"delay","-1")) NO-ERROR.
   IF ERROR-STATUS:ERROR THEN d1 = -1.
   
   result = 0.
   str-kau = loan.contract + ',' + loan.cont-code  + ","  +  (if loan.end-date eq ? then 'ОстВклВ' else 'ОстВклС').
   /* Определяем дату окончания начисления */
   e-dat = wop.con-date.
   if loan.end-date ne ? and loan.end-date le e-dat  and beg-date lt loan.end-date then
     end-dat1 = loan.end-date.
   else  end-dat1 = e-dat.
   if end-dat1 = e-dat or (not nach_end and end-dat1 = loan.end-date) then end-dat1 = end-dat1 + d1.
   
   /* Определяем комиссию и схему */
   RUN Get_Last_Commi in h_dpspc (RECID(loan),beg-date,end-dat1,OUTPUT in-commi).
   RUN Get_Last_Inter in h_dpspc (RECID(loan),beg-date,end-dat1,OUTPUT in-interest).
   IF in-commi    = ? OR in-commi    = "?" OR
      in-interest = ? OR in-interest = "?" THEN DO:
      pick-value = STRING(0).
      RETURN.
   END.
   
   /* 1й цикл расчета - начисление до окончания срока вклада */
   do while  beg-date lt end-dat1  :
     result = 0.
     result1 = 0.
     fl = 0.
     {findsch.i &dir=first &sch=in-interest &since1=" gt beg-date and interest-sch-line.since le end-dat1"}
     if avail interest-sch-line then  dat-t = interest-sch-line.since.
     else dat-t = end-dat1.
     release interest-sch-line.
     {findsch.i &dir=last &sch=in-interest &since1 =" lt dat-t"}
     if avail interest-sch-line then
      run  nachkin.p(
       recid(interest-sch-line),
       in-commi,
       recid(acct),dat-t,str-kau,fl-print,output result,output result1,input-output beg-date,output fl) .
       beg-date = dat-t.
     if fl ne 0 then DO:
        ASSIGN
           remove-amt = 0
           pick-value = STRING(0)
           .
        RETURN.
     END.          
     ASSIGN
          vResult           = vResult + result
          remove-amt        = remove-amt + result1
          beg-date          = dat-t
     .
   end.
   
   /* 2й цикл расчета - доначисление после окончания срока вклада */
   if nach_end and end-dat1 lt e-dat then do:
      beg-date = end-dat1.
      end-dat1 = e-dat.
      end-dat1 = end-dat1 + d1.
   
      /* Еще раз определяем комиссию и схему */
      RUN Get_Last_Commi in h_dpspc (RECID(loan),beg-date,end-dat1,OUTPUT in-commi).
      RUN Get_Last_Inter in h_dpspc (RECID(loan),beg-date,end-dat1,OUTPUT in-interest).
      IF in-commi    = ? OR in-commi    = "?" OR
         in-interest = ? OR in-interest = "?" THEN DO:
         pick-value = STRING(0).
         RETURN.
      END.
   
      do while beg-date lt end-dat1:
        {findsch.i &dir=first &sch=in-interest &since1=" gt beg-date and interest-sch-line.since le end-dat1"}
        if avail interest-sch-line then  dat-t = interest-sch-line.since.
        else dat-t = end-dat1.
        release interest-sch-line.
        {findsch.i &dir=last &sch=in-interest &since1 =" lt dat-t"}
        if avail interest-sch-line then
           run  nachkin.p(
                          recid(interest-sch-line),
                          in-commi,
                          recid(acct),dat-t,str-kau,fl-print,output result,output result1,input-output beg-date,output fl).
        beg-date = dat-t.
        if fl ne 0 then DO:
           ASSIGN
              remove-amt = 0
              pick-value = STRING(0)
              .
           RETURN.
        END.           
        ASSIGN
           vResult           = vResult + result
           remove-amt        = remove-amt + result1.
           beg-date          = dat-t
        .
      end.
   end.
   pick-value = STRING(vResult).
END PROCEDURE.


/*  Что делает: Старое начисление процентов без учета смены счета. (НЕ ПОДДЕРЖИВАЕТСЯ)
**  Синтаксис : Начисл(обязат назначение, 
                       обязат Тип. дог, 
                       необязат Печать):deicmal
**  Пример    : Начисл("dps",*,Да)
*/
PROCEDURE Начисл:
    DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
    DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
    DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
    DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

    def var h_templ as handle no-undo.
    def var beg-date as date no-undo.
    def var in-surrogate as char no-undo.
    def var in-commi like commission.commi no-undo.
    def var in-interest like interest-sch.interest no-undo.
    def var str-kau like kau.kau no-undo.
    def var dat-t as date no-undo.
    def var result as decimal no-undo.
    def buffer cacct for acct.
    def var ii as INT64 no-undo.
    def var fl as INT64 init -1.
    def var cod-ost as char no-undo.
    def var result1 as decimal no-undo.
    def buffer yop-templ for op-templ.
    def var end-dat1 as date no-undo.
    def var fl-print as logical init yes no-undo.
    def var nach_end as logical no-undo.
    DEF VAR vResult  AS DECIMAL NO-UNDO.
    DEF VAR is-ok    AS LOGICAL NO-UNDO.
    DEF VAR pen AS LOGICAL NO-UNDO. /*Доначисление по штрафной ставке или
                                      по ставке пролонгации */

    remove-amt = 0.
    IF param-count LT 2 OR param-count GT 4 THEN
       RETURN.
    pen = if param-count EQ 4 AND GetParam(4, param-str) eq 'Штр' THEN YES 
                                                                  ELSE NO.
    fl-print = if param-count GE 3 AND GetParam(3, param-str) eq 'нет' then no
                                                                       else yes.

    /*разбор необязательных параметров в случае передачи 3 параметров*/
    IF param-count EQ 3 THEN DO:
      IF GetParam(3, param-str) EQ "Да" OR GetParam(3, param-str) EQ 'нет' THEN DO:
        IF GetParam(3, param-str) EQ "Да" THEN fl-print = YES.
        ELSE fl-print = NO.
        pen = NO.
      END.
      IF GetParam(3, param-str) = "штр" THEN DO:
        ASSIGN
         fl-print = YES
         pen = YES.
      END.
    END.

    /* Определение правильного применения функции,
    ** формат private-data */
    run DPS_VALID_HANDLE (input-output h_templ).

    if not valid-handle(h_templ) then DO:
       pick-value = STRING(0).
       RETURN.
    END.

    FIND FIRST wop WHERE RECID(wop) EQ rid NO-LOCK NO-ERROR.
    IF NOT AVAIL wop THEN DO:
       pick-value = STRING(0).
       RETURN.
    END.

    nach_end = FGetSetting("NachEndLoan",?,'Да') eq 'Да'.
    find loan  where loan.contract eq GetParam(1, param-str) and
                     loan.cont-code eq entry(1,substring(h_templ:private-data,6)) no-lock no-error.
    if not avail loan then DO:
       pick-value = STRING(0).
       RETURN.
    END.
    in-surrogate = loan.contract + ',' + loan.cont-code.
    find op-templ where op-templ.op-kind eq loan.op-kind and
        op-templ.op-templ eq loan.op-templ no-lock no-error.
    if not avail op-template then DO:
       pick-value = STRING(0).
       RETURN.
    END.
    if not can-do(replace(replace(GetParam(2, param-str),"!",","),"'",""),loan.cont-type) then DO:
       pick-value = STRING(0).
       RETURN.
    END.
    cod-ost =  Get-ost(wop.op-kind).
    if cod-ost eq ? then DO:
       pick-value = STRING(0).
       RETURN.
    END.
    cod-ost = loan.contract + ',' + loan.cont-code + ',' + cod-ost.

    beg-date = Get-Beg-Date(cod-ost,wop.con-date).
    if beg-date eq ? then DO:
       pick-value = STRING(0).
       RETURN.
    END.
    if loan.end-date eq ? then
        find last loan-acct of loan where loan-acct.acct-type eq 'loan-dps-p'
            and loan-acct.since le in-op-date no-lock no-error.
    else
        find last loan-acct of loan where loan-acct.acct-type eq  'loan-dps-t' and loan-acct.since le in-op-date
            no-lock no-error.
    if avail loan-acct then
        find first acct where acct.acct eq loan-acct.acct and
            acct.currency eq loan-acct.currency no-lock no-error.
    if not avail acct then DO:
       pick-value = STRING(0).
       RETURN.
    END.

    result = 0.
    str-kau = loan.contract + ',' + loan.cont-code  + ","  +  (if loan.end-date eq ? then 'ОстВклВ' else 'ОстВклС').
    /* Определяем дату окончания начисления */
    if loan.end-date ne ? and loan.end-date le wop.con-date and beg-date lt loan.end-date  then
        end-dat1 = loan.end-date.
    else if (loan.end-date ne ? and loan.end-date gt wop.con-date) or
        (loan.end-date eq ? /*and loan.prolong eq 0 */) then
        end-dat1 = wop.con-date.
        else end-dat1 = if not nach_end then  beg-date else wop.con-date.

    /* Определяем код комиссии и схему на указанную дату */
    RUN Get_Last_Commi in h_dpspc (RECID(loan),beg-date,end-dat1,OUTPUT in-commi).
    RUN Get_Last_Inter in h_dpspc (RECID(loan),beg-date,end-dat1,OUTPUT in-interest).
    IF in-commi    = ? OR in-commi    = "?" OR
       in-interest = ? OR in-interest = "?" THEN DO:
       pick-value = STRING(0).
       RETURN.
    END.

    do while  beg-date lt end-dat1  :
        result = 0.
        result1 = 0.
        fl = 0 .
        {findsch.i &dir=first &sch=in-interest &since1=" gt beg-date and interest-sch-line.since le end-dat1"}
        if avail interest-sch-line then  dat-t = interest-sch-line.since.
        else dat-t = end-dat1.
        release interest-sch-line.
        {findsch.i &dir=last &sch=in-interest &since1 =" lt dat-t"}
        if avail interest-sch-line then
            run  nachkin.p(
                            recid(interest-sch-line),
                            in-commi,
                            recid(acct),dat-t,str-kau,fl-print,output result,output result1,input-output beg-date,output fl) .
        beg-date = dat-t.
        if fl ne 0 then DO:
           ASSIGN
              remove-amt = 0
              pick-value = STRING(0)
              .
           RETURN.
        END.
        ASSIGN
            vResult           = vResult + result
            remove-amt        = remove-amt + result1
            beg-date          = dat-t
            .
    END.
    if end-dat1 lt wop.con-date and nach_end then do :
        beg-date = end-dat1.
        end-dat1 = wop.con-date.
        in-surrogate = loan.op-kind + ',' + string(loan.op-templ).
        IF pen THEN DO:
          /*начисление по штрафной ставке за оставшиеся дни*/
          {parsrat1.i Get_Last_Pen_Inter Get_Last_Pen-Commi}
        END.
        ELSE DO:
          /*начисление по ставке пролонгации за оставшиеся дни*/
          {parsrat1.i Get_Last_Inter Get_Last_Commi}
        END.
        do while  beg-date lt end-dat1  :
            fl = 0.
            {findsch.i &dir=first &sch=in-interest &since1=" gt beg-date and interest-sch-line.since le end-dat1"}
            if avail interest-sch-line then  dat-t = interest-sch-line.since.
            else dat-t = wop.con-date.
            release interest-sch-line.
            {findsch.i &dir=last &sch=in-interest &since1 =" lt dat-t"}
            if avail interest-sch-line then
                run  nachkin.p(
                                recid(interest-sch-line),
                                in-commi,
                                recid(acct),dat-t,str-kau,fl-print,output result,output result1,input-output beg-date,output fl) .
            beg-date = dat-t.
            if fl ne 0 then DO:
               ASSIGN
                  remove-amt = 0
                  pick-value = STRING(0)
                  .
               RETURN.
            END.
            ASSIGN
                vResult           = vResult + result
                remove-amt        = remove-amt + result1
                beg-date          = dat-t
                .
        END.
    END.
    pick-value = STRING(vResult).

END PROCEDURE.


/* Процедура, начисляющая проценты за последний день срока вклада. 
** Без учета пробега по основной или щтрафной ставке в зависимотсти от параметра
** Синтаксис : НачислДень (<начзначение договора>,
**                         <печать ведомости ["Да"/"Нет"]>, (по умолчанию "Да")
**                         <Осн/Штр> Основная/Штрафная ставка) 
**  Автор     : SAP 15/02/2004, заявка 0038051  
**  Пример    : НачислДень("dps","Нет","Осн"), НачислДень("dps","Да","Штр"), НачислДень("dps","Штр")
*/
PROCEDURE НачислДень.

   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   DEFINE VARIABLE vDpsHandle   AS HANDLE    NO-UNDO.            /* Указатель на параметры договора */
   DEFINE VARIABLE vBegDate     AS DATE      NO-UNDO.            /* Дата начала вклада*/
   DEFINE VARIABLE vEndDate     AS DATE      NO-UNDO.            /* Дата окончания вклада*/
   DEFINE VARIABLE vSurrChar    AS CHARACTER NO-UNDO.            /* Суррогат для поиска параметров вклада */
   DEFINE VARIABLE vCommiChar   AS CHARACTER NO-UNDO.            /* Код штрафной комиссии */
   DEFINE VARIABLE vInterChar   AS CHARACTER NO-UNDO.            /* Код штрафной схемы начисления %% */
   DEFINE VARIABLE vKauChar     AS CHARACTER NO-UNDO.            /* Код субсчета */
   DEFINE VARIABLE vFlPrintLog  AS LOGICAL   NO-UNDO.            /* Признак печати ведомости */
   DEFINE VARIABLE vAcctLstChar AS CHARACTER NO-UNDO.            /* Список основных счетов по вкаладу */
   DEFINE VARIABLE vBase        AS LOG       NO-UNDO.            /*По основной или штрафной ставке*/
   DEFINE VARIABLE RESULT       AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE result1      AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE delay        AS INT64   NO-UNDO .
   DEFINE VARIABLE fl           AS INT64   NO-UNDO INITIAL -1.
   DEFINE VARIABLE str-par      AS CHARACTER NO-UNDO.
   DEFINE VARIABLE beg-date     AS DATE      NO-UNDO.
   DEFINE VARIABLE vStr_tmp     AS CHARACTER NO-UNDO.

   FIND FIRST wop WHERE
         RECID( wop ) EQ rid.
   IF param-count > 3 OR param-count < 2 THEN
   DO:
      MESSAGE "Ошибочное количество параметров передано в функцию 'НачислДень' "
         VIEW-AS ALERT-BOX.
      RETURN.
   END.

   IF param-count GE 2 THEN
      vStr_tmp = GetParam( 2, param-str ).
   IF param-count = 3 THEN
      vStr_tmp =  vStr_tmp + ',' + GetParam( 3, param-str ).

   /*печать ведомости */
         IF CAN-DO(vStr_tmp,'Нет') THEN
            vFlPrintLog = NO .
         ELSE
            vFlPrintLog = YES .

         IF CAN-DO( vStr_tmp, 'Осн' ) THEN
            vBase = YES.
         ELSE
         DO:
            IF CAN-DO( vStr_tmp, 'Штр' ) THEN
               vBase = FALSE.
            ELSE
            DO:
               MESSAGE "Неправильные аргументы переданы в функцию 'НачислДень' " SKIP
                       "Не определена ставка (Осн или Штр)!"
                  VIEW-AS ALERT-BOX.
               RETURN.
            END.
         END.

         RUN DPS_VALID_HANDLE ( INPUT-OUTPUT vDpsHandle ).
   IF NOT VALID-HANDLE( vDpsHandle ) THEN
      RETURN.
   RUN RE_B_LOAN ( "DPS",
      ENTRY( 1, SUBSTRING( vDpsHandle:PRIVATE-DATA, 6 ) ),
      BUFFER loan ).
   IF NOT AVAILABLE loan THEN
      RETURN.

  /* проверка отсутствия начисления с датой > даты опер. дня */
   RUN chek_no_nach in h_dpspc ( RECID( loan ), in-op-date ).
   IF RETURN-VALUE = 'error' THEN
      RETURN.

   RUN get_acct in h_dpspc ( RECID( loan ), wop.con-date, wop.con-date,
      OUTPUT vAcctLstChar ).
   IF   vAcctLstChar = '' THEN
      RETURN.

   RUN get-beg-date-prol in h_dpspc ( RECID( loan ), wop.con-date, OUTPUT
         vBegDate, OUTPUT vEndDate).

   FIND FIRST acct WHERE
         acct.acct = ENTRY( 1, vAcctLstChar ) NO-LOCK NO-ERROR.

   IF NOT AVAILABLE acct THEN
      RETURN.

   vKauChar = loan.contract + ',' +
      loan.cont-code  + ","  +
      ( IF vEndDate EQ ?
      THEN 'ОстВклВ'
      ELSE 'ОстВклС' ).

   /*Основная ставка*/
   IF vBase THEN
   DO :
      RUN Get_Last_Commi in h_dpspc ( RECID( loan ), vBegDate, wop.con-date,
            OUTPUT vCommiChar ) .
      RUN Get_Last_Inter in h_dpspc ( RECID( loan ), vBegDate, wop.con-date,
            OUTPUT vInterChar ) .
   END.
   /*Штрафная ставка*/
   ELSE
   DO:
      RUN Get_Last_Pen_Inter in h_dpspc ( RECID( loan ), vBegDate, wop.con-date,
            OUTPUT vInterChar ) .

      RUN get_srok_vklad in h_dpspc ( RECID( loan ), wop.con-date, OUTPUT
            str-par ).
       /*Если вклад на два года или полтора закрывается досрочно, но год уже отлежал*/
      IF str-par = "-1" THEN
         RUN Get_Last_Commi in h_dpspc ( RECID( loan ), vBegDate, wop.con-date,
               OUTPUT vCommiChar ) .
      ELSE
         RUN Get_Last_Pen-Commi in h_dpspc ( RECID( loan ), vBegDate,wop.con-date,
               OUTPUT vCommiChar ) .
   END.

   IF vCommiChar = ? OR vCommiChar = '?' OR vInterChar = ? OR vInterChar = "?" THEN
      RETURN.

   {findsch.i &dir=LAST &sch=vInterChar &since1 =" <= wop.con-date"}

   IF NOT AVAILABLE interest-sch-line THEN
      RETURN.

   /*четко за последний день*/
   beg-date = wop.con-date - 1.

   RUN  nachkin.p( RECID( interest-sch-line ),
      vCommiChar,
      RECID( acct ),
      wop.con-date,
      vKauChar,
      vFlPrintLog,
      OUTPUT RESULT,
      OUTPUT result1,
      INPUT-OUTPUT beg-date,
      OUTPUT fl ) .

   IF fl NE 0 THEN
      RETURN.
   pick-value = STRING( RESULT ).
END PROCEDURE.


/*  Что делает: Начисление процентов за последний день срока вклада без учета
**              пробега по основной или штрафной ставке. Используется в транзакциях
**              досрочного закрытия вклада для анализа необходимости пересчета 
**              предварительно начисленных процентов.
**  Синтаксис : НачислПр(обязат Номер счета, 
                         обязат Валюта, 
                         обязат Субостаток):decimal
**  Пример    : НачислПр(Роль("loan-dps-t"),РольСчетВал("loan-dps-t"),"ОстВклС")
*/
PROCEDURE НачислПр:
  DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
  DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
  DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
  DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

  def var h_templ as handle no-undo.
  def var in-kau as char no-undo.
  def var cur1 like loan.currency no-undo.
  def var beg-date as date no-undo.
  def var in-surrogate AS CHAR no-undo.
  def var i AS INT64 NO-UNDO.
  DEF BUFFER yop-templ FOR op-template.
  def var vdate1 as date no-undo.
  def var vdate2 as date no-undo.

  DEF    VAR      mTmp-date         AS DATE       NO-UNDO.
  DEF    VAR      vResult           AS DEC        NO-UNDO.   

  IF param-count NE 3 THEN 
     RETURN.

  /* Определение правильного применения функции,
  ** формат private-data */
  run DPS_VALID_HANDLE (input-output h_templ).

  if not valid-handle(h_templ) then DO:
     pick-value = STRING(0).
     RETURN.
  END.

  run RE_B_LOAN ("DPS",
                 entry(1,substring(h_templ:private-data,6)),
                 buffer loan).

  if not avail loan then DO:
     pick-value = STRING(0).
     RETURN.
  END.

  FIND FIRST wop WHERE RECID(wop) EQ rid NO-LOCK NO-ERROR.
  IF NOT AVAIL wop THEN DO:
     pick-value = STRING(0).
     RETURN.
  END.

  in-kau = loan.contract + ',' + loan.cont-code + ',' +  string(GetParam(3, param-str)).
  if string(GetParam(2, param-str),"999") eq vNatCurrChar then cur1 = ''.
  else cur1 = string(GetParam(2, param-str),"999").

  beg-date = Get-Beg-Date-Obl(in-kau,wop.con-date).
  RUN get-beg-date-prol in h_dpspc (RECID(loan),
                                            wop.con-date,
                                            OUTPUT vdate1,
                                            OUTPUT vdate2).

  IF vdate1 GT beg-date THEN
     ASSIGN mTmp-date = vdate1 + 1.
  ELSE
     ASSIGN mTmp-date = beg-date + 1.

  /* Корректируем дату */
  RUN correct_date in h_dpspc (RECID(loan),
                                       INPUT-OUTPUT mTmp-date).
  IF mTmp-date LT wop.con-date THEN DO:
     RUN kau-pos.p(GetParam(1, param-str),cur1, mTmp-date, wop.con-date,gop-status,in-kau).

     /*если пролонгация прошла не плановой датой, убираем "лишние" обороты*/
     vResult = (IF cur1 EQ '' THEN ksh-cr
                              ELSE ksh-vcr) -
                unneces_credit(GetParam(1, param-str), mTmp-date,wop.con-date,in-kau,cur1) +
                necessary_credit(GetParam(1, param-str),mTmp-date,in-kau,cur1)
                .
     pick-value = STRING(vResult).
  END.
  ELSE
     pick-value = STRING(0).
end procedure.


/*  Что делает: Начисление процентов по вкладам. При закрытии вклада позже даты
**              окончания,от плановой даты закрытия до даты операции %% будут 
**              начисляться либо по штрафной ставке либо по ставке пролонгации. 
**              Выбор ставки зависит от параметра, передаваемого в функцию НачислСчет. 
**              Если третьим (или четвертым) параметром передается "штр", то проценты 
**              считаются по штрафной ставке; по умолчанию (отсутствие параметра) 
**              по ставке пролонгациии. 
**  Синтаксис : НачислСчет(обязат назначение, 
                           обязат Тип. дог, 
                           необязат Печать, 
                           необязат Ставка, 
                           необязат Нач мес):deicmal
**  Пример    : НачислСчет("dps",*,"Нет")
*/
procedure НачислСчет:
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   def var h_templ as handle no-undo.
   def var beg-date as date no-undo.
   def var in-commi like commission.commi no-undo.
   def var in-interest like interest-sch.interest no-undo.
   def var str-kau like kau.kau no-undo.
   def var dat-t as date no-undo.
   def var result as decimal no-undo.
   def var fl as INT64 init -1.
   def var result1 as decimal no-undo.
   def var end-dat1 as date no-undo.
   def var fl-print as logical init yes no-undo.
   def var nach_end as logical no-undo.
   def var str-acct as char no-undo.
   def var date-contr as date no-undo.
   def var vdate1 as date no-undo.
   def var vdate2 as date no-undo.
   def var i as INT64 no-undo.
   def var delay as INT64 no-undo .
   def var fl-close as logical no-undo .
   DEF VAR fl-ok-prol AS LOGICAL NO-UNDO .
   DEF VAR vBegMonth AS LOGICAL NO-UNDO .
   DEF VAR str_par AS CHAR NO-UNDO .
   DEF VAR vResult AS DECIMAL NO-UNDO.

   DEF VAR pen AS INT64 NO-UNDO. /* 1 - Доначисление по штрафной ставке
                                  2 - по основной ставке
                                  иначе - по ставке пролонгации */
   remove-amt = 0.

   IF param-count LT 2 OR param-count GT 5 THEN
      RETURN.   

   IF param-count GT 2
   THEN str_par = GetParam(3, param-str).
   IF param-count GT 3
   THEN str_par = str_par + ',' +  GetParam(4, param-str).
   IF param-count GT 4
   THEN str_par = str_par + ',' + GetParam(5, param-str).
   IF CAN-DO(str_par,'Нет')
   THEN fl-print = NO .
   ELSE fl-print = YES .
   IF CAN-DO(str_par,'Осн')
   THEN pen = 2 .
   IF CAN-DO(str_par,'Штр')
   THEN pen = 1 .
   IF CAN-DO(str_par,'НачМес')
   THEN vBegMonth = YES .

   /* Определение правильного применения функции,
   ** формат private-data */
   run DPS_VALID_HANDLE (input-output h_templ).

   if not valid-handle(h_templ) then DO:
      pick-value = STRING(0).
      RETURN.
   END.

   FIND FIRST wop WHERE RECID(wop) EQ rid NO-LOCK NO-ERROR.
   IF NOT AVAIL wop THEN DO:
      pick-value = STRING(0).
      RETURN.
   END.

   nach_end = FGetSetting("NachEndLoan",?,'Да') eq 'Да'.
   find loan  where loan.contract eq GetParam(1, param-str) and
                    loan.cont-code eq entry(1,substring(h_templ:private-data,6)) no-lock no-error.
   if not avail loan then DO:
       pick-value = STRING(0).
       RETURN.
    END.
   find op-templ where op-templ.op-kind eq loan.op-kind and
                       op-templ.op-templ eq loan.op-templ no-lock no-error.
   if not avail op-template then DO:
      pick-value = STRING(0).
      RETURN.
   END.
   if not can-do(replace(replace(GetParam(2, param-str),"!",","),"'",""),loan.cont-type) then DO:
       pick-value = STRING(0).
       RETURN.
    END.

   FIND FIRST op-entry WHERE
         RECID( op-entry ) = wop.op-recid NO-LOCK NO-ERROR.
   
   IF AVAILABLE op-entry THEN
      FIND FIRST op WHERE
            op.op = op-entry.op NO-LOCK NO-ERROR.
   ELSE
      FIND FIRST op WHERE RECID(op) = wop.op-recid NO-LOCK NO-ERROR.


   /* определение даты последнего начисления процентов */
   RUN get-date-nach in h_dpspc (RECID(loan),
                                         wop.con-date,
                                         IF AVAIL op THEN op.op-transaction ELSE ?,
                                         OUTPUT beg-date).
                                           
   /* если начисление уже есть в будущем */
   IF beg-date = ? OR beg-date >= wop.con-date THEN DO:
       pick-value = STRING(0).
       RETURN.
    END.

    IF vBegMonth THEN DO:     /* начисление от начала месяца  */
      /* Если начало месяца - позже последнего начисления процентов - тогда
         началом интервала считаем начало месяца */
      IF DATE(MONTH(wop.con-date),01,YEAR(wop.con-date)) - 1 > beg-date THEN
         beg-date = DATE(MONTH(wop.con-date),01,YEAR(wop.con-date)) - 1.
    END.

   /* получение списка счетов */
   run get_acct in h_dpspc (recid(loan),beg-date,in-op-date,output str-acct).
   if   str-acct = '' then DO:
       pick-value = STRING(0).
       RETURN.
    END.
   run  chk_close in h_dpspc(wop.op-kind,loan.class-code,loan.loan-status,output fl-close) .

   do i = 1 to num-entries(str-acct) :
      find first acct where acct.acct = entry(i,str-acct) /* and acct.currency = loan.currency */ no-lock no-error.
      if not avail acct then next.

      if i > 1 then beg-date = if beg-date lt date(entry(i + 1,str-acct)) then date(entry(i + 1,str-acct)) else beg-date.
      if num-entries(str-acct) >= i + 3 then date-contr = date(entry(i + 3,str-acct)).
      else date-contr = wop.con-date.
      run  get_last_delay in h_dpspc (recid(loan),beg-date,date-contr,output  delay) .
      if   num-entries(str-acct) < i + 3 and fl-close then date-contr = date-contr + delay .
      if date-contr > wop.con-date then date-contr = wop.con-date.
      /*
      run get-beg-date-prol IN h_dpspc (recid(loan),beg-date,output vdate1,output vdate2).
      */
       vdate2 = loan.end-date.
      if vdate2 <> ? and vdate2 <= date-contr and beg-date lt vdate2 then end-dat1 = vdate2.
      else if (vdate2 <> ?  and vdate2 > date-contr) or vdate2 = ? then end-dat1 = date-contr.
      else end-dat1 = if not nach_end then  beg-date else date-contr.
      str-kau = loan.contract + ',' + loan.cont-code  + ","  +  (if vdate2 eq ? then 'ОстВклВ' else 'ОстВклС').
      run Get_Last_Inter in h_dpspc (recid(loan),beg-date,end-dat1,output in-interest).
      if in-interest = ? or in-interest = '?'  then do :
         i = i + 1.
         next.
      end.
      run Get_Last_Commi in h_dpspc (recid(loan),beg-date,end-dat1,output in-commi).
      if in-commi = ? or in-commi = '?' then do :
         i = i + 1.
         next.
      end.

      c1:
      do while  beg-date lt end-dat1  :
         /*если было проведено начисление на плановую дату = дате закрытия*/
         IF loan.end-date  <=  end-dat1 AND
            beg-date >= loan.end-date THEN
         DO:
             end-dat1 = beg-date.
             LEAVE c1.
         END.
         result = 0.
         result1 = 0.
         fl = 0.
         {findsch.i &dir=first &sch=in-interest &since1=" gt beg-date and interest-sch-line.since le end-dat1"}
         if avail interest-sch-line then  dat-t = interest-sch-line.since.
         else dat-t = end-dat1.
         release interest-sch-line.
         {findsch.i &dir=last &sch=in-interest &since1 =" lt dat-t"}
         if avail interest-sch-line then DO:
             RUN SetSysConf IN h_base ("pars-id", "1_НачислСчет").
              /*для резервирования уже готово "быстрое  начисление" */
              IF vReserv THEN DO:
                  
                  run nachkin IN H_NACHD (
                      recid(interest-sch-line),
                      in-commi,
                      recid(acct),dat-t,str-kau,fl-print,output result,output result1,input-output beg-date,output fl).
                  
              END.
              ELSE
                  run nachkin.p (
                      recid(interest-sch-line),
                      in-commi,
                      recid(acct),dat-t,str-kau,fl-print,output result,output result1,input-output beg-date,output fl).
              RUN SetSysConf IN h_base ("pars-id", ?).
         END.
         beg-date = dat-t.
         if fl ne 0 then DO:
            ASSIGN 
               pick-value = STRING(0)
               remove-amt        = 0
               .
            RETURN.
         END.
         ASSIGN
            vResult           = vResult + result
            remove-amt        = remove-amt + result1
            beg-date          = dat-t
            .
      end.
      if end-dat1 lt date-contr and nach_end then do :
         IF pen = 1 THEN DO:
            /* начисление по штрафной ставке за оставшиеся дни
               (причем ставку определяем в период предыдущей жизни) */
            {parsrat2.i Get_Last_Pen_Inter Get_Last_Pen-Commi}
            assign
               beg-date = end-dat1
               end-dat1 = date-contr
               .
         END.
         ELSE IF pen = 2 THEN DO:
            /* начисление по основной ставке за оставшиеся дни
               (причем ставку определяем в период предыдущей жизни) */
            {parsrat2.i Get_Last_Inter Get_Last_Commi}
            assign
               beg-date = end-dat1
               end-dat1 = date-contr
               .
         END.
         ELSE DO:
            ASSIGN
               beg-date = end-dat1
               end-dat1 = date-contr
               .
            /* начисление по ставке  пролонгации за оставшиеся дни
               (причем ставку определяем в период новой жизни) */
            {parsrat2.i Get_Last_Inter Get_Last_Commi}
             /* Приходится делать в лоб
            Начисление после плановой даты закрытия договора возникает
            только при пролонгации или закрытии на дату > плановой даты
            закрытия. Стандартные инструменты получения параметров  договора
            не дают возможность определить, что при исчерпании числа
            пролонгаций в этот момент
            ( изменение реквизитов договора проводится после генерации
              всех документов при пролонгации) ставка и схема начисления
              должны браться из условий штрафной пролонгации */
            RUN Chk_Limit_Per in h_dpspc
                    (in-op-date,RECID(loan),loan.prolong + 1,OUTPUT fl-ok-prol) .
            IF NOT fl-ok-prol THEN /* исчерпаны пролонгации */
            DO:
               RUN Get_PenOpkind_Inter_Commi in h_dpspc
                (RECID(loan),INPUT-OUTPUT in-commi,INPUT-OUTPUT in-interest).
              IF in-commi = ? OR in-interest = ? THEN NEXT .
            END.
         END.
         do while  beg-date lt end-dat1  :
            fl = 0.
            {findsch.i &dir=first &sch=in-interest &since1=" gt beg-date and interest-sch-line.since le end-dat1"}
            if avail interest-sch-line then  dat-t = interest-sch-line.since.
            else dat-t = end-dat1.
            release interest-sch-line.
            {findsch.i &dir=last &sch=in-interest &since1 =" lt dat-t"}
            if avail interest-sch-line then DO:
                /*для резервирования уже готово "быстрое  начисление" */
                RUN SetSysConf IN h_base ("pars-id", "1_НачислСчет").
                IF vReserv THEN
                    run nachkin IN H_NACHD (
                        recid(interest-sch-line),
                        in-commi,
                        recid(acct),dat-t,str-kau,fl-print,output result,output result1,input-output beg-date,output fl).

                ELSE
                    run nachkin.p (
                        recid(interest-sch-line),
                        in-commi,
                        recid(acct),dat-t,str-kau,fl-print,output result,output result1,input-output beg-date,output fl).
               RUN SetSysConf IN h_base ("pars-id", ?).

            END.
            beg-date = dat-t.
            if fl ne 0 then DO:
               ASSIGN 
                  pick-value = STRING(0)
                  remove-amt        = 0
                  .
               RETURN.
            END.
            ASSIGN
               vResult           = vResult + result
               remove-amt        = remove-amt + result1
               beg-date          = dat-t
               .
         end.
      end.
   end.
   pick-value = STRING(vResult).
END PROCEDURE.


/*  Что делает: Начисление штрафных процентов по срочным вкладам 
**  Синтаксис : НачШтраф(обязат назначение, 
                         обязат тип. дог, 
                         необязат печать):decimal
**  Пример    : НачШтраф("dps",*,"Нет")
*/
PROCEDURE НачШтраф:
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   DEF VAR h_templ      AS HANDLE NO-UNDO.
   DEF VAR beg-date     AS DATE   NO-UNDO.
   DEF VAR in-surrogate AS CHAR   NO-UNDO.
   DEF VAR in-commi     LIKE commission.commi      NO-UNDO.
   DEF VAR in-interest  LIKE interest-sch.interest NO-UNDO.
   DEF VAR str-kau      LIKE kau.kau               NO-UNDO.
   DEF VAR dat-t        AS DATE    NO-UNDO.
   DEF VAR result       AS DECIMAL NO-UNDO.
   DEF VAR ii           AS INT64     NO-UNDO.
   DEF BUFFER cacct FOR acct.
   def var fl as INT64.
   def var cod-ost as char no-undo.
   def var result1 as decimal no-undo.
   def buffer yop-templ for op-templ.
   def var end-dat1 as date no-undo.
   def var dl as INT64 no-undo.
   def var fl-print as logical init yes no-undo.
   DEF    VAR str-par      AS CHAR    NO-UNDO.
   
   DEFINE VAR str-acct   AS CHARACTER NO-UNDO.
   DEFINE VAR i          AS INT64   NO-UNDO.
   DEFINE VAR date-contr AS DATE      NO-UNDO.
   DEFINE VAR vResult    AS DECIMAL   NO-UNDO. 
   
   remove-amt = 0.
   
   IF NOT (param-count EQ 2 or param-count EQ 3) THEN 
       RETURN.
   
   if param-count EQ 3 then
      if GetParam(3, param-str) EQ 'нет'  then fl-print = no.
   
      /* Определение правильного применения функции,
      ** формат private-data */
      run DPS_VALID_HANDLE (input-output h_templ).
   
    IF NOT valid-handle(h_templ) THEN DO:
        pick-value = STRING(0).
        RETURN.
     END.
   
    RUN RE_B_LOAN (GetParam(1, param-str),
                   entry(1,substring(h_templ:private-data,6)),
                   buffer loan).
   
    IF NOT AVAIL loan THEN DO:
        pick-value = STRING(0).
        RETURN.
    END.

    FIND FIRST wop WHERE RECID(wop) EQ rid NO-LOCK NO-ERROR.
    IF NOT AVAIL wop THEN DO:
       pick-value = STRING(0).
       RETURN.
    END.

    in-surrogate = loan.contract + ',' + loan.cont-code.
    IF loan.end-date EQ ? THEN DO:
        pick-value = STRING(0).
        RETURN.
     END.
    FIND op-template WHERE op-template.op-kind EQ loan.op-kind
                       AND op-templ.op-templ   EQ loan.op-templ NO-LOCK NO-ERROR.
    IF NOT AVAIL op-template THEN DO:
        pick-value = STRING(0).
        RETURN.
     END.
    /* проверка отсутствия начисления с датой > даты опер. дня */
    RUN chek_no_nach in h_dpspc (recid(loan),in-op-date).
    if RETURN-VALUE = 'error' THEN DO:
        MESSAGE "По вкладу N " loan.doc-ref SKIP
                "еcть начисление процентов с датой больше " in-op-date "!!!"
        VIEW-AS ALERT-BOX ERROR.      
        pick-value = STRING(0).
        RETURN.   
    END.
   
    RUN  get-beg-date-all in h_dpspc (RECID(loan),
                                              in-op-date,
                                              OUTPUT beg-date).
    if beg-date = ? then DO:
        pick-value = STRING(0).
        RETURN.
     END.
    run get_acct in h_dpspc (recid(loan),beg-date,in-op-date,output str-acct) .
   if   str-acct = '' then DO:
      pick-value = STRING(0).
      RETURN.
   END.
   run  get_last_delay in h_dpspc (recid(loan),beg-date,date-contr,output dl) .
   end-date = wop.con-date + if dl <> ? then dl else 0 .
   str-kau = loan.contract + ',' + loan.cont-code  + ","  +  'ОстВклС' .
   do i = 1 to num-entries(str-acct) by 2:
    find first acct
       where acct.acct eq entry(i,str-acct)
    no-lock no-error.

    if not avail acct then next.

    if i gt 1 then beg-date = if beg-date lt date(entry(i + 1,str-acct)) then date(entry(i + 1,str-acct))
                                                                         else beg-date.
    if num-entries(str-acct) >= i + 3
    then date-contr = date(entry(i + 3,str-acct)).
    else date-contr = end-date.
    run Get_Last_Pen_Inter in h_dpspc (recid(loan),beg-date,date-contr,output in-interest).
    if in-interest = ? or in-interest = '?' then do :
       i = i + 1.
       next.
    end.
    RUN get_srok_vklad in h_dpspc (RECID(loan),wop.con-date,OUTPUT str-par).
    /*Если вклад на два года или полтора закрывается досрочно, но год уже отлежал*/
    IF str-par = "-1"
    THEN run Get_Last_Commi in h_dpspc (recid(loan),beg-date,date-contr,output in-commi).
    /*Если вклад на два года или полтора закрывается досрочно и пролежал меньше года,
    или этот вклад к таким извращениям (7251) отношения не имеет */
    ELSE run Get_Last_Pen-Commi in h_dpspc (recid(loan),beg-date,date-contr,output in-commi).
    if in-commi = ? or in-commi = '?' then do :
        i = i + 1.
        next.
    end.

    DO WHILE beg-date LT date-contr:
       result = 0.
       result1 = 0.
       fl = 0 .
            {findsch.i &dir=first
                  &sch=in-interest
                  &since1=" gt beg-date and interest-sch-line.since le date-contr"}

       IF AVAIL interest-sch-line THEN dat-t = interest-sch-line.since.
                                  ELSE dat-t = date-contr.

       RELEASE interest-sch-line.
       {findsch.i &dir=last &sch=in-interest &since1 =" lt dat-t"}
       IF AVAIL interest-sch-line THEN
              run  nachkin.p(recid(interest-sch-line),
                      in-commi,
                      recid(acct),
                      dat-t,
                      str-kau,
                      fl-print,
                      output result,
                      output result1,
                      input-output beg-date,
                      output fl) .
         beg-date = dat-t.
       if fl ne 0 then DO:
         ASSIGN
            remove-amt        = 0
            pick-value = STRING(0)
            .
         RETURN.
      END.            
      ASSIGN
           vResult           = vResult + result
           remove-amt        = remove-amt + result1
           beg-date          = dat-t
        .
     END.
   END.
   pick-value = STRING(vResult). 
END PROCEDURE.


/*  Что делает: Пересчет предварительно начисленных процентов 
**              по штрафной ставке. Функция используется при досрочном 
**              закрытии вклада с оплатой процентов в конце срока. 
**              Проценты пересчитываются по штрафной ставке от даты открытия 
**              или понгации до последней даты предварительного начисления процентов.
**  Синтаксис : НачШтрНач(обязат назначение, 
                          обязат тип. дог, 
                          необязат печать):decimal
**  Пример    : НачШтраф("dps",*,"Нет")
*/
PROCEDURE НачШтрНач:
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   DEF VAR h_templ      AS HANDLE NO-UNDO.
   DEF VAR beg-date     AS DATE   NO-UNDO.
   DEF VAR END-DATE AS DATE NO-UNDO.
   DEF VAR in-surrogate AS CHAR   NO-UNDO.
   DEF VAR in-commi     LIKE commission.commi      NO-UNDO.
   DEF VAR in-interest  LIKE interest-sch.interest NO-UNDO.
   DEF VAR str-kau      LIKE kau.kau               NO-UNDO.
   DEF VAR dat-t        AS DATE    NO-UNDO.
   DEF VAR result       AS DECIMAL NO-UNDO.
   DEF VAR ii           AS INT64     NO-UNDO.
   def var fl-print as logical init yes no-undo.
   def var i as INT64 no-undo.
   DEF    VAR str-par      AS CHAR    NO-UNDO.
   
   DEF BUFFER cacct FOR acct.
   def var fl as INT64.
   def var cod-ost as char no-undo.
   def var result1 as decimal no-undo.
   def buffer yop-templ for op-templ.
   def var end-dat1 as date no-undo.
   def var dl as INT64 no-undo.
   def var str-acct as char no-undo.
   def var date-contr as date no-undo.
   DEFINE VAR vResult    AS DECIMAL   NO-UNDO.
   
   remove-amt = 0.
   
   IF NOT (param-count EQ 2 or param-count EQ 3) THEN 
      RETURN.
   
   /* Определение правильного применения функции,
   ** формат private-data */
   run DPS_VALID_HANDLE (input-output h_templ).
   
   IF NOT valid-handle(h_templ) THEN DO:
       pick-value = STRING(0).
       RETURN.
    END.
   
   RUN RE_B_LOAN (GetParam(1, param-str),
                  entry(1,substring(h_templ:private-data,6)),
                  buffer loan).
   
   IF NOT AVAIL loan THEN DO:
      pick-value = STRING(0).
      RETURN.
   END.

   FIND FIRST wop WHERE RECID(wop) EQ rid NO-LOCK NO-ERROR.
   IF NOT AVAIL wop THEN DO:
      pick-value = STRING(0).
      RETURN.
   END.

   in-surrogate = loan.contract + ',' + loan.cont-code.
   IF loan.end-date EQ ? THEN DO:
      pick-value = STRING(0).
      RETURN.
   END.
   FIND op-template WHERE op-template.op-kind EQ loan.op-kind
                      AND op-templ.op-templ   EQ loan.op-templ NO-LOCK NO-ERROR.
   IF NOT AVAIL op-template THEN DO:
      pick-value = STRING(0).
      RETURN.
   END.
   fl-print = (if param-count EQ 3 and GetParam(3, param-str) eq 'нет' then no else yes).
   cod-ost = loan.contract + "," + loan.cont-code + ","  .
   
   beg-date = Get-Beg-Date-Obl(cod-ost,in-op-date).
        run get_beg_date_per in h_dpspc(
        recid(loan),
        in-op-date,
        output end-date).
    if end-date ne ? and
       end-date lt beg-date then DO:
       pick-value = STRING(0).
       RETURN.
    END.
   
    if end-date eq ?
    then end-date = beg-date.
    else do:
   
        run get_beg_date_kl_per in h_dpspc(
            recid(loan),
            in-op-date,
            input-output beg-date).
   
        if beg-date ge end-date
        then end-date = beg-date.
        else run get_beg_date_kl_per in h_dpspc(
            recid(loan),
            end-date,
            input-output beg-date).
   end.

    FIND LAST loan-acct OF loan WHERE
        loan-acct.acct-type EQ 'loan-dps-t' AND
        loan-acct.since     LE  in-op-date
    NO-LOCK NO-ERROR.

    IF AVAIL loan-acct THEN
        FIND FIRST acct WHERE
            acct.acct     EQ loan-acct.acct AND
            acct.currency EQ loan-acct.currency
        NO-LOCK NO-ERROR.

    IF NOT AVAIL acct THEN DO:
       pick-value = STRING(0).
       RETURN.
    END.
    run Get_Last_Pen_Inter in h_dpspc (recid(loan),beg-date,wop.con-date,output in-interest).
    if in-interest = ? or in-interest = '?'  then DO:
       pick-value = STRING(0).
       RETURN.
    END.
    RUN get_srok_vklad in h_dpspc (RECID(loan),wop.con-date,OUTPUT str-par).
    /*Если вклад на два года или полтора закрывается досрочно, но год уже отлежал*/
    IF str-par = "-1"
    THEN run Get_Last_Commi in h_dpspc (recid(loan),beg-date,wop.con-date,output in-commi).
    /*Если вклад на два года или полтора закрывается досрочно и пролежал меньше года,
     или этот вклад к таким извращениям (7251) отношения не имеет */
    ELSE run Get_Last_Pen-Commi in h_dpspc (recid(loan),beg-date,wop.con-date,output in-commi).
    if in-commi = ? or in-commi = '?' then DO:
       pick-value = STRING(0).
       RETURN.
    END.
    if end-date eq in-op-date
    then do:
     run  get_last_delay in h_dpspc (recid(loan),beg-date,wop.con-date,output dl) .
     if dl <> ? then   end-date = end-date + dl.
    end.
    result = 0.

    str-kau = loan.contract + ',' + loan.cont-code +   ',' +  "ОстВклС".
    run get_acct in h_dpspc(
        recid(loan),
        beg-date,
        end-date,
        output str-acct).
    if str-acct eq ''
    then DO:
       pick-value = STRING(0).
       RETURN.
    END.
    do i = 1 to num-entries(str-acct) BY 2:

        find first acct where
            acct.acct eq entry(i,str-acct)
        no-lock no-error.
        if not avail acct
        then next.

        if i gt 1
        then beg-date = if beg-date lt date(entry(i + 1,str-acct))
                        then date(entry(i + 1,str-acct))
                        else beg-date.

        if num-entries(str-acct) >= i + 3
        then date-contr = date(entry(i + 3,str-acct)).
        else date-contr = end-date.
        do while  beg-date lt date-contr:

            ASSIGN
                result  = 0
                result1 = 0
                fl = 0
           .

            {findsch.i
                &dir    = first
                &sch    = in-interest
                &since1 = " gt beg-date and interest-sch-line.since le date-contr"
            }

            IF AVAIL interest-sch-line
            THEN dat-t = interest-sch-line.since.
            ELSE dat-t = date-contr.

            RELEASE interest-sch-line.

            {findsch.i
                &dir    = last
                &sch    = in-interest
                &since1 = " lt dat-t"
            }

      IF AVAIL interest-sch-line THEN
                run  nachkin.p(recid(interest-sch-line),
                     in-commi,
                     recid(acct),
                     dat-t,
                     str-kau,
                     fl-print,
                     output result,
                     output result1,
                     input-output beg-date,
                     output fl) .
       beg-date = dat-t.
       if fl ne 0 then DO:
          ASSIGN
             remove-amt        = 0
             pick-value = STRING(0)
             .
          RETURN.
       END.            
       ASSIGN
            vResult           = vResult + result
            remove-amt        = remove-amt + result1
            beg-date = dat-t
       .
    END.
   end.
   pick-value = STRING(vResult).
END PROCEDURE.


/*  Что делает: Используется для начисления процентов на капитализированные и снятые проценты
**  Синтаксис : НчВыдПроц(обязат Назначение, 
                          обязат Тип Дог, 
                          необязат Дней в начале, 
                          необязат Дней в конце):decimal
**  Пример    : НчВыдПроц("dps",*,10,10)
*/
PROCEDURE НЧВыдПроц.
  DEF INPUT PARAM rid         AS RECID NO-UNDO.
  DEF INPUT PARAM in-op-date  AS DATE  NO-UNDO.
  DEF INPUT PARAM param-count AS INT64   NO-UNDO.
  DEF INPUT PARAM param-str   AS CHAR  NO-UNDO.

  DEF VAR delta_beg AS INT64 INIT 1 NO-UNDO.
  DEF VAR delta_end AS INT64 INIT -1 NO-UNDO.

  def var h_templ        as handle no-undo.
  def var fl-print as logical init YES no-undo.
  DEF VAR beg-date AS DATE NO-UNDO.
  DEF VAR end-date AS DATE NO-UNDO.

  DEF VAR data AS DATE NO-UNDO.
  DEF VAR s1   AS DEC  NO-UNDO.
  DEF VAR in-interest AS CHAR NO-UNDO.
  DEF VAR in-commi    AS CHAR NO-UNDO.
  def var result1 as decimal INIT 0 no-undo.

  find first wop where recid(wop) eq rid.
  if param-count < 2 OR param-count > 4 then do:
    message "Ошибочное количество параметров передано в функцию 'НЧВыдПроц' " view-as alert-box.
    return.
  end.
  /*  if param-count >= 3 then
  IF TRIM(GetParam(3, param-str), """'") EQ 'нет' THEN fl-print = NO. */

  IF param-count > 2 THEN delta_beg = INT64(GetParam(3, param-str)) + delta_beg.
  IF param-count > 3 THEN delta_end = INT64(GetParam(4, param-str)) + delta_end.
  /* MESSAGE "DPSPARS.P" SKIP
      PROGRAM-NAME(1) SKIP
      "Кол-во параметров:" param-count SKIP
      'Параметры:' SKIP
      "Модуль =" GetParam(1, param-str) SKIP
      "Маска =" GetParam(2, param-str) SKIP
      /* "Флаг =" fl-print SKIP */
      "Дней_В_Начале =" delta_beg SKIP
      "Дней_В_Конце  =" delta_end
      VIEW-AS ALERT-BOX INFO BUTTONS OK. {comment} */
  run DPS_VALID_HANDLE (input-output h_templ).
  if not valid-handle(h_templ) then return.
  run RE_B_LOAN ("DPS",
                 entry(1,substring(h_templ:private-data,6)),
                 buffer loan).
  if not avail loan then return.
  IF NOT CAN-DO(REPLACE(REPLACE(GetParam(2,param-str),"!",","),"'",""),loan.cont-type) then RETURN.
  /*вычисление даты последнего начисления %%*/
  RUN last-nach-int (recid(loan),wop.con-date,output beg-date).
  /*если начисления не было, считаем от открытия*/
  if beg-date = ? THEN
          run get-beg-date-prol in h_dpspc
                               (recid(loan),
                                wop.con-date,
                                output beg-date,
                                output end-date).
  end-date = wop.con-date.
  FIND LAST loan-acct of loan where loan-acct.acct-type = 'loan-dps-t'
                                and loan-acct.since <= wop.con-date NO-LOCK NO-ERROR.
  tr:
  DO WHILE end-date > beg-date:
     run Get_Last_Pen_Inter in h_dpspc (recid(loan),beg-date,data,output in-interest).
     if in-interest = ? or in-interest = '?'  THEN RETURN.
     run Get_Last_Pen-Commi in h_dpspc (recid(loan),beg-date,data,output in-commi).
     if in-commi = ? or in-commi = '?' THEN RETURN.
     RUN last-nach-pay(RECID(loan),end-date,beg-date,OUTPUT data,OUTPUT s1).
     IF data = ? THEN LEAVE tr.
     /* MESSAGE "DPSPARS.P" SKIP
        PROGRAM-NAME(1) SKIP
        "beg-date =" beg-date SKIP
        "end-date =" end-date SKIP
        "data =" data SKIP
        "delta_beg =" delta_beg SKIP
        "delta_end =" delta_end SKIP
        "s1 =" s1 SKIP
        "in-commi =" in-commi SKIP
        "loan-acct.acct =" loan-acct.acct SKIP
        VIEW-AS ALERT-BOX INFO BUTTONS OK. {comment} */
     result1 = result1 + IF nch(s1,beg-date + delta_beg,data + delta_end,in-commi,in-interest,loan-acct.acct) = ?
                            THEN 0
                            ELSE nch(s1,beg-date + delta_beg,data + delta_end,in-commi,in-interest,loan-acct.acct).
     end-date = data.
  END.
pick-value = STRING(RESULT1).
/* MESSAGE "DPSPARS.P" SKIP
      PROGRAM-NAME(1) SKIP
      "Кол-во параметров:" param-count SKIP
      'Параметры:' SKIP
      "Модуль =" GetParam(1, param-str) SKIP
      "Маска =" GetParam(2, param-str) SKIP
      /* "Флаг =" fl-print SKIP */
      "Дней_В_Начале =" delta_beg SKIP
      "Дней_В_Конце  =" delta_end SKIP(1)
      "Результат:" pick-value
      VIEW-AS ALERT-BOX INFO BUTTONS OK. {comment} */
END PROCEDURE.


/*  Что делает: Используется вместе с основной функцией начисления %% (напр. НачислСчет). 
**              В случае если вклад иемеет реквизит delay (открывается либо на метасхеме на классе 
**              договоров, либо на объекте транзакции открытия), то количество дней указанных
**              в этом реквизите вычитается из основного начисления. С помощью НЧДень проценты
**              за эти дни начисляются по штрафной ставке.
**  Синтаксис : НчДень(обязат назначение, 
                       обязат Тип. дог, 
                       необязат Печать):deicmal
**  Пример    : НчДень("dps",*,Да)
*/
PROCEDURE НЧДень.
   DEF INPUT PARAM rid         AS RECID NO-UNDO.
   DEF INPUT PARAM in-op-date  AS DATE  NO-UNDO.
   DEF INPUT PARAM param-count AS INT64   NO-UNDO.
   DEF INPUT PARAM param-str   AS CHAR  NO-UNDO.
   def var h_templ        as handle no-undo.
   DEF  VAR vdate1 AS DATE NO-UNDO.
   DEF  VAR vdate2 AS DATE NO-UNDO.
   DEF VAR str-acct AS CHAR NO-UNDO.
   DEF VAR str-kau AS CHAR NO-UNDO.
   DEF VAR in-interest AS CHAR NO-UNDO.
   DEF VAR in-commi AS CHAR NO-UNDO.
   def var fl-print as logical init YES no-undo.
   def var result as decimal no-undo.
   def var result1 as decimal no-undo.
   def var delay as INT64 no-undo .
   def var fl as INT64 init -1.
   DEF VAR str-par AS CHAR NO-UNDO.
   
   def var beg-date as date no-undo.
   find first wop where recid(wop) eq rid.
   if param-count ne 2 AND param-count ne 3  then do:
     message "Ошибочное количество параметров передано в функцию 'НЧДень' " view-as alert-box.
     return.
   end.
   if param-count = 3 then
   if GetParam(3,param-str) = 'нет'  then fl-print = no.
   
   run DPS_VALID_HANDLE (input-output h_templ).
   if not valid-handle(h_templ) then return.
   run RE_B_LOAN ("DPS",
                  entry(1,substring(h_templ:private-data,6)),
                  buffer loan).
   if not avail loan then return.
   IF NOT CAN-DO(REPLACE(REPLACE(GetParam(2,param-str),"!",","),"'",""),loan.cont-type) then RETURN.
   /* получение списка счетов */
   
   /* проверка отсутствия начисления с датой > даты опер. дня */
   run chek_no_nach in h_dpspc (recid(loan),in-op-date).
   if return-value = 'error' then return.
   
   /* определение даты последнего начисления процентов */
   run  get-beg-date-all in h_dpspc (recid(loan),in-op-date,output beg-date).
   if beg-date = ? then return.
   
   RUN get_acct in h_dpspc (recid(loan),wop.con-date,wop.con-date,output str-acct).
   IF   str-acct = '' THEN RETURN.
   
   run  get_last_delay in h_dpspc (recid(loan),wop.con-date,wop.con-date,output delay) .
   
   run get-beg-date-prol in h_dpspc (recid(loan),wop.con-date,output vdate1,output vdate2).
   FIND FIRST acct WHERE acct.acct = entry(1,str-acct) NO-LOCK NO-ERROR.
   IF NOT AVAIL acct THEN RETURN.
   str-kau = loan.contract + ',' + loan.cont-code  + ","  +  (if vdate2 eq ? then 'ОстВклВ' else 'ОстВклС').
   
   run Get_Last_Pen_Inter in h_dpspc (recid(loan),wop.con-date,wop.con-date,output in-interest).
   if in-interest = ? or in-interest = '?'  THEN RETURN.
   
   RUN get_srok_vklad in h_dpspc (RECID(loan),wop.con-date,OUTPUT str-par).
   /*Если вклад на два года или полтора закрывается досрочно, но год уже отлежал*/
   IF str-par = "-1"
   THEN run Get_Last_Commi in h_dpspc (recid(loan),wop.con-date,wop.con-date,output in-commi).
   ELSE run Get_Last_Pen-Commi in h_dpspc (recid(loan),wop.con-date,wop.con-date,output in-commi).
   if in-commi = ? or in-commi = '?' THEN RETURN.
   {findsch.i &dir=last &sch=in-interest &since1 =" <= wop.con-date"}
   IF NOT AVAILABLE interest-sch-line THEN RETURN.
   beg-date = wop.con-date + delay.
   
   run  nachkin.p(recid(interest-sch-line),
                   in-commi,
                   recid(acct),
                   wop.con-date,
                   str-kau,
                   fl-print,
                   output result,
                   output result1,
                   input-output beg-date,
                   output fl) .
   IF fl NE 0 THEN RETURN.
   
   pick-value = STRING(RESULT).
END PROCEDURE.


/*  Что делает: Возвращает кредитовые обороты по указанному субаналитическому счету. 
**              Используется для определения уже перечисленных % клиенту. 
**  Синтаксис : НчПрогресс(обязат Счет, 
                           обязат Валюта, 
                           обязат Остаток):decimal
**  Пример    : НчПрогресс(Роль("loan-dps-t"),РольСчетВал("loan-dps-t"),"ОстВклС")
*/
PROCEDURE НЧПрогресс.
   DEF INPUT PARAM rid         AS RECID NO-UNDO.
   DEF INPUT PARAM in-op-date  AS DATE  NO-UNDO.
   DEF INPUT PARAM param-count AS INT64   NO-UNDO.
   DEF INPUT PARAM param-str   AS CHAR  NO-UNDO.

   DEF VAR h_templ   AS HANDLE      NO-UNDO.
   DEF VAR vAcct     AS CHARACTER   NO-UNDO. /* Счет */
   DEF VAR vCurrency AS CHARACTER   NO-UNDO. /* Валюта */
   DEF VAR vKau      AS CHARACTER   NO-UNDO. /* Субостаток */
   DEF VAR vBegDate  AS DATE        NO-UNDO. /* Дата начала */
   DEF VAR vTmpDate  AS DATE        NO-UNDO.
   DEF VAR vResult   AS DECIMAL     NO-UNDO. /* Результат */
   DEF VAR vLocalPV  AS CHARACTER   NO-UNDO.
   DEF VAR vFlErr    AS INT64     NO-UNDO. /* Флаг ошибки */

   vLocalPV = "0".

   MAIN:
   DO ON ERROR  UNDO, LEAVE
      ON ENDKEY UNDO, LEAVE: 
     
      IF param-count NE 3 THEN 
      DO:
         RUN Fill-SysMes ("", "", "-1", "Ошибочное количество параметров передано в функцию 'НЧПрогресс'.").
         UNDO MAIN, LEAVE MAIN.
      END.      

      RUN DPS_VALID_HANDLE (INPUT-OUTPUT h_templ).   
      IF NOT VALID-HANDLE(h_templ) THEN 
         UNDO MAIN, LEAVE MAIN.
      
      FIND FIRST loan WHERE loan.contract  EQ "dps"
                        AND loan.cont-code EQ ENTRY(1, SUBSTRING(h_templ:PRIVATE-DATA, 6))
         NO-LOCK NO-ERROR. 
      IF NOT AVAIL loan THEN 
         UNDO MAIN, LEAVE MAIN.

      FIND FIRST wop WHERE RECID(wop) EQ rid 
         NO-LOCK NO-ERROR.
      IF NOT AVAIL wop THEN 
         UNDO MAIN, LEAVE MAIN.      

      ASSIGN
         vAcct       = GetParam (1, param-str)         
         vKau        = GetParam (3, param-str)
         vCurrency   = STRING(GetParam(2, param-str), "999").
         vBegDate    = DATE(GetParam (4, param-str))
         .        

      IF vCurrency EQ FGetSetting("КодНацВал",?,?) THEN
         vCurrency = "".      

      RUN get-beg-date-prol IN h_dpspc (RECID(loan),
                                        wop.con-date,
                                        OUTPUT vBegDate,
                                        OUTPUT vTmpDate).   
   
      IF vBegDate NE loan.open-date THEN
         vBegDate = vBegDate + 1.
      
      RUN Get_Interest_KauEntry IN h_dpspr (BUFFER loan,
                                            vAcct,
                                            vCurrency,
                                            loan.contract + "," + loan.cont-code + "," +  vKau,
                                            vBegDate,
                                            wop.con-date,
                                            OUTPUT vResult,
                                            OUTPUT vFlErr).
      IF vFLErr GE 0 THEN
         vLocalPV = STRING(vResult).
   END.

   pick-value = vLocalPV.
END PROCEDURE.


/*  Что делает: Возвращает кредитовые обороты по указанному субаналитическому счету
**              за указаный период. Используется для определения уже перечисленных % 
**              клиенту. 
**  Синтаксис : НчПрогрессДт(обязат Счет, 
                             обязат Валюта, 
                             обязат Остаток,
                             обязат Дата-С,
                             обязат Дата-По):decimal
**  Пример    : НчПрогрессДт(Роль("loan-dps-t"),РольСчетВал("loan-dps-t"),"ОстВклС",01/01/2007,01/01/2008)
*/
PROCEDURE НЧПрогрессДт.
   DEF INPUT PARAM rid         AS RECID NO-UNDO.
   DEF INPUT PARAM in-op-date  AS DATE  NO-UNDO.
   DEF INPUT PARAM param-count AS INT64   NO-UNDO.
   DEF INPUT PARAM param-str   AS CHAR  NO-UNDO.

   DEF VAR h_templ   AS HANDLE      NO-UNDO. 
   DEF VAR vAcct     AS CHARACTER   NO-UNDO. /* Счет */
   DEF VAR vCurrency AS CHARACTER   NO-UNDO. /* Валюта */
   DEF VAR vKau      AS CHARACTER   NO-UNDO. /* Субостаток */
   DEF VAR vBegDate  AS DATE        NO-UNDO. /* Дата начала */
   DEF VAR vEndDate  AS DATE        NO-UNDO. /* Дата окончания */
   DEF VAR vResult   AS DECIMAL     NO-UNDO. /* Результат */
   DEF VAR vLocalPV  AS CHARACTER   NO-UNDO.
   DEF VAR vFlErr    AS INT64     NO-UNDO. /* Флаг ошибки */

   vLocalPV = "0".

   MAIN:
   DO ON ERROR  UNDO, LEAVE
      ON ENDKEY UNDO, LEAVE: 
     
      IF param-count NE 5 THEN 
      DO:
         RUN Fill-SysMes ("", "", "-1", "Ошибочное количество параметров передано в функцию 'НЧПрогресс'.").
         UNDO MAIN, LEAVE MAIN.
      END.

      RUN DPS_VALID_HANDLE (INPUT-OUTPUT h_templ).   
      IF NOT VALID-HANDLE(h_templ) THEN 
         UNDO MAIN, LEAVE MAIN.
      FIND FIRST loan WHERE loan.contract  EQ "dps"
                        AND loan.cont-code EQ ENTRY(1, SUBSTRING(h_templ:PRIVATE-DATA, 6))
         NO-LOCK NO-ERROR.      
      IF NOT AVAIL loan THEN 
         UNDO MAIN, LEAVE MAIN.

      FIND FIRST wop WHERE RECID(wop) EQ rid 
         NO-LOCK NO-ERROR.
      IF NOT AVAIL wop THEN 
         UNDO MAIN, LEAVE MAIN.

      ASSIGN
         vAcct       = GetParam (1, param-str)         
         vKau        = GetParam (3, param-str)
         vBegDate    = DATE(GetParam (4, param-str))
         vEndDate    = DATE(GetParam (5, param-str))
         vCurrency   = STRING(GetParam(2, param-str), "999").
         .  
      IF vCurrency EQ FGetSetting("КодНацВал",?,?) THEN
         vCurrency = "".  

      RUN Get_Interest_KauEntry IN h_dpspr (BUFFER loan,   
                                            vAcct,         
                                            vCurrency,     
                                            loan.contract + "," + loan.cont-code + "," + vKau,          
                                            vBegDate,      
                                            vEndDate,      
                                            OUTPUT vResult,
                                            OUTPUT vFlErr).
      IF vFLErr GE 0 THEN
         vLocalPV = STRING(vResult).
   END.

   pick-value = vLocalPV.
END PROCEDURE.


/*
**  Что делает: Пересчитывает %% за период капитализаций 
**             (от начала вклада до последней капитализации)
**             Наличие параметра "Осн" - означает, что расчет ведется
**             по основной ставке. По умолчанию пересчет процентов идет по штрафной ставке 
**  Синтаксис : ПерерасчКап(обязат Назначение , 
                            необязат Печать, 
                            необязат Ставка):decimal
**  Автор     : sap 17/02/2005 0038051 
**  Пример    : ПереРасчКап("dps"); ПереРасчКап("dps","Нет"), ПереРасчКап("dps","Да","Осн")
*/
PROCEDURE ПереРасчКап.
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   DEFINE VARIABLE vDpsHandle   AS HANDLE    NO-UNDO. /* Указатель на параметры договора */
   DEFINE VARIABLE vBegDate     AS DATE      NO-UNDO. /* Дата начала периода начисления */
   DEFINE VARIABLE vEndDate     AS DATE      NO-UNDO. /* Дата окончания периода начисления */
   DEFINE VARIABLE vEndDate1    AS DATE      NO-UNDO. /* Дата окончания вклада*/
   DEFINE VARIABLE vSurrChar    AS CHARACTER NO-UNDO. /* Суррогат для поиска параметров вклада */
   DEFINE VARIABLE vCommiChar   AS CHARACTER NO-UNDO. /* Код штрафной комиссии */
   DEFINE VARIABLE vInterChar   AS CHARACTER NO-UNDO. /* Код штрафной схемы начисления %% */
   DEFINE VARIABLE vKauChar     AS CHARACTER NO-UNDO. /* Код субсчета */
   DEFINE VARIABLE vFlPrintLog  AS LOGICAL   NO-UNDO. /* Признак печати ведомости */
   DEFINE VARIABLE i            AS INT64   NO-UNDO. /* Счетчик */
   DEFINE VARIABLE vFlagInt     AS INT64   NO-UNDO. /* Код ошибки начисления */
   DEFINE VARIABLE vCodOstChar  AS CHARACTER NO-UNDO. /* Код остатка */
   DEFINE VARIABLE vAcctLstChar AS CHARACTER NO-UNDO. /* Список основных счетов по вкаладу */
   DEFINE VARIABLE vPerEndDate  AS DATE      NO-UNDO. /* Дата окончание интервала действия счета */
   DEFINE VARIABLE RESULT       AS DECIMAL   NO-UNDO. /* Результат начисления по основной ставке */
   DEFINE VARIABLE result1      AS DECIMAL   NO-UNDO. /* Результат начисления по ставке рефенансирования */
   DEFINE VARIABLE vCommEndDate AS DATE      NO-UNDO. /* Дата окончания действия комиссии */
   DEFINE VARIABLE vKindChar    AS CHARACTER NO-UNDO. /* Код транзакции открытия/пролонгации */
   DEFINE VARIABLE vTemplInt    AS INT64   NO-UNDO. /* Номер шаблона карточки */
   DEFINE VARIABLE base         AS LOGICAL   NO-UNDO. /*Основная или штрашная ставка*/
   DEFINE VARIABLE c            AS CHARACTER NO-UNDO. /*Используемая ставка*/
   DEFINE VARIABLE s            AS CHARACTER NO-UNDO. /*Используемая схема*/
   DEFINE VARIABLE str-par      AS CHARACTER NO-UNDO.
   DEFINE VARIABLE result_s     AS DECIMAL   NO-UNDO.
   DEFINE VARIABLE delay     AS INT64 NO-UNDO .
   DEFINE VARIABLE fl-close  AS LOGICAL NO-UNDO .
   DEFINE VARIABLE vFrom-kap AS LOGICAL NO-UNDO.  /*Основная или штрашная ставка*/

   ASSIGN
      remove-amt = 0
      RESULT = 0.

   FIND FIRST wop WHERE
         RECID( wop ) EQ rid.

    /*if not (pars-validparam(1) OR pars-validparam(2) OR pars-validparam(3)) then return.*/

   IF param-count NE 1 AND param-count NE 2 AND param-count NE 3  THEN
   DO :
      MESSAGE "Ошибочное количество параметров передано в функцию 'ПерерасчКап' "
         VIEW-AS ALERT-BOX .
      RETURN.
   END.


    /* было
    base = if pn = 2 AND pars-getstring(2) BEGINS 'Осн' THEN YES ELSE NO.*/

   base = IF param-count = 3 AND GetParam( 3, param-str ) BEGINS 'Осн' 
          THEN YES
          ELSE NO.

    /* было
    vFlPrintLog = if (pn = 1 OR pn = 2) AND pars-getstring(1) eq 'нет' then no
             else yes
    */
   vFlPrintLog = IF  ( param-count = 2 OR param-count = 3 ) 
                 AND GetParam( 2,param-str ) EQ 'нет'
                 THEN NO
                 ELSE YES.

   

   RUN DPS_VALID_HANDLE ( INPUT-OUTPUT vDpsHandle ).
   IF NOT VALID-HANDLE( vDpsHandle ) THEN
      RETURN.
   

   RUN RE_B_LOAN ( "DPS",
      ENTRY( 1, SUBSTRING( vDpsHandle:PRIVATE-DATA, 6 ) ),
      BUFFER loan ).
   
   IF NOT AVAILABLE loan THEN
      RETURN.

   /*определяем дату переоформления вклада  vBegDate*/
   RUN  get-beg-date-prol in h_dpspc ( RECID( loan ),
      wop.con-date,
      OUTPUT vBegDate,
      OUTPUT vEndDate1 ).

   /* корректировка, если дата переоформления включается в новый период начисления
      процентов */
   RUN correct_date in h_dpspc ( INPUT RECID( loan ), INPUT-OUTPUT vBegDate ) .

   vEndDate = vBegDate.
   
   /* определение последней даты капитализации процентов */
   FIND FIRST op-entry WHERE
         RECID( op-entry ) = wop.op-recid NO-LOCK NO-ERROR.
   
   IF AVAILABLE op-entry THEN
      FIND FIRST op WHERE
            op.op = op-entry.op NO-LOCK NO-ERROR.
   
   IF AVAILABLE op THEN
      RUN get_beg_kper in h_dpspc ( RECID( loan ),
         wop.con-date,
         op.op-transaction,
         INPUT-OUTPUT  vEndDate ).
   ELSE
      RUN get_beg_kper in h_dpspc ( RECID( loan ),
         wop.con-date,
         ?,
         INPUT-OUTPUT  vEndDate ).
   
   IF  vEndDate = ?  THEN
      RETURN.

   ASSIGN
      vCodOstChar = loan.contract + "," + loan.cont-code + "," + "НачПрВ".

   RUN  get_last_delay in h_dpspc ( RECID( loan ), wop.con-date,
         wop.con-date, OUTPUT delay ) .

   RUN  chk_close in h_dpspc( wop.op-kind, loan.class-code,
         loan.loan-status, OUTPUT fl-close ) .
   IF fl-close AND delay <> ? THEN
      vEndDate = vEndDate + delay .

    /*  Определяем список счетов для начисления процентов  */
   RUN get_acct in h_dpspc (
      RECID( loan ),
      vBegDate,
      vEndDate,
      OUTPUT vAcctLstChar ).

   /* нет ни одного счета */
   IF  vAcctLstChar = '' THEN
      RETURN.

   vKauChar = loan.contract + ',' +
      loan.cont-code  + ","  +
      ( IF vEndDate1 EQ ?
      THEN 'ОстВклВ'
      ELSE 'ОстВклС' ).

   DO i = 1 TO NUM-ENTRIES( vAcctLstChar ):
        /* Поиск счета */
      FIND FIRST acct WHERE
            acct.acct EQ ENTRY( i, vAcctLstChar ) NO-LOCK NO-ERROR.
      IF NOT AVAILABLE acct THEN
         NEXT.

      IF i GT 1
         THEN vBegDate = IF vBegDate LT DATE( ENTRY( i + 1, vAcctLstChar ) )
         THEN DATE( ENTRY( i + 1, vAcctLstChar ) )
         ELSE vBegDate.

      IF NUM-ENTRIES( vAcctLstChar ) GE i + 3 THEN
         vPerEndDate = DATE( ENTRY( i + 3, vAcctLstChar ) ).
      ELSE
         vPerEndDate = vEndDate.
      /* определяем коды комиссии и схемы начисления процентов в диапазоне привязки счета */
      /* ищем комиссии или схемы начисления */
      IF base THEN
      DO :
         RUN Get_Last_Commi in h_dpspc ( RECID( loan ), vBegDate, vPerEndDate,
               OUTPUT vCommiChar ) .
         RUN Get_Last_Inter in h_dpspc ( RECID( loan ), vBegDate, vPerEndDate,
               OUTPUT vInterChar ) .
      END.

      ELSE
      DO:
         RUN Get_Last_Pen_Inter in h_dpspc ( RECID( loan ), vBegDate, vPerEndDate,
               OUTPUT vInterChar ) .
         RUN get_srok_vklad in h_dpspc ( RECID( loan ), wop.con-date, OUTPUT
               str-par ).
       /*Если вклад на два года или полтора закрывается досрочно, но год уже отлежал*/
         IF str-par = "-1" THEN
            RUN Get_Last_Commi in h_dpspc ( RECID( loan ), vBegDate, vPerEndDate,
                  OUTPUT vCommiChar ) .
         ELSE
            RUN Get_Last_Pen-Commi in h_dpspc ( RECID( loan ), vBegDate, vPerEndDate,
                  OUTPUT vCommiChar ) .
      END.

      IF  vCommiChar  = ? OR vInterChar = ? OR   vCommiChar  = '?' OR vInterChar = '?'
            THEN
         DO:
            i = i + 1.
            NEXT.
         END.
         DO WHILE vBegDate LT vPerEndDate:
            ASSIGN
               RESULT  = 0
               result1 = 0
               .
            {findsch.i
               &dir    = FIRST
               &sch    = vInterChar
               &since1 = " gt vBegDate and interest-sch-line.since le vPerEndDate"
               }

            vCommEndDate = IF AVAILABLE interest-sch-line
               THEN interest-sch-line.since
               ELSE vPerEndDate.

            RELEASE interest-sch-line.

            {findsch.i
               &dir    = LAST
               &sch    = vInterChar
               &since1 = " lt vCommEndDate"
               }
            /* End-Of-Block Поиск схемы начисления процентов */

            /* Запуск схемы начисления процентов */
            IF AVAILABLE interest-sch-line THEN
               IF NOT vReserv THEN
                  RUN nachkin.p
                     ( RECID( interest-sch-line ),
                     vCommiChar,
                     RECID( acct ),
                     vCommEndDate,
                     vKauChar,
                     vFlPrintLog,
                     OUTPUT RESULT,
                     OUTPUT result1,
                     INPUT-OUTPUT vBegDate,
                     OUTPUT vFlagInt ).
               ELSE DO:
                  RUN SetSysConf IN h_base ("pars-id", "1_ПерерасчКап").
                  RUN nachkin IN h_nachd
                     ( RECID( interest-sch-line ),
                     vCommiChar,
                     RECID( acct ),
                     vCommEndDate,
                     vKauChar,
                     vFlPrintLog,
                     OUTPUT RESULT,
                     OUTPUT result1,
                     INPUT-OUTPUT vBegDate,
                     OUTPUT vFlagInt ).
                  RUN SetSysConf IN h_base ("pars-id", ?).
               END.
            vBegDate = vCommEndDate.
            IF vFlagInt NE 0 THEN
            DO:
               ASSIGN
                  result_s = 0
                  remove-amt = 0.
               RETURN.
            END.
            ASSIGN
               result_s = result_s + RESULT
               remove-amt        = remove-amt + result1
               vBegDate          = vCommEndDate
               .

         END.
       /* End-Of-Block По выбранному счету произвожу расчет процентов */
   END.
   pick-value = STRING( result_s ).
END PROCEDURE.


/*
**  Что делает: Производит пересчет процентов по штрафной/основной ставке за
**              период с начала откурытия вкалада, до последнего
**              переноса процентов.
**              Должна идти раньше шаблона переноса процентов на счет клиента иначе
**              не пересчетает
**  Синтаксис : ПерерасчПроц(обязат Назначение, 
**                           необязат Печать, 
**                           необязат Ставка/период):decimal 
**  Автор     : Om 02/04/2001
**  Пример    : ПереРасчПроц ("dps"); ПереРасчПроц ("dps", "Нет"),ПереРасчПроц ("dps","Да","ОснКап")
**  Недопустимо: ПереРасчПроц ("dps", "Осн") !!!!!!!!!!!!!!!!
*/
PROCEDURE ПереРасчПроц.
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   DEF VAR vBase        AS LOGICAL     NO-UNDO. /*Основная или штрашная ставка*/
   DEF VAR vDelay       AS INT64     NO-UNDO.
   DEF VAR vFlClose     AS LOGICAL     NO-UNDO.
   DEF VAR vFrom-kap    AS LOGICAL     NO-UNDO. /*Основная или штрафная ставка╨*/
   DEF VAR vResult      AS DECIMAL     NO-UNDO.
   DEF VAR vFlPrintLog  AS LOGICAL     NO-UNDO. /* Признак печати ведомости */
   DEF VAR vBegDate     AS DATE        NO-UNDO. /* Дата начала периода начисления */
   DEF VAR vEndDate     AS DATE        NO-UNDO. /* Дата окончания периода начисления */
   DEF VAR vFlErr       AS INT64     NO-UNDO. /* Код ошибки начисления */
   DEF VAR vLocalPV     AS CHARACTER   NO-UNDO.

   DEF VAR vDpsHandle   AS HANDLE  NO-UNDO. /* Указатель на параметры договора */

   ASSIGN
      remove-amt  = 0
      vLocalPV    = "0"
      .
   MAIN:
   DO ON ERROR  UNDO, LEAVE
      ON ENDKEY UNDO, LEAVE: 
   
      /* Контроль количества переданных параметров */
      IF param-count LT 1 OR param-count GT 3 THEN 
         UNDO MAIN, LEAVE MAIN.

      /* Разбор полученных параметров */
      ASSIGN
         vBase       = IF     param-count EQ 3 
                          AND GetParam(3, param-str) BEGINS 'Осн' THEN YES 
                                                                  ELSE NO
         vFrom-kap   = IF     param-count EQ 3 
                          AND GetParam(3, param-str) MATCHES '*Кап*' THEN YES 
                                                                     ELSE NO
         vFlPrintLog = IF    (   param-count EQ 2 
                              OR param-count EQ 3) 
                          AND GetParam(2, param-str) EQ "Нет" THEN NO
                                                              ELSE YES
         .
      RUN DPS_VALID_HANDLE (INPUT-OUTPUT vDpsHandle).     
      IF NOT VALID-HANDLE(vDpsHandle) THEN 
         UNDO MAIN, LEAVE MAIN.

      FIND FIRST loan WHERE loan.contract  EQ GetParam(1, param-str)
                        AND loan.cont-code EQ ENTRY(1, SUBSTRING(vDpsHandle:PRIVATE-DATA, 6))
         NO-LOCK NO-ERROR.      
      IF NOT AVAIL loan THEN 
         UNDO MAIN, LEAVE MAIN.
   
      FIND FIRST wop WHERE RECID(wop) EQ rid 
         NO-LOCK NO-ERROR.

      IF NOT AVAIL wop THEN 
         UNDO MAIN, LEAVE MAIN.
   
      /* определяем дату переоформления вклада  vBegDate*/
      RUN get-beg-date-prol IN h_dpspc (RECID(loan),
                                        wop.con-date,
                                        OUTPUT vBegDate, 
                                        OUTPUT vEndDate).
      /* корректировка, если дата переоформления включается в новый период начисления процентов */
      RUN correct_date IN h_dpspc (RECID(loan),
                                   INPUT-OUTPUT vBegDate).
      vEndDate = wop.con-date.
   
      /* определение последней даты капитализации процентов */
      IF vFrom-kap THEN
      DO:
         FIND FIRST op-entry WHERE RECID(op-entry) EQ wop.op-recid 
            NO-LOCK NO-ERROR.
         IF AVAIL op-entry THEN
            FIND FIRST op WHERE op.op EQ op-entry.op 
               NO-LOCK NO-ERROR.
         IF AVAILABLE op THEN
            RUN get_beg_kper IN h_dpspc (RECID(loan),
                                         vEndDate,
                                         op.op-transaction,
                                         INPUT-OUTPUT vBegDate).
         ELSE
            RUN get_beg_kper in h_dpspc (RECID(loan),
                                         vEndDate,
                                         ?,
                                         INPUT-OUTPUT vBegDate).
      END.
         
      RUN get_last_delay IN h_dpspc (RECID(loan),
                                     vEndDate,
                                     vEndDate,
                                     OUTPUT vDelay).
   
      RUN chk_close IN h_dpspc (wop.op-kind,
                                loan.class-code,
                                loan.loan-status,
                                OUTPUT vFlClose).
   
      IF     vFlClose 
         AND vDelay NE ? THEN  
         vEndDate = vEndDate + vDelay.

      RUN Calc_Interest_Full IN h_dpspr (BUFFER loan,
                                         vBegDate,
                                         vEndDate,
                                         vBase,
                                         vFlPrintLog,
                                         OUTPUT vResult,
                                         OUTPUT vFlErr).
      IF vFlErr GE 0 THEN
         vLocalPV = STRING(vResult). 
   END.

   pick-value = vLocalPV.
END PROCEDURE. /* ПереРасчПроц */


/*
**  Что делает: Производит пересчет процентов по штрафной/основной ставке за
**              указанный период. Должна идти раньше шаблона переноса процентов 
**              на счет клиента иначе не пересчетает.
**  Синтаксис : ПерерасчПроцДт(обязат Назначение, 
                               обязат Дата-С,
                               обязат Дата-По
**                             необязат Печать, 
**                             необязат Ставка/период):decimal 
**  Автор     : feak 22/11/2007
**  Пример    : ПереРасчПроцДт ("dps",01/01/05,01/10/05);
                ПереРасчПроцДт ("dps",01/01/05,01/10/05,"Нет");
                ПереРасчПроцДт ("dps",01/01/05,01/10/05,"Да","Осн")
*/
PROCEDURE ПереРасчПроцДт.
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   DEF VAR vBase        AS LOGICAL     NO-UNDO. /*Основная или штрашная ставка*/   
   DEF VAR vResult      AS DECIMAL     NO-UNDO.
   DEF VAR vFlPrintLog  AS LOGICAL     NO-UNDO. /* Признак печати ведомости */
   DEF VAR vBegDate     AS DATE        NO-UNDO. /* Дата начала периода начисления */
   DEF VAR vEndDate     AS DATE        NO-UNDO. /* Дата окончания периода начисления */
   DEF VAR vFlErr       AS INT64     NO-UNDO. /* Код ошибки начисления */
   DEF VAR vLocalPV     AS CHARACTER   NO-UNDO.

   DEF VAR vDpsHandle   AS HANDLE  NO-UNDO. /* Указатель на параметры договора */

   ASSIGN
      remove-amt = 0
      vLocalPV = "0"
      .
   MAIN:
   DO ON ERROR  UNDO, LEAVE
      ON ENDKEY UNDO, LEAVE: 
   
      /* Контроль количества переданных параметров */
      IF param-count LT 3 OR param-count GT 5 THEN 
         UNDO MAIN, LEAVE MAIN.
         
      /* Разбор полученных параметров */
      ASSIGN 
         vBegDate    = DATE(GetParam(2, param-str))
         vEndDate    = DATE(GetParam(3, param-str))
         vBase       = IF     param-count EQ 5 
                          AND GetParam(5, param-str) BEGINS 'Осн' THEN YES 
                                                                  ELSE NO
         vFlPrintLog = IF     param-count            GE 4 
                          AND GetParam(4, param-str) EQ "Нет" 
                       THEN NO
                       ELSE YES
         .

      /* Поиск договора */
      RUN DPS_VALID_HANDLE (INPUT-OUTPUT vDpsHandle).      
      IF NOT VALID-HANDLE(vDpsHandle) THEN 
         UNDO MAIN, LEAVE MAIN.
      FIND FIRST loan WHERE loan.contract  EQ GetParam(1, param-str)
                        AND loan.cont-code EQ ENTRY(1, SUBSTRING(vDpsHandle:PRIVATE-DATA, 6))
         NO-LOCK NO-ERROR.   
      IF NOT AVAIL loan THEN 
         UNDO MAIN, LEAVE MAIN.

      RUN Calc_Interest_Full IN h_dpspr (BUFFER loan,
                                         vBegDate,
                                         vEndDate,
                                         vBase,
                                         vFlPrintLog,
                                         OUTPUT vResult,
                                         OUTPUT vFlErr).
      IF vFlErr GE 0 THEN
         vLocalPV = STRING(vResult). 
   END.

   pick-value = vLocalPV.
END PROCEDURE. /* ПереРасчПроцДт */

/* Начисление процентов по пролонгированным вкладам СР-ВНП с остатком на loan-dps-t */
PROCEDURE НачПрол:
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   RUN НачПролХ (ENTRY(1, PROGRAM-NAME (1), " ")).

   RETURN.
END PROCEDURE.

PROCEDURE НачПрПрол:
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   RUN НачПролХ (ENTRY(1, PROGRAM-NAME (1), " ")).

   RETURN.
END PROCEDURE.

/* Вспомогательная процедура.
** Используется в:
** - НачПрПрол
** - НачПрол */
PROCEDURE НачПролХ:
   DEFINE INPUT PARAMETER ipFuncSeLChar AS CHAR      NO-UNDO. /* Наименование процедуры */
   DEFINE INPUT PARAMETER rid           AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date    AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count   AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str     AS CHARACTER NO-UNDO.

   DEFINE VARIABLE vParam1 AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vParam2 AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vParam3 AS CHARACTER  NO-UNDO.
   DEFINE VARIABLE vResult AS DECIMAL    NO-UNDO.
   DEFINE VARIABLE is-ok   AS LOGICAL    NO-UNDO. /* успешно ли выполнена ? */

   MAIN:
   DO ON ERROR  UNDO MAIN, LEAVE MAIN
      ON ENDKEY UNDO MAIN, LEAVE MAIN:

      IF    param-count NE 2
         OR param-count NE 3 THEN
         UNDO MAIN, LEAVE MAIN.

      ASSIGN
         vParam3 = IF param-count EQ 2
                   THEN GetParam(3,param-str)
                   ELSE ?
         vParam1 = GetParam(1,param-str)
         vParam2 = GetParam(2,param-str)
      .

      RUN nachprox.p (in-op-date,
                      rid,
                      ipFuncSeLChar,
                      vParam1,
                      vParam2,
                      vParam3,
                      OUTPUT vResult,
                      OUTPUT is-ok).

      pick-value = STRING(vResult).
   END.

   RETURN.
END PROCEDURE.

/*Излишне выплаченные проценты за прошлый год*/
/*
**  Что делает: Производит расчет излишненачисленных процентов за прошлый год
**  Синтаксис : ИзлишВыплачПроцПрошл (обязат Счет, 
                               обязат Валюта, 
                               обязат Остаток,
**                             необязат Печать):decimal 
**  Автор     : sap 30/1/2009
**  Пример    : ИзлишВыплачПроцПрошл (Роль("loan-dps-t"),РольСчетВал("loan-dps-t"), "НачПрС",Нет)
                ИзлишВыплачПроцПрошл (Роль("loan-dps-int"),РольСчетВал("loan-dps-t"), "НачПр")
                
*/
PROCEDURE ИзлишВыплачПроцПрошл.
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.
   
   DEF VAR vBegDate     AS DATE        NO-UNDO. /* Дата начала периода начисления */
   DEF VAR vEndDate     AS DATE        NO-UNDO. /* Дата окончания периода начисления */
   DEF VAR vEndLoan     AS DATE        NO-UNDO. /* Дата окончания вклада */ 
   DEF VAR vResult      AS DECIMAL     NO-UNDO. /* Результат */
   DEF VAR vFlErr       AS INT64     NO-UNDO. /* Код ошибки начисления */
   DEF VAR vDpsHandle   AS HANDLE      NO-UNDO. /* Указатель на параметры договора */
   DEF VAR vLocalPV     AS CHARACTER   NO-UNDO.
   DEF VAR vAcct        AS CHARACTER   NO-UNDO.  
   DEF VAR vCurrency    AS CHARACTER   NO-UNDO.  
   DEF VAR vKau         AS CHARACTER   NO-UNDO.  
   DEF VAR vFlPrintLog  AS LOGICAL     NO-UNDO. /* Признак печати ведомости */
   DEF VAR vNewYear     AS DATE        NO-UNDO. /* Новый год!*/ 


   MAIN:
   DO ON ERROR  UNDO, LEAVE
      ON ENDKEY UNDO, LEAVE: 
       /* Контроль количества переданных параметров */
       IF param-count < 3  THEN 
          UNDO MAIN, LEAVE MAIN.

       /* Поиск договора */
       RUN DPS_VALID_HANDLE (INPUT-OUTPUT vDpsHandle).      
       IF NOT VALID-HANDLE(vDpsHandle) THEN 
          UNDO MAIN, LEAVE MAIN.

       FIND FIRST loan WHERE loan.contract  EQ "dps"
                         AND loan.cont-code EQ ENTRY(1, SUBSTRING(vDpsHandle:PRIVATE-DATA, 6))
          NO-LOCK NO-ERROR.   
       IF NOT AVAIL loan THEN 
          UNDO MAIN, LEAVE MAIN.

       FIND FIRST wop WHERE RECID(wop) EQ rid NO-LOCK NO-ERROR.
       IF NOT AVAIL wop THEN DO:
          pick-value = STRING(0).
          RETURN.
       END.
       FIND FIRST op-entry WHERE
             RECID( op-entry ) = wop.op-recid NO-LOCK NO-ERROR.

       IF AVAILABLE op-entry THEN
          FIND FIRST op WHERE
                op.op = op-entry.op NO-LOCK NO-ERROR.
       ELSE
          FIND FIRST op WHERE RECID(op) = wop.op-recid NO-LOCK NO-ERROR.


       ASSIGN
           vAcct       = GetParam (1, param-str)         
           vKau        = GetParam (3, param-str)
           vCurrency   = IF GetParam (2, param-str) = FGetSetting("КодНацВал",?,?)
                         THEN ""
                         ELSE GetParam (2, param-str)

           vFlPrintLog = IF param-count = 4 AND GetParam(4, param-str) EQ "Нет" 
                         THEN NO
                         ELSE YES

           vNewYear =   DATE(12,31,YEAR(wop.con-date) - 1)
        .

      /* определяем дату переоформления вклада  vBegDate*/
      RUN get-beg-date-prol in h_dpspc  (RECID(loan),
                                                 wop.con-date,
                                                 OUTPUT vBegDate, 
                                                 OUTPUT vEndLoan).
      
      /* корректировка, если дата переоформления включается в новый период 
      начисления процентов */
      RUN correct_date in h_dpspc (RECID(loan),
                                   INPUT-OUTPUT vBegDate).

      /*если вклад открыт в этом году - и считать нечего*/
      IF vBegDate > vNewYear  THEN DO: 
          pick-value = string(0).
          LEAVE MAIN.
      END.

      vEndDate = vBegDate.
      /*Определение даты капитализации vEndDate относительно нового года - 
      последняя капитализация в прошлом году */
      RUN get_beg_kper in h_dpspc (RECID(loan),
                                   vNewYear, 
                                   wop.op-transaction,
                                   INPUT-OUTPUT vEndDate).

      /*Если капитализации не было*/
      IF vEndDate EQ ? THEN vEndDate = vBegDate.

      RUN Calc_Unnecessary_Full IN h_dpspr (BUFFER loan,
                                            vAcct,
                                            vCurrency,
                                            loan.contract + "," + loan.cont-code + "," + vKau,
                                            vBegDate,
                                            vEndDate,
                                            vFlPrintLog,   
                                            OUTPUT vResult, 
                                            OUTPUT vFlErr).
      IF vResult < 0 OR  vFlErr < 0 THEN vResult = 0.
      pick-value = STRING(vResult). 

   END.

END PROCEDURE.

/*Излишневыполаченные проценты за весь период*/
/*
**  Что делает: Производит расчет излишненачисленных процентов за весь период
**  Синтаксис : ИзлишВыплачПроц (обязат Счет, 
                               обязат Валюта, 
                               обязат Остаток,
**                             необязат Печать):decimal 
**  Автор     : sap 30/1/2009
**  Пример    : ИзлишВыплачПроц (Роль("loan-dps-t"),РольСчетВал("loan-dps-t"), "НачПрС",Нет)
                ИзлишВыплачПроц (Роль("loan-dps-int"),РольСчетВал("loan-dps-t"), "НачПр")                
*/
PROCEDURE ИзлишВыплачПроц.
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.
   
   DEF VAR vBegDate     AS DATE        NO-UNDO. /* Дата начала периода начисления */
   DEF VAR vEndDate     AS DATE        NO-UNDO. /* Дата окончания периода начисления */
   DEF VAR vEndLoan     AS DATE        NO-UNDO. /* Дата окончания вклада */ 
   DEF VAR vResult      AS DECIMAL     NO-UNDO. /* Результат */
   DEF VAR vFlErr       AS INT64     NO-UNDO. /* Код ошибки начисления */
   DEF VAR vDpsHandle   AS HANDLE      NO-UNDO. /* Указатель на параметры договора */
   DEF VAR vLocalPV     AS CHARACTER   NO-UNDO.
   DEF VAR vAcct        AS CHARACTER   NO-UNDO.  
   DEF VAR vCurrency    AS CHARACTER   NO-UNDO.  
   DEF VAR vKau         AS CHARACTER   NO-UNDO.  
   DEF VAR vFlPrintLog  AS LOGICAL     NO-UNDO. /* Признак печати ведомости */

   MAIN:
   DO ON ERROR  UNDO, LEAVE
      ON ENDKEY UNDO, LEAVE: 
   
      /* Контроль количества переданных параметров */
      IF param-count < 3  THEN 
         UNDO MAIN, LEAVE MAIN.

      /* Поиск договора */
      RUN DPS_VALID_HANDLE (INPUT-OUTPUT vDpsHandle).      
      IF NOT VALID-HANDLE(vDpsHandle) THEN 
         UNDO MAIN, LEAVE MAIN.

      FIND FIRST loan WHERE loan.contract  EQ "dps"
                        AND loan.cont-code EQ ENTRY(1, SUBSTRING(vDpsHandle:PRIVATE-DATA, 6))
         NO-LOCK NO-ERROR.   
      IF NOT AVAIL loan THEN 
         UNDO MAIN, LEAVE MAIN.

      FIND FIRST wop WHERE RECID(wop) EQ rid NO-LOCK NO-ERROR.
      IF NOT AVAIL wop THEN DO:
         pick-value = STRING(0).
         RETURN.
      END.
      FIND FIRST op-entry WHERE
            RECID( op-entry ) = wop.op-recid NO-LOCK NO-ERROR.

      IF AVAILABLE op-entry THEN
         FIND FIRST op WHERE
               op.op = op-entry.op NO-LOCK NO-ERROR.
      ELSE
         FIND FIRST op WHERE RECID(op) = wop.op-recid NO-LOCK NO-ERROR.


      ASSIGN
          vAcct       = GetParam (1, param-str)         
          vKau        = GetParam (3, param-str)
          vCurrency   = IF GetParam (2, param-str) = FGetSetting("КодНацВал",?,?)
                        THEN ""
                        ELSE GetParam (2, param-str)

          vFlPrintLog = IF param-count = 4 AND GetParam(4, param-str) EQ "Нет" 
                        THEN NO
                        ELSE YES.

      /* определяем дату переоформления вклада  vBegDate*/
      RUN get-beg-date-prol in h_dpspc (RECID(loan),
                                        wop.con-date,
                                        OUTPUT vBegDate, 
                                        OUTPUT vEndLoan).

      /* корректировка, если дата переоформления включается в новый период начисления процентов */
      RUN correct_date IN  h_dpspc (RECID(loan),
                                   INPUT-OUTPUT vBegDate).
      
      vEndDate = vBegDate.
      /*Определение даты капитализации vEndDate*/
      RUN get_beg_kper IN  h_dpspc (RECID(loan),
                                   wop.con-date,
                                   IF AVAIL op THEN op.op-transaction ELSE ?,
                                   INPUT-OUTPUT vEndDate).


      /*Если капитализации не было*/
      IF vEndDate EQ ? THEN vEndDate = vBegDate.

      RUN Calc_Unnecessary_Full (BUFFER loan,
                                 vAcct,
                                 vCurrency,
                                 loan.contract + "," + loan.cont-code + "," + vKau,
                                 vBegDate,
                                 vEndDate,
                                 vFlPrintLog,   
                                 OUTPUT vResult, 
                                 OUTPUT vFlErr).

      IF vResult < 0  THEN vResult = 0.
      pick-value = STRING(vResult). 
   END.

END PROCEDURE.


/***  Что делает: определяет сумму излишне выплаченных процентов и еще не
 отнесенных на расходы
**  Синтаксис : ИзлишВыпНеотн ():decimal 
**  Автор     : Deas 07/2012
**  Пример    : ИзлишВыпНеотн ()
*/
PROCEDURE ИзлишВыпНеотн.
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64     NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   DEF VAR vBegDate     AS DATE        NO-UNDO. /* Дата начала периода начисления */
   DEF VAR vEndLoan     AS DATE        NO-UNDO. /* Дата окончания вклада */ 
   DEF VAR vResult      AS DECIMAL     NO-UNDO. /* Результат */
   DEF VAR vDpsHandle   AS HANDLE      NO-UNDO. /* Указатель на параметры договора */
   DEF VAR vAcctCr      AS CHARACTER   NO-UNDO.
   DEF VAR vAcctDb      AS CHARACTER   NO-UNDO.
   DEFINE BUFFER buf-op-entry FOR op-entry.
   DEFINE BUFFER buf-op       FOR op.
   
   MAIN:
   DO ON ERROR  UNDO, LEAVE
      ON ENDKEY UNDO, LEAVE: 
   
      /* Поиск договора */
      RUN DPS_VALID_HANDLE (INPUT-OUTPUT vDpsHandle).      
      IF NOT VALID-HANDLE(vDpsHandle) THEN 
         UNDO MAIN, LEAVE MAIN.

      FIND FIRST loan WHERE loan.contract  EQ "dps"
                        AND loan.cont-code EQ ENTRY(1, SUBSTRING(vDpsHandle:PRIVATE-DATA, 6))
         NO-LOCK NO-ERROR.   
      IF NOT AVAIL loan THEN 
         UNDO MAIN, LEAVE MAIN.

      FIND FIRST wop WHERE RECID(wop) EQ rid NO-LOCK NO-ERROR.
      IF NOT AVAIL wop THEN DO:
         pick-value = STRING(0).
         RETURN.
      END.
      FIND FIRST op-entry WHERE
            RECID( op-entry ) = wop.op-recid NO-LOCK NO-ERROR.

      IF AVAILABLE op-entry THEN
         FIND FIRST op WHERE
               op.op = op-entry.op NO-LOCK NO-ERROR.
      ELSE
         FIND FIRST op WHERE RECID(op) = wop.op-recid NO-LOCK NO-ERROR.

      /* определяем дату переоформления вклада  vBegDate*/
      RUN get-beg-date-prol in h_dpspc (RECID(loan),
                                        wop.con-date,
                                        OUTPUT vBegDate, 
                                        OUTPUT vEndLoan).

      /* корректировка, если дата переоформления включается в новый период начисления процентов */
      RUN correct_date IN  h_dpspc (RECID(loan),
                                   INPUT-OUTPUT vBegDate).

      FIND LAST loan-acct WHERE loan-acct.contract  EQ loan.contract 
                            AND loan-acct.cont-code EQ loan.cont-code 
                            AND loan-acct.since     LE wop.con-date
                            AND loan-acct.acct-type EQ "loan-dps-adv"
         NO-LOCK NO-ERROR.
      IF AVAIL loan-acct THEN
         vAcctCr = loan-acct.acct.
      FIND LAST loan-acct WHERE loan-acct.contract  EQ loan.contract 
                            AND loan-acct.cont-code EQ loan.cont-code 
                            AND loan-acct.since     LE wop.con-date
                            AND loan-acct.acct-type EQ "loan-expens"
         NO-LOCK NO-ERROR.
      IF AVAIL loan-acct THEN
         vAcctDb = loan-acct.acct.
      vResult = 0.
      cl:
      FOR EACH signs WHERE signs.code      EQ "DrVklad"
                       AND signs.file-name EQ "op-entry"  
                       AND signs.code-val  EQ loan.cont-code
         NO-LOCK:
         FIND FIRST buf-op-entry WHERE buf-op-entry.op       EQ INT64(ENTRY(1,signs.surrogate))
                                   AND buf-op-entry.op-entry EQ INT64(ENTRY(2,signs.surrogate))
            NO-LOCK NO-ERROR.
         IF buf-op-entry.acct-cr NE vAcctCr
            OR buf-op-entry.acct-db NE vAcctDb THEN
            NEXT cl.
         FIND FIRST buf-op WHERE buf-op.op EQ buf-op-entry.op
            NO-LOCK NO-ERROR.
         IF buf-op.contract-date LT vBegDate
            OR buf-op.contract-date GE wop.con-date THEN
            NEXT cl.
         IF loan.currency EQ "" THEN
            vResult = vResult + buf-op-entry.amt-rub.
         ELSE
            vResult = vResult + buf-op-entry.amt-cur.
      END.
      IF vResult < 0  THEN vResult = 0.
      pick-value = STRING(vResult). 
   END.
END PROCEDURE.


/*  Что делает: Возвращает сумму излишне начисленных или выплаченных процентов 
**              в рублях по валютному вкладу за период (предыдущий, отчетный 
**              или текущий) на дату признания или на дату расторжения.
**              Данные берутся с допреквизитов "СуммПерерасчДатаПризн" и 
**              "СуммПерерасчДатаРасторж" соответвенно на суб.проводок. Реквизиты 
**              заполняются парсерной функцией "ИзлишПроцВалДЗ" (т.е. она
**              должна быть запущена в транзакции).
**  Синтаксис : ИзлишПроцРубДЗ(обязат Начисленные/Выплаченные проценты, 
                               обязат Период (предыдущий, отчетный или текущий), 
                               обязат Дата, на которую сконвертированы валюты (признания или расторжения),
                               :decimal
**  Примеры   : ИзлишПроцРубДЗ("Начисленные","Текущий","Признания")
**              ИзлишПроцРубДЗ("Выплаченные","Отчетный","Расторжения")
*/
PROCEDURE ИзлишПроцРубДЗ:
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   DEFINE VARIABLE vResult    AS DECIMAL   INIT ?  NO-UNDO.
   DEFINE VARIABLE h_templ    AS HANDLE            NO-UNDO. 
   DEFINE VARIABLE vPeriod    AS CHARACTER         NO-UNDO.
   DEFINE VARIABLE vType      AS CHARACTER         NO-UNDO.
   DEFINE VARIABLE vForDate   AS CHARACTER         NO-UNDO.
   DEFINE VARIABLE vTmpStr    AS CHARACTER         NO-UNDO.
   DEFINE VARIABLE vBegDate   AS DATE              NO-UNDO.
   DEFINE VARIABLE vEndDate   AS DATE              NO-UNDO.
   DEFINE VARIABLE vErrMes    AS CHARACTER         NO-UNDO.

   DEF BUFFER loan      FOR loan.
   DEF BUFFER op        FOR op.
   DEF BUFFER op-entry  FOR op-entry.

   MAIN:
   DO ON ERROR  UNDO MAIN, LEAVE MAIN
      ON ENDKEY UNDO MAIN, LEAVE MAIN:
      
      IF param-count NE 3 THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("", "", "-1", "Неверное число параметров передано в функцию <ИзлишПроцРубДЗ>.").
         UNDO MAIN, LEAVE MAIN.
      END.

      ASSIGN
         vType    = GetParam(1, param-str) WHEN CAN-DO("Начисленные,Выплаченные", GetParam(1, param-str))
         vPeriod  = GetParam(2, param-str) WHEN CAN-DO("Прошлый,Текущий,Отчетный", GetParam(2, param-str))
         vForDate = GetParam(3, param-str) WHEN CAN-DO("Признания,Расторжения", GetParam(3, param-str))
         .
      IF    NOT {assigned vType}
         OR NOT {assigned vPeriod} THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("", "", "-1", "Неверные параметры переданы в парсерную функцию <ИзлишПроцРубДЗ>.").
         UNDO MAIN, LEAVE MAIN.
      END.

      RUN DPS_VALID_HANDLE (INPUT-OUTPUT h_templ).   
      IF NOT VALID-HANDLE(h_templ) THEN 
         UNDO MAIN, LEAVE MAIN.
      FIND FIRST loan WHERE loan.contract  EQ "dps"
                        AND loan.cont-code EQ ENTRY(1, SUBSTRING(h_templ:PRIVATE-DATA, 6))
         NO-LOCK NO-ERROR.      
      IF NOT AVAIL loan THEN 
         UNDO MAIN, LEAVE MAIN.

      RUN GetDateForProcRecalc IN h_dpspr (RECID(loan),
                                           in-op-date,
                                           YES,
                                           vPeriod,
                                           OUTPUT vBegDate,
                                           OUTPUT vEndDate,
                                           OUTPUT vErrMes).
      IF {assigned vErrMes} THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("", "", "-1", vErrMes).
         UNDO MAIN, LEAVE MAIN.
      END.

      IF     vBegDate NE ?
         AND vEndDate NE ? THEN      
      DO:
         FIND FIRST wop WHERE RECID(wop) EQ rid 
            NO-LOCK NO-ERROR.
         IF NOT AVAIL wop THEN 
         DO:
            pick-value = STRING(0).
            UNDO MAIN, LEAVE MAIN.
         END.
         FIND FIRST op-entry WHERE RECID(op-entry) EQ wop.op-recid 
            NO-LOCK NO-ERROR.
         IF AVAILABLE op-entry THEN
            FIND FIRST op WHERE op.op EQ op-entry.op 
               NO-LOCK NO-ERROR.
         ELSE
            FIND FIRST op WHERE RECID(op) EQ wop.op-recid 
               NO-LOCK NO-ERROR.

         RUN GetIzlSummRub_AfterRecalc IN h_dpspr (RECID(loan),
                                                   vBegDate,
                                                   vEndDate,
                                                   in-op-date,
                                                   op.op-transaction,
                                                   vType,   
                                                   vForDate,
                                                   OUTPUT vResult,
                                                   OUTPUT vErrMes).
         IF {assigned vErrMes} THEN
         DO:
            RUN Fill-SysMes IN h_tmess ("", "", "-1", vErrMes).
            UNDO MAIN, LEAVE MAIN.
         END.
      END.         
      ELSE 
         vResult = 0.      
   END.

   pick-value = STRING(vResult).
END PROCEDURE.


/*  Что делает: Возвращает сумму начисленных или выплаченных процентов  
**              по валютному вкладу за период (предыдущий, отчетный или текущий) 
**              в валюте для дату признания или на дату расторжения.
**              Функция идет по всем суб.проводкам НАЧИСЛЕНИЯ и ДОНАЧИСЛЕНИЯ 
**              процентов и помимо подсчета их сумм сохраняет также данные
**              о конвертированных в рубли средствах на реквизитах субпроводок
**              "СуммПерерасчДатаПризн" и "СуммПерерасчДатаРасторж" соответвенно.
**              Эти данные в будущем нужны для работы парсерной функции
**              ИзлишПроцРубДЗ (т.е. она должна быть запущена после этой).
**  Синтаксис : ИзлишПроцВалДЗ(обязат Начисленные/Выплаченные проценты, 
                               обязат Период (предыдущий, отчетный или текущий), 
                               необязат Печать в лог, по умолчанию = Нет
                               :decimal
**  Примеры   : ИзлишПроцВалДЗ("Начисленные","Текущий")
**              ИзлишПроцВалДЗ("Выплаченные","Отчетный",Да)
*/
PROCEDURE ИзлишПроцВалДЗ:
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   DEFINE VARIABLE vResult    AS DECIMAL   INIT ?  NO-UNDO.
   DEFINE VARIABLE h_templ    AS HANDLE            NO-UNDO. 
   DEFINE VARIABLE vPeriod    AS CHARACTER         NO-UNDO.
   DEFINE VARIABLE vType      AS CHARACTER         NO-UNDO.   
   DEFINE VARIABLE vTmpStr    AS CHARACTER         NO-UNDO.
   DEFINE VARIABLE vLog       AS LOGICAL           NO-UNDO.
   DEFINE VARIABLE vBegDate   AS DATE              NO-UNDO.
   DEFINE VARIABLE vEndDate   AS DATE              NO-UNDO.
   DEFINE VARIABLE vErrMes    AS CHARACTER         NO-UNDO.

   DEF BUFFER loan FOR loan.

   MAIN:
   DO ON ERROR  UNDO MAIN, LEAVE MAIN
      ON ENDKEY UNDO MAIN, LEAVE MAIN:
      
      IF     param-count NE 2
         AND param-count NE 3 THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("", "", "-1", "Неверное число параметров передано в функцию <ИзлишПроцВалДЗ>.").
         UNDO MAIN, LEAVE MAIN.
      END.

      ASSIGN
         vType    = GetParam(1, param-str)         WHEN CAN-DO("Начисленные,Выплаченные", GetParam(1, param-str))
         vPeriod  = GetParam(2, param-str)         WHEN CAN-DO("Прошлый,Текущий,Отчетный", GetParam(2, param-str))         
         vLog     = GetParam(3, param-str) EQ "Да" WHEN param-count EQ 3
         .
      IF    NOT {assigned vType}
         OR NOT {assigned vPeriod} THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("", "", "-1", "Неверные параметры переданы в парсерную функцию <ИзлишПроцВалДЗ>.").
         UNDO MAIN, LEAVE MAIN.
      END.

      RUN DPS_VALID_HANDLE (INPUT-OUTPUT h_templ).   
      IF NOT VALID-HANDLE(h_templ) THEN 
         UNDO MAIN, LEAVE MAIN.
      FIND FIRST loan WHERE loan.contract  EQ "dps"
                        AND loan.cont-code EQ ENTRY(1, SUBSTRING(h_templ:PRIVATE-DATA, 6))
         NO-LOCK NO-ERROR.      
      IF NOT AVAIL loan THEN 
         UNDO MAIN, LEAVE MAIN.      

      RUN GetDateForProcRecalc IN h_dpspr (RECID(loan),
                                           in-op-date,
                                           YES,
                                           vPeriod,
                                           OUTPUT vBegDate,
                                           OUTPUT vEndDate,
                                           OUTPUT vErrMes).
      IF {assigned vErrMes} THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("", "", "-1", vErrMes).
         UNDO MAIN, LEAVE MAIN.
      END.

      IF     vBegDate NE ?
         AND vEndDate NE ? THEN   
      DO:      
         FIND FIRST wop WHERE RECID(wop) EQ rid 
            NO-LOCK NO-ERROR.
         IF NOT AVAIL wop THEN 
         DO:
            pick-value = STRING(0).
            UNDO MAIN, LEAVE MAIN.
         END.
         FIND FIRST op-entry WHERE RECID(op-entry) EQ wop.op-recid 
            NO-LOCK NO-ERROR.
         IF AVAILABLE op-entry THEN
            FIND FIRST op WHERE op.op EQ op-entry.op 
               NO-LOCK NO-ERROR.
         ELSE
            FIND FIRST op WHERE RECID(op) EQ wop.op-recid 
               NO-LOCK NO-ERROR.

         RUN GetIzlSummRub_wRecalc IN h_dpspr (RECID(loan),
                                               vBegDate,
                                               vEndDate,
                                               in-op-date,
                                               op.op-transaction,
                                               vType,                                          
                                               vLog,
                                               OUTPUT vResult,
                                               OUTPUT vErrMes).
         IF {assigned vErrMes} THEN
         DO:
            RUN Fill-SysMes IN h_tmess ("", "", "-1", vErrMes).
            UNDO MAIN, LEAVE MAIN.
         END.
      END.
      ELSE 
         vResult = 0.      
   END.

   pick-value = STRING(vResult).
END PROCEDURE.


/*  Что делает: Определяет, емеется ли по вкладу требуемый период 
**              (предыдущий, отчетный или текущий).
**  Синтаксис : ИмеетПериодДЗ(обязат Период (предыдущий, отчетный или текущий)
                             :decimal
**  Примеры   : ИмеетПериодДЗ("Текущий")
**              ИмеетПериодДЗ("Отчетный")
*/
PROCEDURE ИмеетПериодДЗ:
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64   NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   DEFINE VARIABLE vResult    AS INT64           NO-UNDO.
   DEFINE VARIABLE h_templ    AS HANDLE            NO-UNDO. 
   DEFINE VARIABLE vPeriod    AS CHARACTER         NO-UNDO. 
   DEFINE VARIABLE vBegDate   AS DATE              NO-UNDO.
   DEFINE VARIABLE vEndDate   AS DATE              NO-UNDO.
   DEFINE VARIABLE vErrMes    AS CHARACTER         NO-UNDO.

   DEF BUFFER loan FOR loan.

   MAIN:
   DO ON ERROR  UNDO MAIN, LEAVE MAIN
      ON ENDKEY UNDO MAIN, LEAVE MAIN:
      
      IF    param-count NE 1 THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("", "", "-1", "Неверное число параметров передано в функцию <ИмеетПериодДЗ>.").
         UNDO MAIN, LEAVE MAIN.
      END.

      ASSIGN         
         vPeriod  = GetParam(1, param-str)         WHEN CAN-DO("Прошлый,Текущий,Отчетный", GetParam(2, param-str))                  
         .
      IF NOT {assigned vPeriod} THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("", "", "-1", "Неверные параметры переданы в парсерную функцию <ИмеетПериодДЗ>.").
         UNDO MAIN, LEAVE MAIN.
      END.

      RUN DPS_VALID_HANDLE (INPUT-OUTPUT h_templ).   
      IF NOT VALID-HANDLE(h_templ) THEN 
         UNDO MAIN, LEAVE MAIN.
      FIND FIRST loan WHERE loan.contract  EQ "dps"
                        AND loan.cont-code EQ ENTRY(1, SUBSTRING(h_templ:PRIVATE-DATA, 6))
         NO-LOCK NO-ERROR.      
      IF NOT AVAIL loan THEN 
         UNDO MAIN, LEAVE MAIN.

      RUN GetDateForProcRecalc IN h_dpspr (RECID(loan),
                                           in-op-date,
                                           YES,
                                           vPeriod,
                                           OUTPUT vBegDate,
                                           OUTPUT vEndDate,
                                           OUTPUT vErrMes).
      IF {assigned vErrMes} THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("", "", "-1", vErrMes).
         UNDO MAIN, LEAVE MAIN.
      END.

      IF     vBegDate NE ?
         AND vEndDate NE ? THEN 
         vResult = 1.
      ELSE 
         vResult = 0.      
   END.

   pick-value = STRING(vResult).
END PROCEDURE.

/*  Что делает: Определяет, нужен ли по пересчет процентов при штрафном изъятии 
**  Синтаксис : НуженПересч()
*/
{dps_fshtr.i}
PROCEDURE НуженПересч:
   DEFINE INPUT PARAMETER rid         AS RECID     NO-UNDO.
   DEFINE INPUT PARAMETER in-op-date  AS DATE      NO-UNDO.
   DEFINE INPUT PARAMETER param-count AS INT64     NO-UNDO.
   DEFINE INPUT PARAMETER param-str   AS CHARACTER NO-UNDO.

   DEFINE VARIABLE vResult      AS INT64      NO-UNDO.
   DEFINE VARIABLE h_templ      AS HANDLE     NO-UNDO. 
   DEFINE VARIABLE vBegDate     AS DATE       NO-UNDO.
   DEFINE VARIABLE vEndDate     AS DATE       NO-UNDO.
   DEFINE VARIABLE vShtrPeresch AS CHAR       NO-UNDO. 
   DEFINE VARIABLE vDatePeresch AS DATE        NO-UNDO.

   DEF BUFFER loan FOR loan.
   
   MESSAGE "Внимание!" SKIP 
	    "В данный момент излишневыплаченные проценты могут расчитываться с ошибкой." SKIP
	    "При возникновении ошибки, перезайдите в бисквит"
	    "и повторно запустите изъятие с вклада" VIEW-AS ALERT-BOX.
   vResult = 0.
   MAIN:
   DO ON ERROR  UNDO MAIN, LEAVE MAIN
      ON ENDKEY UNDO MAIN, LEAVE MAIN:
      
      IF    param-count NE 0 THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("", "", "-1", "Неверное число параметров передано в функцию <НуженПересч>.").
         UNDO MAIN, LEAVE MAIN.
      END.

      RUN DPS_VALID_HANDLE (INPUT-OUTPUT h_templ).   
      IF NOT VALID-HANDLE(h_templ) THEN 
         UNDO MAIN, LEAVE MAIN.
      FIND FIRST loan WHERE loan.contract  EQ "dps"
                        AND loan.cont-code EQ ENTRY(1, SUBSTRING(h_templ:PRIVATE-DATA, 6))
         NO-LOCK NO-ERROR.      
      IF NOT AVAIL loan THEN 
         UNDO MAIN, LEAVE MAIN.
      vShtrPeresch = GetXattrValueEx ("loan",
                                      loan.contract + "," + loan.cont-code,
                                      "ШтрафПересчет",
                                      ?).
      vDatePeresch = DATE (vShtrPeresch) NO-ERROR. /* Дата пересчета*/ 

      RUN get-beg-date-prol IN h_dpspc (RECID(loan),
                                        in-op-date,
                                        OUTPUT vBegDate,
                                        OUTPUT vEnddate).
  
      IF CAN-DO("Дюж*",loan.cont-type) THEN
      DO:
      /* Проверки необходимости запуска пересчета процентов */
      IF NOT {assigned vShtrPeresch}
         OR vDatePeresch LT vBegDate THEN /* Не было Пересчета в пределах виртуальной жизни вклада */
         vResult = 1.
      ELSE 
         vResult = 0.      
      END. ELSE DO:
         vResult = (IF IsFirstShtrIzVkl(RECID(loan), in-op-date) THEN 1 ELSE 0).
      END.
   END.
   pick-value = STRING(vResult).
END PROCEDURE.

/*
  выплаченные проценты по вкладу с учетом капит. на срочный и просто на дв 
  выплачпроц(датанач,датакон)
 */
PROCEDURE выплачпроц.
   DEF INPUT PARAM rid         AS RECID NO-UNDO.
   DEF INPUT PARAM in-op-date  AS DATE  NO-UNDO.
   DEF INPUT PARAM param-count AS INT64   NO-UNDO.
   DEF INPUT PARAM param-str   AS CHAR  NO-UNDO.

   DEF VAR h_templ   AS HANDLE      NO-UNDO. 
   DEF VAR vAcct     AS CHARACTER   NO-UNDO. /* Счет */
   DEF VAR vCurrency AS CHARACTER   NO-UNDO. /* Валюта */
   DEF VAR vKau      AS CHARACTER   NO-UNDO. /* Субостаток */
   DEF VAR vBegDate  AS DATE        NO-UNDO. /* Дата начала */
   DEF VAR vEndDate  AS DATE        NO-UNDO. /* Дата окончания */
   DEF VAR vResult   AS DECIMAL     NO-UNDO. /* Результат */
   DEF VAR vLocalPV  AS CHARACTER   NO-UNDO.
   DEF VAR vFlErr    AS INT64     NO-UNDO. /* Флаг ошибки */
   DEF VAR iKauCode AS CHAR NO-UNDO.

    vLocalPV = "0".
    vResult = 0.

   MAIN:
   DO ON ERROR  UNDO, LEAVE
      ON ENDKEY UNDO, LEAVE: 
     
      IF param-count NE 2 THEN 
      DO:
         RUN Fill-SysMes ("", "", "-1", "Ошибочное количество параметров передано в функцию 'НЧПрогресс'.").
         UNDO MAIN, LEAVE MAIN.
      END.

      RUN DPS_VALID_HANDLE (INPUT-OUTPUT h_templ).   
      IF NOT VALID-HANDLE(h_templ) THEN 
         UNDO MAIN, LEAVE MAIN.
      FIND FIRST loan WHERE loan.contract  EQ "dps"
                        AND loan.cont-code EQ ENTRY(1, SUBSTRING(h_templ:PRIVATE-DATA, 6))
         NO-LOCK NO-ERROR.      
      IF NOT AVAIL loan THEN 
         UNDO MAIN, LEAVE MAIN.

      /*FIND FIRST wop WHERE RECID(wop) EQ rid 
         NO-LOCK NO-ERROR.
      IF NOT AVAIL wop THEN 
         UNDO MAIN, LEAVE MAIN.*/

      ASSIGN
         /*vAcct       = GetParam (1, param-str)         
         vKau        = GetParam (3, param-str)*/
         vBegDate    = DATE(GetParam (1, param-str))
         vEndDate    = DATE(GetParam (2, param-str))
         /*vCurrency   = STRING(GetParam(2, param-str), "999")*/.
         .  

    iKauCode = loan.contract + ',' + loan.cont-code + ',начпр'.
    FOR EACH kau-entry
     WHERE /*kau-entry.acct = acct.acct AND
                kau-entry.currency = iCurrency AND*/
                kau-entry.kau = iKauCode AND
                kau-entry.kau-id = 'loan-dps-int' AND
                kau-entry.debit /*AND
                kau-entry.op-date >= vBegDate - iPlanDelay AND
                kau-entry.op-date <= vEndDate + iPlanDelay*/,
                FIRST op OF kau-entry NO-LOCK:
            	    FIND FIRST op-entry OF op
            	      WHERE op-entry.op-entry EQ kau-entry.op-entry
            	      NO-LOCK.
                    /*выбрасываем из диапазона, что по плановым датам не попало в период*/
                    IF op.contract-date > vEndDate OR
                       op.contract-date < vBegDate
                    THEN NEXT.
            	    /* выбрасываем возврат процентов */
                    IF CAN-DO ( "70606*,70601........172*", op-entry.acct-cr) OR
                       CAN-DO ( "70606*,70601........172*", op.ben-acct) THEN NEXT.
            	    /* выплата процентов */
            	    vResult = vResult + IF loan.currency EQ "" 
                                             THEN kau-entry.amt-rub
                                             ELSE kau-entry.amt-cur.
    END.

    /* еще надо отнять возвращенные проценты с 423* счета */
    iKauCode = loan.contract + ',' + loan.cont-code + ','.
    FOR EACH kau-entry
     WHERE      kau-entry.kau begins iKauCode AND
                kau-entry.kau-id = 'loan-dps-t' AND
                kau-entry.debit,
                FIRST op OF kau-entry NO-LOCK:
            	    FIND FIRST op-entry OF op
            	      WHERE op-entry.op-entry EQ kau-entry.op-entry
            	      NO-LOCK.
                    /*выбрасываем из диапазона, что по плановым датам не попало в период*/
                    IF op.contract-date > vEndDate OR
                       op.contract-date < vBegDate
                    THEN NEXT.
                    IF CAN-DO ( "70606*,70601........172*", op-entry.acct-cr) OR
                       CAN-DO ( "70606*,70601........172*", op.ben-acct) THEN DO:
                        /* возврат процентов */
                	vResult = vResult - IF loan.currency EQ "" 
                                              THEN kau-entry.amt-rub
                                              ELSE kau-entry.amt-cur.
                    END.
    END.

    vLocalPV = STRING(vResult).
   END.
   pick-value = vLocalPV.
END PROCEDURE.

/*
  возвращенные излишние проценты
  выплачпроц(датанач,датакон)
 */
PROCEDURE излишпроц.
   DEF INPUT PARAM rid         AS RECID NO-UNDO.
   DEF INPUT PARAM in-op-date  AS DATE  NO-UNDO.
   DEF INPUT PARAM param-count AS INT64   NO-UNDO.
   DEF INPUT PARAM param-str   AS CHAR  NO-UNDO.

   DEF VAR h_templ   AS HANDLE      NO-UNDO. 
   DEF VAR vAcct     AS CHARACTER   NO-UNDO. /* Счет */
   DEF VAR vCurrency AS CHARACTER   NO-UNDO. /* Валюта */
   DEF VAR vKau      AS CHARACTER   NO-UNDO. /* Субостаток */
   DEF VAR vBegDate  AS DATE        NO-UNDO. /* Дата начала */
   DEF VAR vEndDate  AS DATE        NO-UNDO. /* Дата окончания */
   DEF VAR vResult   AS DECIMAL     NO-UNDO. /* Результат */
   DEF VAR vLocalPV  AS CHARACTER   NO-UNDO.
   DEF VAR vFlErr    AS INT64     NO-UNDO. /* Флаг ошибки */
   DEF VAR iKauCode AS CHAR NO-UNDO.

    vLocalPV = "0".
    vResult = 0.

   MAIN:
   DO ON ERROR  UNDO, LEAVE
      ON ENDKEY UNDO, LEAVE: 
     
      IF param-count NE 2 THEN 
      DO:
         RUN Fill-SysMes ("", "", "-1", "Ошибочное количество параметров передано в функцию 'НЧПрогресс'.").
         UNDO MAIN, LEAVE MAIN.
      END.

      RUN DPS_VALID_HANDLE (INPUT-OUTPUT h_templ).   
      IF NOT VALID-HANDLE(h_templ) THEN 
         UNDO MAIN, LEAVE MAIN.
      FIND FIRST loan WHERE loan.contract  EQ "dps"
                        AND loan.cont-code EQ ENTRY(1, SUBSTRING(h_templ:PRIVATE-DATA, 6))
         NO-LOCK NO-ERROR.      
      IF NOT AVAIL loan THEN 
         UNDO MAIN, LEAVE MAIN.

      /*FIND FIRST wop WHERE RECID(wop) EQ rid 
         NO-LOCK NO-ERROR.
      IF NOT AVAIL wop THEN 
         UNDO MAIN, LEAVE MAIN.*/

      ASSIGN
         /*vAcct       = GetParam (1, param-str)         
         vKau        = GetParam (3, param-str)*/
         vBegDate    = DATE(GetParam (1, param-str))
         vEndDate    = DATE(GetParam (2, param-str))
         /*vCurrency   = STRING(GetParam(2, param-str), "999")*/.
         .  

    iKauCode = loan.contract + ',' + loan.cont-code + ',начпр'.
    FOR EACH kau-entry
     WHERE /*kau-entry.acct = acct.acct AND
                kau-entry.currency = iCurrency AND*/
                kau-entry.kau = iKauCode AND
                kau-entry.kau-id = 'loan-dps-int' AND
                kau-entry.debit /*AND
                kau-entry.op-date >= vBegDate - iPlanDelay AND
                kau-entry.op-date <= vEndDate + iPlanDelay*/,
                FIRST op OF kau-entry NO-LOCK:
        FIND FIRST op-entry OF op
            	      WHERE op-entry.op-entry EQ kau-entry.op-entry
            	      NO-LOCK.
        /*выбрасываем из диапазона, что по плановым датам не попало в период*/
        IF op.contract-date > vEndDate OR
                       op.contract-date < vBegDate
        THEN NEXT.
        /* считаем только возврат процентов */
        IF CAN-DO ( "70606*,70601........172*", op-entry.acct-cr) OR
           CAN-DO ( "70606*,70601........172*", op.ben-acct)
        THEN vResult = vResult + IF loan.currency EQ "" 
                                             THEN kau-entry.amt-rub
                                             ELSE kau-entry.amt-cur.
    END.

    /* еще надо отнять возвращенные проценты с 423* счета */
    iKauCode = loan.contract + ',' + loan.cont-code + ','.
    FOR EACH kau-entry
     WHERE      kau-entry.kau begins iKauCode AND
                kau-entry.kau-id = 'loan-dps-t' AND
                kau-entry.debit,
                FIRST op OF kau-entry NO-LOCK:
        FIND FIRST op-entry OF op
            	      WHERE op-entry.op-entry EQ kau-entry.op-entry
            	      NO-LOCK.
        /*выбрасываем из диапазона, что по плановым датам не попало в период*/
        IF op.contract-date > vEndDate OR
           op.contract-date < vBegDate
        THEN NEXT.
        IF CAN-DO ( "70606*,70601........172*", op-entry.acct-cr) OR
           CAN-DO ( "70606*,70601........172*", op.ben-acct) THEN DO:
            /* возврат процентов */
    	    vResult = vResult + IF loan.currency EQ "" 
                                              THEN kau-entry.amt-rub
                                              ELSE kau-entry.amt-cur.
        END.
    END.

    vLocalPV = STRING(vResult).
   END.
   pick-value = vLocalPV.
END PROCEDURE.
