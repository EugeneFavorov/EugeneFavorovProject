/*
               Банковская интегрированная система БИСквит
    Copyright: (C) 1992-2014 ЗАО "Банковские информационные системы"
     Filename: PP-PACK.P
      Comment: Библиотека работы сообщениями экспорта-импорта
   Parameters: НЕТ
         Uses:
      Used BY:
      Created: 01.02.2004 NIK
     Modified: Многократно....
     Modified: 07.10.2005 NIK "Переоформление" рейсов экспорта
     Modified: 10.11.2005 NIK Реструктуризация процедур формирования сообщений
                              и текстов сообщений.
                              Создана процедура PacketObjectCreate, которая
                              вызывается в PacketXMLCreate и PacketPOSCreate
     Modified: 17.11.2005 NIK 1. Заранее определяется индексированность
                                 допреквизитов
                              2. В ряде мест исключено использование
                                 GetBaseProcedure
                              3. В процедуре PacketObjectCreate делается попытка
                                 получить формат обмена из Instance
     Modified: 06.04.2006 NIK Управление направлением в PacketObjectCreate
     Modified: 16.05.2006 NIK Доработка матчинга
     Modified: 16.05.2006 NIK Реструктуризация на
                              pp-rfrnc.p
                              pp-epack.p
     Modified: 23.07.2007 16:32 OZMI     (0077065)


     Список процедур:

I. Создание текста сообщения.
   Приммечание: Размер итогового сообщения не ограничен, ограничен только
                размер буфера, передаваемого процедуре PacketTextKeep

   PacketTextClear - удаляет все записи PacketText, связанные с заданным Packet
   PacketTextKeep  - накапливает текущее содержание сообщения в буфере
   PacketTextSave  - сохраняет накопленный буфер в базе данных

      Пример использования:

   RUN PacketTextClear(PacketID).
   FOR EACH ....
      RUN PacketTextKeep(PacketID, ... ).
   END.
   RUN PacketTextSave(PacketID, .... ).

II.Чтение текста сообщения.
   ПРИМЕЧАНИЕ: Предназначены для получения сохраненного текста сообщения
               построчно с максимально быстрой скоростью.
               Вызов данной последовательности нереентерабелен, то есть нельзя
               читать одновременно несколько сообщений

   PacketReadOpen    - открывает сеанс чтения одного сообщения
   PacketReadClose   - закрывает сеанс чтения одного сообщения
   PacketReadLine    - возвращает очередную строку сообщения
   PacketTextPrint   - сохраняет сообщения в указанном файле

      Пример использования:

   PacketReadOpen(PacketID).
   REPEAT:
      IF NOT PacketReadLine(PacketID, ... ) THEN LEAVE.
   END.
   PacketReadClose(PacketID, .... ).


III. Прочее

   PacketEnableExhange - контроль возможности обмена

*/
{globals.i}

{form.def}
{g-trans.equ}
{exchange.equ}

DEFINE STREAM sPacket.

DEFINE VAR mPckOpKindInd   AS LOGICAL  NO-UNDO.
DEFINE VAR mPckStSELFInd   AS LOGICAL  NO-UNDO.
DEFINE VAR mPackCopyCr     AS LOGICAL  NO-UNDO.

DEFINE TEMP-TABLE ttPackRead NO-UNDO
            FIELD PacketID AS INTEGER
            FIELD Order    AS INTEGER
            FIELD Line     AS INTEGER
            FIELD LineCnt  AS INT64
            FIELD Data     AS CHAR
            INDEX Packet   PacketID
.

{pack.def}

{intrface.get strng}
{intrface.get xclass}

{intrface.get data}
{intrface.get db2l}
{intrface.get tmess}
{intrface.get pbase}
{intrface.get trans}

{intrface.get filex}
{intrface.get rule}
{intrface.get exch}
{intrface.get rights}
{intrface.get xpos}

{pfuncdef
   &DefLib="pack" 
   &Description="Библиотека работы с сообщениями (Packet)" }
   


mPackCopyCr = FGetSetting("УФЭБС","СоздДубль","ДА") EQ "ДА".
 

{pack-cmn.fun}                                   /* Общие функции             */
{pack-txt.pro}                                   /* Тексты сообщений          */
{pack-snc.pro}                                   /* Сеансы обмена             */

mPckOpKindInd = isXAttrIndexed("Packet","op-kind").
mPckStSELFInd = isXAttrIndexed("Packet","StateSELF").
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketCreate:
   DEFINE INPUT  PARAMETER iSeanceID      AS INT64  NO-UNDO.
   DEFINE INPUT  PARAMETER iAbonentID     AS INT64  NO-UNDO.
   DEFINE INPUT  PARAMETER iMailUserID    AS INT64  NO-UNDO.
   DEFINE INPUT  PARAMETER iKind          AS CHAR     NO-UNDO.
   DEFINE OUTPUT PARAMETER oPacketID      AS INT64  NO-UNDO.

   DEFINE VAR vFlagSet     AS LOGICAL  INIT ?   NO-UNDO.
   DEFINE VAR vCode        AS CHAR              NO-UNDO.
   DEFINE VAR vClassCode   AS CHAR              NO-UNDO.
   DEFINE VAR vOpKind      AS CHAR              NO-UNDO.
   DEFINE VAR vUpKind      AS CHAR              NO-UNDO.

   DEFINE BUFFER mail-user FOR mail-user.
   DEFINE BUFFER Packet    FOR Packet.

   &SCOP NO-BASE-PROC  YES

   {profile F01}

   &IF DEFINED(IS-DEBUG) &THEN
   RUN dbgprint.p ("PacketCreate","iSeanceID:" + string(iSeanceID)).
   &ENDIF

MAIN:
   DO TRANSACTION ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      DISABLE triggers FOR load OF Signs.

      FIND FIRST mail-user WHERE
                 mail-user.mail-user-num EQ iMailUserID
                 NO-LOCK NO-ERROR.
      IF NOT AVAILABLE(mail-user) THEN UNDO MAIN, RETRY MAIN.
      vCode = TRNSettingValue ("", "CodeExchMsg", "EXCH-MSG").
      vClassCode = GetCodeMisc(vCode,
                               mail-user.mail-format,
                               {&SWFT-PCLASS}).

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("PacketCreate","mail-format:" + GetNullStr(mail-user.mail-format) +
                                      " ClassCode:" + GetNullStr(vClassCode)).
      &ENDIF

      IF NOT {assigned vClassCode} THEN DO:
         RUN Fill-SysMes("","","","%s=" + GetNullStr(mail-user.mail-format) +
                                  "%s=" + GetNullInt(iMailUserID)).
         UNDO MAIN, RETRY MAIN.
      END.
                                                 /* Создаем Сообщение         */
      {pack-crt.i  &Packet     = Packet
                   &PacketID   = oPacketID
                   &SeanceID   = iSeanceID
                   &AbonentID  = iAbonentID
                   &MailUserID = mail-user.mail-user-num
                   &State      = "{&STATE-CRT}"
                   &Kind       = iKind
                   &Format     = mail-user.mail-format
                   &ClassCode  = vClassCode
                   &ParentID   = 0
      }

      ASSIGN
         vOpKind = GetBaseOpKind()
         vUpKind = GetCallOpkind(0,"")
      .
      IF {assigned vOpKind} AND
         {assigned vUpKind} AND
         vOpKind NE vUpKind THEN
         IF NOT UpdateSigns("Packet",
                            string(oPacketID),
                            "op-kind",
                            vOpKind,
                            mPckOpKindInd) THEN
            UNDO MAIN, RETRY MAIN.

      vFlagSet = YES.
   END.

   {profile F02}
   {doreturn.i vFlagSet}
   &undefine NO-BASE-PROC
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketCreateF:
   DEFINE INPUT  PARAMETER iSeanceID   AS INT64  NO-UNDO.
   DEFINE PARAMETER BUFFER bCode       FOR Code.
   DEFINE OUTPUT PARAMETER oPacketID   AS INT64  NO-UNDO.

   DEFINE VAR vFlagSet     AS LOGICAL  INIT ?   NO-UNDO.
   DEFINE VAR vClassCode   AS CHAR              NO-UNDO.
   DEFINE VAR vOpKind      AS CHAR              NO-UNDO.
   DEFINE VAR vUpKind      AS CHAR              NO-UNDO.

   DEFINE BUFFER mail-user FOR mail-user.
   DEFINE BUFFER Packet    FOR Packet.

   &SCOP NO-BASE-PROC  YES

   {profile F01}

   &IF DEFINED(IS-DEBUG) &THEN
   RUN dbgprint.p ("PacketCreateF","iSeanceID:" + string(iSeanceID)).
   &ENDIF

   DISABLE triggers FOR load OF Signs.

MAIN:
   DO TRANSACTION ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      FIND FIRST Seance WHERE
                 Seance.SeanceID EQ iSeanceID
                 NO-LOCK NO-ERROR. {&ON-ERROR}

      GetEXCHRule (INPUT  iSeanceID,
                   INPUT  Seance.Direct,
                   INPUT  chr(1) + bCode.Code,
                   BUFFER mail-user).

      IF NOT AVAILABLE(mail-user) THEN DO:
         RUN Fill-SysMes("","ComnExc79","","%s=" + GetNullStr(Seance.op-kind) +
                                           "%s=" + GetNullStr(Seance.Direct)  +
                                           "%s=" + GetNullStr(bCode.Code)).
         UNDO MAIN, RETRY MAIN.
      END.

      {pack-crt.i  &Packet     = Packet
                   &PacketID   = oPacketID
                   &SeanceID   = iSeanceID
                   &AbonentID  = -1
                   &MailUserID = mail-user.mail-user-num
                   &State      = "{&STATE-CRT}"
                   &Kind       = "bCode.Misc[{&RKC-KIND}]"
                   &Format     = bCode.Code
                   &ClassCode  = "bCode.Misc[{&RKC-CLASS}]"
                   &ParentID   = 0
      }

      ASSIGN
         vOpKind = GetBaseOpKind()
         vUpKind = GetCallOpkind(0,"")
      .
      IF {assigned vOpKind} AND
         {assigned vUpKind} AND
         vOpKind NE vUpKind THEN
         IF NOT UpdateSigns("Packet",
                            string(oPacketID),
                            "op-kind",
                            vOpKind,
                            mPckOpKindInd) THEN
            UNDO MAIN, RETRY MAIN.

      vFlagSet = YES.
   END.

   {profile F02}
   {doreturn.i vFlagSet}
   &undefine NO-BASE-PROC
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketSetError:
   DEFINE INPUT  PARAMETER iPacketID    AS INT64  NO-UNDO.
   DEFINE INPUT  PARAMETER iErrorClass  AS CHAR     NO-UNDO.
   DEFINE INPUT  PARAMETER iErrorList   AS CHAR     NO-UNDO.
   DEFINE OUTPUT PARAMETER oState       AS CHAR     NO-UNDO.

   DEFINE BUFFER Packet FOR Packet.
   DEFINE VAR vFlagSet  AS LOGICAL INIT ? NO-UNDO.
   DEFINE VAR vWarning  AS CHAR           NO-UNDO.
   DEFINE VAR vError    AS CHAR           NO-UNDO.

   &SCOP NO-BASE-PROC  YES

   {profile F03}
MAIN:
   DO TRANSACTION ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("PacketSetError","iPacketID:" + string(iPacketID)       +
                                    " iErrorClass:" + GetNullStr(iErrorClass) +
                                    " iErrorList :" + GetNullStr(iErrorList )).
      &ENDIF

      FIND FIRST Packet WHERE
                 Packet.PacketID EQ iPacketID
                 EXCLUSIVE-LOCK no-wait NO-ERROR.
      IF NOT AVAILABLE(Packet) THEN DO:
         RUN Fill-SysMes("","ComnExc14","","%i=" + string(iPacketID)).
         UNDO MAIN, RETRY MAIN.
      END.

      RUN CheckErrorInst (INPUT  iErrorClass,
                          INPUT  iErrorList,
                          OUTPUT vWarning,
                          OUTPUT vError).

      ASSIGN
         Packet.ClassError = iErrorClass
         Packet.PackError  = TRIM(vError + "," + vWarning,",")
         Packet.State      = {&STATE-ERR} WHEN {assigned vError}
      NO-ERROR. {&ON-ERROR}

      oState   = Packet.State.
      vFlagSet = YES.
   END.
   {profile F04}
   {doreturn.i vFlagSet}

   &undefine NO-BASE-PROC
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketCreateLink:
   DEFINE INPUT PARAMETER iPacketID AS INT64 NO-UNDO.
   DEFINE INPUT PARAMETER iTable    AS CHAR    NO-UNDO.
   DEFINE INPUT PARAMETER iSurr     AS CHAR    NO-UNDO.
   DEFINE INPUT PARAMETER iRole     AS CHAR    NO-UNDO.

   DEFINE BUFFER Packet FOR Packet.
   DEFINE VAR vFlagSet AS LOGICAL INIT ? NO-UNDO.

   &SCOP NO-BASE-PROC  YES

   {profile F05}
MAIN:
   DO TRANSACTION ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      FIND FIRST Packet WHERE Packet.PacketID EQ iPacketID NO-LOCK NO-ERROR.
      IF NOT AVAILABLE(Packet) THEN UNDO MAIN, RETRY MAIN.

      RUN PacketCreateLink2 (iPacketID,
                             Packet.SeanceID,
                             iTable,
                             iSurr,
                             iRole).
      vFlagSet = YES.
   END.
   {profile F06}
   {doreturn.i vFlagSet}
   &undefine NO-BASE-PROC
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketCreateLink2:
   DEFINE INPUT PARAMETER iPacketID AS INT64 NO-UNDO.
   DEFINE INPUT PARAMETER iSeanceID AS INT64 NO-UNDO.
   DEFINE INPUT PARAMETER iTable    AS CHAR    NO-UNDO.
   DEFINE INPUT PARAMETER iSurr     AS CHAR    NO-UNDO.
   DEFINE INPUT PARAMETER iRole     AS CHAR    NO-UNDO.

   DEFINE BUFFER PackObject   FOR PackObject.
   DEFINE VAR vFlagSet AS LOGICAL INIT ? NO-UNDO.

   &SCOP NO-BASE-PROC  YES

   {profile F05}
MAIN:
   DO TRANSACTION ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      DISABLE triggers FOR load OF PackObject.

      CREATE PackObject.
      ASSIGN PackObject.PackObjectID = next-value(pack-id)
             PackObject.PacketID     = iPacketID
             PackObject.SeanceID     = iSeanceID
             PackObject.File-Name    = iTable
             PackObject.Surrogate    = iSurr
             PackObject.Kind         = iRole
      NO-ERROR.
      IF ERROR-STATUS:ERROR THEN UNDO MAIN, RETRY MAIN.

      vFlagSet = YES.
   END.
   {profile F06}
   {doreturn.i vFlagSet}
   &undefine NO-BASE-PROC
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketSetState:
   DEFINE INPUT PARAMETER iPacketID AS INT64 NO-UNDO.
   DEFINE INPUT PARAMETER iState    AS CHAR    NO-UNDO.

   DEFINE BUFFER Packet    FOR Packet.
   DEFINE BUFFER FileExch  FOR FileExch.
   DEFINE VAR    vFlagSet  AS LOGICAL NO-UNDO.

   &SCOP NO-BASE-PROC  YES

   {profile F07}

MAIN:
   DO TRANSACTION ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      FIND FIRST Packet WHERE Packet.PacketID EQ iPacketID
                 EXCLUSIVE-LOCK no-wait NO-ERROR.
      IF NOT AVAILABLE(Packet) THEN
         UNDO MAIN, RETRY MAIN.
      ELSE
         ASSIGN Packet.State = iState.

      vFlagSet = YES.
   END.

   {profile F08}
   {doreturn.i vFlagSet}
   &undefine NO-BASE-PROC
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*    Проверяет возможность обмена                                            */
/*                                                                            */
/*    Управляюще параметры:                                                   */
/* iRoleDis - список запрещающих ролей для связанных объектов                 */
/* iRoleEnb - список разрешающих ролей для связанных объектов, при наличии    */
/*            сообщений с запрещающими ролями                                 */
/*----------------------------------------------------------------------------*/
FUNCTION PacketEnableExhange LOGICAL (INPUT iTableName  AS CHAR,
                                      INPUT iSurrogate  AS CHAR,
                                      INPUT iRoleDis    AS CHAR,
                                      INPUT iRoleEnb    AS CHAR,
                                      INPUT iSeanceID   AS INT64):

   DEFINE VAR vEnable   AS LOGICAL  INIT YES NO-UNDO.
   DEFINE VAR vNothing  AS INT64           NO-UNDO.

   {profile F13}
   &IF DEFINED(IS-DEBUG) &THEN
   RUN dbgprint.p ("PacketEnableExhange","iRoleDis:" + GetNullStr(iRoleDis) +
                                        " iRoleEnb:" + GetNullStr(iRoleEnb)).
   &ENDIF

   IF NOT {assigned iRoleDis} AND
      NOT {assigned iRoleEnb} THEN RETURN vEnable.

   IF LOOKUP({&NOTHING},iRoleDis) NE 0 THEN ASSIGN
      iRoleDis = TRIM(replace(iRoleDis,{&NOTHING},""),",")
      vNothing = 1
   .
   ELSE
      vNothing = 0.

   FOR EACH PackObject WHERE
            PackObject.file-name EQ iTableName
        AND PackObject.surrogate EQ iSurrogate
            NO-LOCK,
      FIRST Packet WHERE
            Packet.PacketID EQ PackObject.PacketID
            NO-LOCK
      break BY PackObject.PacketID:              /* По порядку создания       */

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("PacketEnableExhange","PackObject.file-name:" + PackObject.file-name +
                                           " PackObject.surrogate:" + PackObject.surrogate +
                                                " PackObject.Kind:" + PackObject.Kind      +
                                                   " Packet.State:" + Packet.State).
      &ENDIF
      IF Packet.State    EQ {&STATE-ERR}      THEN NEXT.   /* Ошибка          */
      IF Packet.State    EQ {&STATE-CNC}      THEN NEXT.   /* Отменен         */
      IF iSeanceID       NE 0                 AND
         Packet.State    EQ {&STATE-RMT}      AND
         Packet.SeanceID EQ iSeanceID         THEN NEXT.   /* Переформирование*/
      IF NOT CAN-DO(iRoleDis,PackObject.Kind) AND
         NOT CAN-DO(iRoleEnb,PackObject.Kind) THEN NEXT.   /* Другие роли     */

      vNothing = vNothing - 1.
      IF CAN-DO(iRoleDis,PackObject.Kind) THEN
         vEnable = NO.

      IF LAST(PackObject.PacketID) AND
         vEnable             EQ NO THEN
         vEnable = CAN-DO(iRoleEnb,PackObject.Kind).
   END.

   &IF DEFINED(IS-DEBUG) &THEN
   RUN dbgprint.p ("PacketEnableExhange","vEnable:" + string(vEnable) +
                                       " vNothing:" + string(vNothing) +
                                         " RETURN:" + string(IF vNothing LE 0
                                                                THEN vEnable
                                                                ELSE NO)).
   &ENDIF
   {profile F14}

   RETURN IF vNothing LE 0 THEN vEnable
                           ELSE NO.
END FUNCTION.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketInclude:
   DEFINE INPUT PARAMETER iOnePacketID AS INT64 NO-UNDO.
   DEFINE INPUT PARAMETER iAllPacketID AS INT64 NO-UNDO.
   DEFINE INPUT PARAMETER iState       AS CHAR    NO-UNDO.

   DEFINE VAR vFlagSet  AS LOGICAL INIT ? NO-UNDO.
   DEFINE VAR vRetryErr AS CHAR           NO-UNDO.
   DEFINE BUFFER bigPacket FOR Packet.
   DEFINE BUFFER onePacket FOR Packet.

   &SCOP RETRY-ERROR    vRetryErr
   &SCOP NO-BASE-PROC   YES

   DISABLE triggers FOR Load OF Packet.
   DISABLE triggers FOR Load OF Signs.

MAIN:
   DO TRANSACTION ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}
      FIND FIRST onePacket WHERE
                 onePacket.PacketID EQ iOnePacketID
                 EXCLUSIVE-LOCK no-wait NO-ERROR.
      IF locked(onePacket) THEN DO:
         vRetryErr = "Запись с идентификатором " + string(iOnePacketID) +
                     " заблокирована другим пользователем.".
         UNDO MAIN, RETRY MAIN.
      END.
      IF NOT AVAILABLE(onePacket) THEN UNDO MAIN, RETRY MAIN.

      FIND FIRST bigPacket WHERE
                 bigPacket.PacketID EQ iAllPacketID
                 NO-LOCK NO-ERROR. {&ON-ERROR}
      IF bigPacket.SeanceID NE onePacket.SeanceID THEN DO:
         IF NOT UpdateSigns("Packet",
                            string(iOnePacketID),
                            "StateSELF",
                            Packet.State,
                            mPckStSELFInd) THEN
            UNDO MAIN, RETRY MAIN.
      END.

      ASSIGN
         onePacket.ParentID = iAllPacketID
         onePacket.State    = iState WHEN onePacket.State NE {&STATE-ERR}
      NO-ERROR. {&ON-ERROR}

      RELEASE Packet.
      vFlagSet = YES.
   END.

   {doreturn.i vFlagSet vRetryErr}
   &undefine RETRY-ERROR
   &undefine NO-BASE-PROC
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketMatch:
   DEFINE INPUT PARAMETER iPacketID AS INT64  NO-UNDO.
   DEFINE INPUT PARAMETER iSeanceID AS INT64  NO-UNDO.
   DEFINE INPUT PARAMETER iTable    AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iRole     AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER hObjQuery AS handle   NO-UNDO.

   DEFINE VAR hObjBuff  AS handle            NO-UNDO.
   DEFINE VAR vFlagSet  AS LOGICAL INIT ?    NO-UNDO.
   DEFINE VAR vCount    AS INT64           NO-UNDO.
   DEFINE VAR vFields   AS CHAR              NO-UNDO.
   DEFINE VAR vSurr     AS CHAR              NO-UNDO.
   DEFINE VAR vPrepare  AS CHAR              NO-UNDO.
   DEFINE VAR vState    AS CHAR              NO-UNDO.

   &SCOP NO-BASE-PROC   YES

MAIN:
   DO TRANSACTION ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      RUN QueryGetBuffer(INPUT  hObjQuery,
                         INPUT  iTable,
                         OUTPUT hObjBuff).
      IF NOT valid-handle(hObjBuff) THEN UNDO MAIN, RETRY MAIN.

      ASSIGN
         vPrepare = hObjQuery:prepare-string
         vFields  = GetTableSurrogate(iTable)
      .

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("PacketMatch","PacketID:" + string(iPacketID)   +
                                     " iTable:" + GetNullStr(iTable)  +
                                    " vFields:" + GetNullStr(vFields) +
                                   " vPrepare:" + vPrepare).
      &ENDIF

/*----------------------------------------- Удаление ранее созданных связей --*/
      FOR EACH PackObject WHERE
               PackObject.PacketID EQ iPacketID
               EXCLUSIVE-LOCK:
         &IF DEFINED(IS-DEBUG) &THEN
         RUN dbgprint.p ("PacketMatch","Delete Link:" + PackObject.File-Name +
                                                  ":" + PackObject.Surrogate).
         &ENDIF
         DELETE PackObject.
      END.

/*-------------------------------------------- Перебор найденных совпадений --*/
      hObjQuery:get-first() NO-ERROR.
OBJ:
      DO WHILE NOT hObjQuery:QUERY-OFF-END
         ON ERROR UNDO OBJ, RETRY OBJ:
         IF RETRY THEN UNDO MAIN, RETRY MAIN.

         vSurr  = GetObjectSurrogate(hObjBuff,vFields).

         &IF DEFINED(IS-DEBUG) &THEN
         RUN dbgprint.p ("PacketMatch","vSurr:" + GetNullStr(vSurr)).
         &ENDIF

/*--------------------------------------------- Контроль повторной привязки --*/
         IF CAN-FIND(FIRST PackObject WHERE
                           PackObject.PacketID  EQ iPacketID
                       AND PackObject.SeanceID  EQ iSeanceID
                       AND PackObject.File-Name EQ iTable
                       AND PackObject.Surrogate EQ vSurr) THEN DO:
            &IF DEFINED(IS-DEBUG) &THEN
            RUN dbgprint.p ("PacketMatch","Repeat link. vSurr:" + GetNullStr(vSurr)).
            &ENDIF   
            RUN Fill-SysMes("","FXExch45","",
                            "%s=" + GetNullInt(iPacketID) +
                            "%s=" + GetNullStr(iTable)    +
                            "%s=" + GetNullStr(vSurr)).
            hObjQuery:get-next().
            NEXT OBJ.
         END.

         vCount = vCount + 1.
         IF vCount GE 10 THEN LEAVE OBJ.

/*------------------------- Выполнение привязки и сохранение условия отбора --*/
         RUN PacketCreateLink2 (iPacketID,
                                iSeanceID,
                                iTable,
                                vSurr,
                                iRole).
         FOR FIRST PackObject WHERE
                   PackObject.File-Name EQ iTable
               AND PackObject.Surrogate EQ vSurr
               AND PackObject.PacketID  EQ iPacketID
                   NO-LOCK:
            UpdateSigns("PackObject",
                        string(PackObject.PackObjectID),
                        "Details",
                        vPrepare,
                        NO).
         END.
         hObjQuery:get-next().
      END.

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("PacketMatch","vCount:" + GetNullInt(vCount)).
      &ENDIF

      IF      vCount EQ 0  THEN vState = {&STATE-IMP}.
      ELSE IF vCount EQ 1  THEN vState = {&STATE-MTH}.
      ELSE IF vCount LE 10 THEN vState = {&STATE-DUB}.
      ELSE                      vState = {&STATE-IMP}.

      RUN PacketSetState (iPacketID, vState).

      vFlagSet = YES.
   END.

   {doreturn.i vFlagSet}
   &undefine NO-BASE-PROC

END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketDeleteByState:
   DEFINE INPUT PARAMETER iSeanceID AS INT64  NO-UNDO.
   DEFINE INPUT PARAMETER iState    AS CHAR     NO-UNDO.

   DEFINE VAR vFlagSet AS LOGICAL INIT ? NO-UNDO.

MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}
      FOR EACH Packet WHERE
               Packet.SeanceID EQ iSeanceID
           AND CAN-DO(iState,Packet.State)
                  EXCLUSIVE-LOCK:
         DELETE Packet.
      END.
      vFlagSet = YES.
   END.

   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketPreCreate:
   DEFINE INPUT PARAMETER iMailUserNum AS INT64 NO-UNDO.
   DEFINE INPUT PARAMETER iSeanceID    AS INT64 NO-UNDO.
   DEFINE INPUT PARAMETER iFileExchID  AS INT64 NO-UNDO.
   DEFINE INPUT PARAMETER iClassCode   AS CHAR    NO-UNDO.

   DEFINE VAR vFlagSet AS LOGICAL INIT ?  NO-UNDO.
   DEFINE VAR vKind    AS CHAR    INIT "" NO-UNDO.

MAIN:
   DO TRANSACTION ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      FOR FIRST mail-user WHERE
                mail-user.mail-user-num EQ iMailUserNum
                NO-LOCK:
         vKind = GetCodeMisc("EXCH-MSG",mail-user.mail-format,1).
      END.

      CREATE Packet.
      ASSIGN Packet.PacketID      = next-value(pack-id)
             Packet.PackDate      = today
             Packet.Class-Code    = (IF {assigned iClassCode}
                                        THEN iClassCode
                                        ELSE "Packet")
             Packet.Mail-User-Num = iMailUserNum
             Packet.mail-format   = mail-user.mail-format
             Packet.Kind          = vKind
             Packet.SeanceID      = iSeanceID
             Packet.FileExchID    = iFileExchID
             Packet.State         = {&STATE-FND}
             Packet.AbonentID     = -1
             Packet.Filial-ID     = shFilial
             Packet.PackDate      = today
             Packet.PackTime      = time
             Packet.User-id       = USERID("bisquit")
      NO-ERROR.

      vFlagSet = YES.
   END.

   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketImportModify:
   DEFINE INPUT  PARAMETER iPacketID      AS INT64           NO-UNDO.
   DEFINE INPUT  PARAMETER iState         AS CHAR              NO-UNDO.
   DEFINE INPUT  PARAMETER iTableName     AS CHAR              NO-UNDO.
   DEFINE INPUT  PARAMETER iSurrogate     AS CHAR              NO-UNDO.
   DEFINE INPUT  PARAMETER iRole          AS CHAR              NO-UNDO.
   DEFINE INPUT  PARAMETER iAbonentID     AS INT64           NO-UNDO.

   DEFINE BUFFER Packet       FOR Packet.
   DEFINE BUFFER PackObject   FOR PackObject.

   DEFINE VAR vError    AS CHAR     INIT ""  NO-UNDO.
   DEFINE VAR vFlagSet  AS LOGICAL  INIT ?   NO-UNDO.

MAIN:
   DO TRANSACTION ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      IF iAbonentID                           NE -1          AND
         NOT CAN-FIND(FIRST Abonent WHERE
                            Abonent.AbonentID EQ iAbonentID) THEN DO:
         RUN Fill-SysMes("","ComnExc02","","%i=" + string(iAbonentID)).
         UNDO MAIN, RETRY MAIN.
      END.
/*
      IF NOT CheckPacketExist (iPacketID) THEN UNDO MAIN, RETRY MAIN.
*/
      FIND FIRST Packet WHERE
                 Packet.PacketID EQ iPacketID
                 EXCLUSIVE-LOCK NO-ERROR.

      IF NOT AVAILABLE(Packet) THEN DO:
         RUN Fill-SysMes("","ComnExc04","","%i=" + string(iPacketID)).
         UNDO MAIN, RETRY MAIN.
      END.

      ASSIGN Packet.AbonentID  = iAbonentID WHEN iAbonentID NE -1
             Packet.State      = iState
      NO-ERROR.

      IF ERROR-STATUS:ERROR THEN UNDO MAIN, RETRY MAIN.

      IF {assigned iSurrogate} AND
         {assigned iTableName} THEN DO:
         CREATE PackObject.
         ASSIGN PackObject.PacketID  = Packet.PacketID
                PackObject.SeanceID  = Packet.SeanceID
                PackObject.File-Name = iTableName
                PackObject.Surrogate = replace(iSurrogate,";",",")
                PackObject.Kind      = iRole
         NO-ERROR.
         IF ERROR-STATUS:ERROR THEN UNDO MAIN, RETRY MAIN.
      END.

      vFlagSet = YES.
   END.

   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Создает запрос для выборки сообщений                                       */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketCreateQuery:
   DEFINE INPUT  PARAMETER hPacket  AS handle   NO-UNDO.
   DEFINE INPUT  PARAMETER iRequest AS INT64  NO-UNDO.
   DEFINE INPUT  PARAMETER pQuery   AS HANDLE   NO-UNDO.

   DEFINE VAR vFlagSet     AS LOGICAL  INIT ?   NO-UNDO.
   DEFINE VAR vOK          AS LOGICAL           NO-UNDO.

   DEFINE VAR vWhere    AS CHAR     NO-UNDO.
   DEFINE VAR vOpKind   AS CHAR     NO-UNDO.
   DEFINE VAR vTmplID   AS INT64  NO-UNDO.
   DEFINE VAR vFilter   AS CHAR     NO-UNDO.
   DEFINE VAR hFilter   AS handle   NO-UNDO.

   DEFINE VARIABLE vBufs    AS HANDLE EXTENT 10  NO-UNDO.
   DEFINE VARIABLE vBuffers AS CHARACTER         NO-UNDO.
   DEFINE VARIABLE vI       AS INT64           NO-UNDO.

/*============================================================================*/
MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      IF NOT valid-handle(pQuery) THEN UNDO MAIN, RETRY MAIN.

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("PacketCreateQuery","iRequest:" + string(iRequest)).
      &ENDIF

      CASE iRequest:
         WHEN {&REQ-SNC} OR
         WHEN {&REQ-PCK} THEN DO:
            vWhere = PacketCreateWhere(hPacket, iRequest).
            pQuery:add-buffer((BUFFER Packet:handle)).
         END.
         WHEN {&REQ-CMP} THEN DO:
            vWhere = PacketCreateWhere(hPacket, iRequest).
            pQuery:add-buffer((BUFFER Seance:handle)).
            pQuery:add-buffer((BUFFER Packet:handle)).
         END.
         WHEN {&REQ-FLT} THEN DO:
            ASSIGN
               vOpKind = GetBaseOpKind()
               vTmplID = GetBaseTemplate()
               vFilter = GetAttrValue2(vOpKind, vTmplID, "$FilterTable")
            NO-ERROR.
            IF ERROR-STATUS:ERROR THEN UNDO MAIN, RETRY MAIN.

            ASSIGN
               hFilter = widget-handle(vFilter)
            NO-ERROR.
            IF ERROR-STATUS:ERROR THEN UNDO MAIN, RETRY MAIN.

            pQuery:add-buffer(hFilter:default-buffer-handle).
            pQuery:add-buffer((BUFFER Packet:handle)).

            vWhere = "for EACH "                    + hFilter:Name +  ","        +
                       " FIRST Packet WHERE "                                    +
                             " Packet.PacketID EQ " + hFilter:Name + ".PacketID" +
                             " no-lock".
         END.
         WHEN {&REQ-USR} THEN
         DO:
            DO vI = 1 TO 10:
               IF VALID-HANDLE(vBufs[vI]) THEN 
                  DELETE OBJECT vBufs[vI] NO-ERROR.
            END.
            ASSIGN
               vOpKind  = GetBaseOpKind()
               vTmplID  = GetBaseTemplate()
               vWhere   = GetAttrValue2(vOpKind, vTmplID, "$Where")
               vBuffers = GetAttrValue2(vOpKind, vTmplID, "$buffers")
            NO-ERROR.
            DO vI = 1 TO NUM-ENTRIES(vBuffers):
               CREATE BUFFER vBufs[vI] FOR TABLE ENTRY(vI,vBuffers). 
               pQuery:ADD-BUFFER(vBufs[vI]).
            END.
         END.
      END CASE.

      IF NOT {assigned vWhere} THEN UNDO MAIN, RETRY MAIN.

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("PacketCreateQuery","vWhere:" + GetNullStr(vWhere)).
      &ENDIF

      ASSIGN
         vOK = pQuery:query-prepare(vWhere)
      NO-ERROR.
      IF ERROR-STATUS:ERROR OR vOK NE YES THEN UNDO MAIN, RETRY MAIN.

      vFlagSet = YES.
   END.

   &IF DEFINED(IS-DEBUG) &THEN
   RUN dbgprint.p ("PacketCreateQuery","prepare:" + GetNullStr(pQuery:prepare-string) +
                                     " vFlagSet:" + GetNullStr(string(vFlagSet))).
   &ENDIF

   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Создает строку запроса для выборки сообщений (удалить)                     */
/*----------------------------------------------------------------------------*/
PROCEDURE PacketCreateWhereTmp:
   DEFINE INPUT  PARAMETER iOpDate        AS DATE     NO-UNDO.
   DEFINE INPUT  PARAMETER iSeanceID      AS INT64  NO-UNDO.
   DEFINE INPUT  PARAMETER iTmplID        AS INT64  NO-UNDO.
   DEFINE OUTPUT PARAMETER oWhere         AS CHAR     NO-UNDO.

   DEFINE VAR hInstance AS handle            NO-UNDO.
   DEFINE VAR vFlagSet  AS LOGICAL  INIT ?   NO-UNDO.

   DEFINE VAR vOpKind      AS CHAR        NO-UNDO.
   DEFINE VAR vOpKindPre   AS CHAR        NO-UNDO.

MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      ASSIGN
         vOpKind     = GetBaseOpKind()
         vOpKindPre  = GetAttrValue2(vOpKind, iTmplID, "$OpKindPrepare")
      NO-ERROR.
      IF ERROR-STATUS:ERROR THEN UNDO MAIN, RETRY MAIN.

      IF vOpKindPre EQ {&RET-ERROR} THEN vOpKindPre = vOpKind.


      IF vOpKindPre EQ vOpKind THEN
         oWhere = "for EACH Seance where"                            +
                          " Seance.SeanceID EQ " + string(iSeanceID) +
                          " NO-LOCK".
      ELSE
         oWhere = "for EACH Seance where"                                      +
                          " Seance.Op-Kind    EQ '" + vOpKindPre        + "'"  +
                      " AND Seance.SeanceDate EQ "  + string(iOpDate)          +
                          " NO-LOCK".

      vFlagSet = YES.
   END.

   {doreturn.i vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Проверяет, была ли выгрузка по данному объекту                             */
/*----------------------------------------------------------------------------*/
FUNCTION CheckPacketObjExist RETURNS LOGICAL (INPUT iFileName AS CHARACTER,
                                              INPUT iSurr     AS CHARACTER,
                                              INPUT iKind     AS CHARACTER):
   DEFINE BUFFER PackObject FOR PackObject.

   FIND FIRST PackObject WHERE PackObject.File-Name EQ iFileName
                           AND PackObject.Surrogate EQ iSurr
                           AND PackObject.Kind      EQ iKind NO-LOCK NO-ERROR.

   IF AVAIL PackObject THEN RETURN TRUE.
   ELSE RETURN FALSE.

END FUNCTION.
/*----------------------------------------------------------------------------*/
/* Возвращает дату создания сообщения                                         */
/*----------------------------------------------------------------------------*/
FUNCTION GetPackDate RETURNS DATE (INPUT iFileName AS CHARACTER,
                                   INPUT iSurr     AS CHARACTER,
                                   INPUT iKind     AS CHARACTER):
   DEFINE BUFFER PackObject FOR PackObject.
   DEFINE BUFFER Packet     FOR Packet.

   FIND FIRST PackObject WHERE PackObject.File-Name EQ iFileName
                           AND PackObject.Surrogate EQ iSurr
                           AND PackObject.Kind      EQ iKind NO-LOCK NO-ERROR.

   IF AVAIL PackObject THEN
   DO:
      FIND FIRST Packet WHERE Packet.PacketID EQ PackObject.PacketID NO-LOCK NO-ERROR.
      IF AVAIL Packet THEN RETURN Packet.PackDate.
   END.
END FUNCTION.
/*----------------------------------------------------------------------------*/
/* Возвращает время создания сообщения                                         */
/*----------------------------------------------------------------------------*/
FUNCTION GetPackTime RETURNS INT64 (INPUT iFileName AS CHARACTER,
                                      INPUT iSurr     AS CHARACTER,
                                      INPUT iKind     AS CHARACTER):
   DEFINE BUFFER PackObject FOR PackObject.
   DEFINE BUFFER Packet     FOR Packet.

   FIND FIRST PackObject WHERE PackObject.File-Name EQ iFileName
                           AND PackObject.Surrogate EQ iSurr
                           AND PackObject.Kind      EQ iKind NO-LOCK NO-ERROR.

   IF AVAIL PackObject THEN
   DO:
      FIND FIRST Packet WHERE Packet.PacketID EQ PackObject.PacketID NO-LOCK NO-ERROR.
      IF AVAIL Packet THEN RETURN Packet.PackTime.
   END.
END FUNCTION.
/* $LINTUSER='VASOV' */
/* $LINTENV ='dpl' */
/* $LINTVSS ='$/ws3-dpl/bq' */
/* $LINTDATE='08/12/2014 11:56:36.514+04:00' */
/* $LINTFILE='pp-pack.p' */
/*prosign2J7cIR4XypVBNR+t2CZCEw*/