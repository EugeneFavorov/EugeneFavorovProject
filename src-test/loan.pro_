{intrface.get xclass}
{intrface.get date}   /*на всякий случай*/
{intrface.get db2l}
{intrface.get comm}
{intrface.get refer}
{intrface.get tmess}
{filleps.def}
&GLOB IsLoanProLoaded YES
&GLOB SESSION_DEBUG_FILE "epscalc_debug.tmp"

DEFINE TEMP-TABLE tt-pay NO-UNDO
   FIELD period     AS DATE                    /* Дата периода */
   FIELD pay        AS LOGICAL                 /* Есть ли платежи в этот период */
INDEX period pay.

DEFINE TEMP-TABLE tt-perpay NO-UNDO
   FIELD cntDays    AS INT64     /* длительность периода */
   FIELD cnt        AS Int64     /* количество периодов этой длительности */
INDEX period cntDays.

DEFINE VARIABLE mPlasStavTransh AS LOGICAL   NO-UNDO.
DEFINE STREAM vStream. /* для расчета БП ЭПС */

mPlasStavTransh = FgetSetting("ПлавСтавОхват",?,"нет") EQ "Да".

/* Расчет суммы и выбор формулы расчета аннуитетного платежа */
FUNCTION GetAnnuitet RETURN DEC (
   INPUT iSumma AS DEC,
   INPUT iRate  AS DEC,
   INPUT iQty   AS INT64,
   INPUT iDiff  AS INT64,
   INPUT iSumDep AS DEC,
   INPUT iRoundRub AS INT64):

   DEF VAR vSumm  AS DEC NO-UNDO.

   IF iSumDep EQ ? THEN
      iSumDep = 0.
   IF iDiff EQ ? THEN
      CASE FGetSetting("АннуитФорм",?,"1"):
         WHEN "1" THEN iDiff = 0.
         WHEN "2" THEN iDiff = 1.
         WHEN "3" THEN iDiff = 2.
      END CASE.

   vSumm = ROUND((iSumma - iSumDep) * (iRate / (1 - EXP(1 + iRate, iDiff + iQty))) + (iSumDep * iRate), iRoundRub).
   RETURN vSumm.
END FUNCTION.

/* Расчет 2-х сумм аннуитетного платежа */
FUNCTION GetAnnuitet1 RETURN DEC (
   INPUT iSumma AS DEC,
   INPUT iPartAmount AS DEC,
   INPUT iRate  AS DEC,
   INPUT iQty   AS INT64,
   INPUT iSumDep AS DEC,
   INPUT iRoundRub AS INT64):
   
   DEF VAR vSumma1  AS DEC NO-UNDO.
   DEF VAR vAnnSumm    AS DEC NO-UNDO.

   IF iSumDep EQ ? THEN
      iSumDep = 0.
   IF iPartAmount EQ ? THEN 
      iPartAmount = 100.

   vSumma1 = (iSumma * (100 - iPartAmount)) / 100.

   vAnnSumm = ROUND( (vSumma1 - iSumDep) * ((iRate * EXP(1 + iRate, iQty)) / (EXP(1 + iRate, iQty) - 1)) + ((iSumma - vSumma1 + iSumDep) * iRate), iRoundRub).

   RETURN vAnnSumm.
  
END FUNCTION.

/* Расчет 2-х сумм аннуитетного платежа */
FUNCTION GetAnnuitet2 RETURN DEC (
   INPUT iSumma AS DEC,
   INPUT iRate  AS DEC,
   INPUT iQty   AS INT64,
   INPUT iSumDep AS DEC,
   INPUT iRoundRub AS INT64):
   
   DEF VAR vSumma1  AS DEC NO-UNDO.
   DEF VAR vAnnSumm    AS DEC NO-UNDO.

   vAnnSumm = ROUND( (iSumma - iSumDep) * ((iRate * EXP(1 + iRate, iQty)) / (EXP(1 + iRate, iQty) - 1)) + (iSumDep * iRate), iRoundRub).
   RETURN vAnnSumm.
   
END FUNCTION.

/* Возвращает идентификатор договора по известным полям уникального индекса. */
FUNCTION GetLoanRecid RETURN RECID (
   INPUT iContract AS CHAR, /* Назначение договора. */
   INPUT iContCode AS CHAR  /* Номер договора. */
):

   DEF BUFFER loan FOR loan. /* Локализация буфера. */

   FIND FIRST loan WHERE
            loan.contract  EQ iContract
      AND   loan.cont-code EQ iContCode
   NO-LOCK NO-ERROR.

   RETURN IF AVAIL loan
          THEN RECID (loan)
          ELSE ?.

END FUNCTION.

/* Возвращает идентификатор охватывающего догвора. */
PROCEDURE GetMainLnId.
   
   DEFINE INPUT  PARAMETER ipLoanRecid AS RECID NO-UNDO. /* Идентификатор договора. */
   DEFINE OUTPUT PARAMETER opLoanRecid AS RECID NO-UNDO. /* Идентификатор течения. */

   DEFINE BUFFER loan  FOR loan. /* Локализация буфера. */
   DEFINE BUFFER mLoan FOR loan. /* Буфер для поиска течения. */

   /* Поиск текущего договора. */
   FIND FIRST loan WHERE
        RECID(loan) EQ ipLoanRecid NO-LOCK.
   /* Поиск охватывающего договора. */
   FIND FIRST mLoan WHERE
              mLoan.contract EQ loan.contract 
     AND TRIM(mloan.cont-code) EQ ENTRY(1,Loan.cont-code, " ") NO-LOCK NO-ERROR.
   /* У охватывающего договора тип должен быть "Течение". */
   IF     AVAILABLE mLoan 
      AND mLoan.cont-type EQ "Течение" THEN
      opLoanRecid = RECID (mLoan).
   
   RETURN.

END PROCEDURE.

/* Возвращает значение поля таблицы loan
** по Recid записи и наименованию поля.
** Если требуется вернуть значение interest [i],
** то входной параметр имеет следующее значение interest|i. */
FUNCTION FGetLoanField RETURN CHAR (
   INPUT ipLoanRecid AS RECID, /* Идентификатор договора. */
   INPUT ipFieldChar AS CHAR   /* Код поля. */
):

   DEF VAR vValueChar AS CHAR NO-UNDO. /* Результат поиска. */

   RUN PGetLoanField (ipLoanRecid,      /* Идентификатор договора. */
                      ipFieldChar,      /* Поле для получения. */
                      OUTPUT vValueChar /* Значение поля. */
   ).

   RETURN vValueChar.

END FUNCTION.

/* Возвращает значение поля таблицы loan
** по Recid записи и наименованию поля.
** Если требуется вернуть значение interest [i],
** то входной параметр имеет следующее значение interest|i. */
PROCEDURE PGetLoanField.

   DEF INPUT  PARAM ipLoanRecid AS RECID NO-UNDO. /* Идентификатор договора. */
   DEF INPUT  PARAM ipFieldChar AS CHAR  NO-UNDO. /* Поле для получения. */
   DEF OUTPUT PARAM opValueChar AS CHAR  NO-UNDO. /* Значение поля. */

   DEF BUFFER loan FOR loan. /* Локализация буфера. */

   DEF VAR vFrameHandle AS HANDLE NO-UNDO. /* Указатель на фрейм. */
   DEF VAR vCountInt    AS INT64    NO-UNDO. /* Индекс массива. */

   /* Поиск записи (договора). */
   FIND FIRST loan WHERE   
      RECID (loan) EQ ipLoanRecid
   NO-LOCK NO-ERROR.

   /* Выход, если договор не найден. */
   IF NOT AVAIL loan
   THEN RETURN.

   IF NUM-ENTRIES (ipFieldChar, "|") GT 1
   THEN ASSIGN
      vCountInt   = INT64(ENTRY (2, ipFieldChar, "|")) - 1
      ipFieldChar = ENTRY (1, ipFieldChar, "|")
   .

   /* Формирование фрейма. */
   FORM
      loan.close-date
      loan.cust-cat
      loan.cust-id
      loan.end-date
      loan.open-date
      loan.contract
      loan.since
      loan.l-int-date
      loan.warr-cat
      loan.warr-id
      loan.comment
      loan.risk
      loan.interest [1]
      loan.interest [2]
      loan.interest [3]
      loan.interest [4]
      loan.interest [5]
      loan.interest [6]
      loan.interest [7]
      loan.interest [8]
      loan.interest [9]
      loan.interest [10]
      loan.gr-riska
      loan.user-id
      loan.flag-acsept
      loan.nstr
      loan.loan-work
      loan.currency
      loan.cont-code FORMAT "x(25)"
      loan.cont-cli
      loan.user-o [1]
      loan.user-o [2]
      loan.user-o [3]
      loan.user-o [4]
      loan.user-o [5]
      loan.cont-type
      loan.op-kind
      loan.Class-Code
      loan.loan-status
      loan.prolong
      loan.op-template
      loan.filial-id
      loan.doc-ref
   WITH frame LoanFields.

   /* Присвоение элементам фрейма значений. */
   ASSIGN
      loan.close-date:screen-value    = string (loan.close-date, "99/99/9999")
      loan.cust-cat:screen-value      = loan.cust-cat
      loan.cust-id:screen-value       = string (loan.cust-id)
      loan.end-date:screen-value      = string (loan.end-date, "99/99/9999")
      loan.open-date:screen-value     = string (loan.open-date, "99/99/9999")
      loan.contract:screen-value      = loan.contract
      loan.since:screen-value         = string (loan.since, "99/99/9999")
      loan.l-int-date:screen-value    = string (loan.l-int-date, "99/99/9999")
      loan.warr-cat:screen-value      = loan.warr-cat
      loan.warr-id:screen-value       = string (loan.warr-id)
      loan.comment:screen-value       = loan.comment
      loan.risk:screen-value          = string (loan.risk)
      loan.interest [1]:screen-value  = string (loan.interest [1])
      loan.interest [2]:screen-value  = string (loan.interest [2])
      loan.interest [3]:screen-value  = string (loan.interest [3])
      loan.interest [4]:screen-value  = string (loan.interest [4])
      loan.interest [5]:screen-value  = string (loan.interest [5])
      loan.interest [6]:screen-value  = string (loan.interest [6])
      loan.interest [7]:screen-value  = string (loan.interest [7])
      loan.interest [8]:screen-value  = string (loan.interest [8])
      loan.interest [9]:screen-value  = string (loan.interest [9])
      loan.interest [10]:screen-value = string (loan.interest [10])
      loan.gr-riska:screen-value      = string (loan.gr-riska)
      loan.user-id:screen-value       = loan.user-id
      loan.flag-acsept:screen-value   = string (loan.flag-acsept)
      loan.nstr:screen-value          = string (loan.nstr)
      loan.loan-work:screen-value     = string (loan.loan-work)
      loan.currency:screen-value      = loan.currency
      loan.cont-code:screen-value     = loan.cont-code
      loan.cont-cli:screen-value      = loan.cont-cli
      loan.user-o [1]:screen-value    = loan.user-o [1]
      loan.user-o [2]:screen-value    = loan.user-o [2]
      loan.user-o [3]:screen-value    = loan.user-o [3]
      loan.user-o [4]:screen-value    = loan.user-o [4]
      loan.user-o [5]:screen-value    = loan.user-o [5]
      loan.cont-type:screen-value     = loan.cont-type
      loan.op-kind:screen-value       = loan.op-kind
      loan.Class-Code:screen-value    = loan.Class-Code
      loan.loan-status:screen-value   = loan.loan-status
      loan.prolong:screen-value       = string (loan.prolong)
      loan.op-template:screen-value   = string (loan.op-template)
      loan.filial-id:SCREEN-VALUE     = loan.filial-id 
      loan.doc-ref:SCREEN-VALUE       = loan.doc-ref 
   no-error.

   /* Позиционирование на группе полей. */
   ASSIGN

      vFrameHandle = FRAME LoanFields:handle
      vFrameHandle = vFrameHandle:first-child
      vFrameHandle = vFrameHandle:first-child
   .

   /* Поиск требуемого поля. */
   DO WHILE valid-handle (vFrameHandle):

      /* Проверяем поле и индекс. */
      IF vFrameHandle:name EQ ipFieldChar AND
         vCountInt         EQ 0
      THEN LEAVE.

      /* Декримент индекса и поиск следующего поля. */
      ASSIGN
         vCountInt    = vCountInt - 1
                        WHEN vFrameHandle:name EQ ipFieldChar
         vFrameHandle = vFrameHandle:next-sibling
      .
   END.

   IF valid-handle (vFrameHandle)

   /* Получение значения атрибута. */
   THEN opValueChar = vFrameHandle:screen-value.

   /* Реквизит не найден. */
   ELSE opValueChar = "Поле '" + ipFieldChar + "' не найдено.".

   RETURN.

END PROCEDURE.

/* Возвращает значение поля таблицы term-obl
   по Recid записи и наименованию поля. */

FUNCTION FGetTermOblField RETURN CHAR (
   INPUT ipTermOblRecid AS RECID, /* Идентификатор договора. */
   INPUT ipFieldChar    AS CHAR   /* Код поля. */
):

   DEF VAR vValueChar AS CHAR NO-UNDO. /* Результат поиска. */

   RUN PGetTermOblField (ipTermOblRecid,      /* Идентификатор договора. */
                         ipFieldChar,         /* Поле для получения. */
                         OUTPUT vValueChar    /* Значение поля. */
   ).

   RETURN vValueChar.

END FUNCTION.

/* Возвращает значение поля таблицы term-obl
   по Recid записи и наименованию поля. */

PROCEDURE PGetTermOblField.

      DEF INPUT  PARAM ipTermOblRecid AS RECID NO-UNDO. /* Идентификатор договора. */
      DEF INPUT  PARAM ipFieldChar AS CHAR  NO-UNDO. /* Поле для получения. */
      DEF OUTPUT PARAM vValueChar AS CHAR  NO-UNDO. /* Значение поля. */

      DEF BUFFER term-obl FOR term-obl. /* Локализация буфера. */

      DEF VAR vFrameHandle AS HANDLE NO-UNDO. /* Указатель на фрейм. */
      DEF VAR vCountInt    AS INT64    NO-UNDO. /* Индекс массива. */

      /* Поиск записи (договора). */
      FIND FIRST term-obl WHERE
         RECID(term-obl) EQ ipTermOblRecid
      NO-LOCK NO-ERROR.

      /* Выход, если договор не найден. */
      IF NOT AVAIL term-obl
      THEN RETURN.

      IF NUM-ENTRIES (ipFieldChar, "|") GT 1
         THEN ASSIGN
      vCountInt   = INT64(ENTRY (2, ipFieldChar, "|")) - 1
      ipFieldChar = ENTRY (1, ipFieldChar, "|")
      .
                
      /* Формирование фрейма */
      FORM 
         term-obl.acct
         term-obl.amt-rub
         term-obl.bal-acct-cr
         term-obl.bal-acct-db
         term-obl.cont-code
         term-obl.cont-type
         term-obl.contract
         term-obl.cor-acct
         term-obl.currency
         term-obl.end-date
         term-obl.fop
         term-obl.fop-date
         term-obl.fop-offbal
         term-obl.fuser-id
         term-obl.idnt
         term-obl.nn
         term-obl.sop
         term-obl.sop-date
         term-obl.sop-offbal
         term-obl.suser-id
         term-obl.symbol
      WITH FRAME TermFields.

      /* Присвоение элементам фрейма значений. */
   ASSIGN
         term-obl.acct:SCREEN-VALUE         = term-obl.acct
         term-obl.amt-rub:SCREEN-VALUE      = STRING (term-obl.amt-rub)
         term-obl.bal-acct-cr:SCREEN-VALUE  = STRING (term-obl.bal-acct-cr)
         term-obl.bal-acct-db:SCREEN-VALUE  = STRING (term-obl.bal-acct-db)
         term-obl.cont-code:SCREEN-VALUE    = term-obl.cont-code
         term-obl.cont-type:SCREEN-VALUE    = term-obl.cont-type
         term-obl.contract:SCREEN-VALUE     = term-obl.contract
         term-obl.cor-acct:SCREEN-VALUE     = term-obl.cor-acct
         term-obl.currency:SCREEN-VALUE     = term-obl.currency
         term-obl.end-date:SCREEN-VALUE     = STRING (term-obl.end-date, "99/99/9999")
         term-obl.fop:SCREEN-VALUE          = STRING (term-obl.fop)
         term-obl.fop-date:SCREEN-VALUE     = STRING (term-obl.fop-date, "99/99/9999")
         term-obl.fop-offbal:SCREEN-VALUE   = STRING (term-obl.fop-offbal)
         term-obl.fuser-id:SCREEN-VALUE     = term-obl.fuser-id
         term-obl.idnt:SCREEN-VALUE         = STRING (term-obl.idnt)
         term-obl.nn:SCREEN-VALUE           = STRING (term-obl.nn)
         term-obl.sop:SCREEN-VALUE          = STRING (term-obl.sop)
         term-obl.sop-date:SCREEN-VALUE     = STRING (term-obl.sop-date, "99/99/9999")
         term-obl.sop-offbal:SCREEN-VALUE   = STRING (term-obl.sop-offbal)
         term-obl.suser-id:SCREEN-VALUE     = term-obl.suser-id
         term-obl.symbol:SCREEN-VALUE       = term-obl.symbol
        NO-ERROR.

   /* Позиционирование на группе полей. */
   ASSIGN

      vFrameHandle = FRAME TermFields:HANDLE
      vFrameHandle = vFrameHandle:FIRST-CHILD
      vFrameHandle = vFrameHandle:FIRST-CHILD
   .
   /* Поиск требуемого поля. */
   DO WHILE VALID-HANDLE (vFrameHandle):

      /* Проверяем поле и индекс. */
      IF vFrameHandle:NAME EQ ipFieldChar AND
         vCountInt         EQ 0
      THEN LEAVE.
      /* Декримент индекса и поиск следующего поля. */
      ASSIGN
         vCountInt    = vCountInt - 1
                        WHEN vFrameHandle:NAME EQ ipFieldChar
         vFrameHandle = vFrameHandle:NEXT-SIBLING
      .
   END.
   IF VALID-HANDLE (vFrameHandle)

   /* Получение значения атрибута. */
   THEN vValueChar = vFrameHandle:SCREEN-VALUE.
    
   RETURN.
   
END PROCEDURE.

/* Возвращает роль основного счета договора */
FUNCTION GetMainAcctRole RETURN CHAR (
   INPUT iContract AS CHAR,
   INPUT iContCode AS CHAR
):

   DEF VAR vRole AS CHAR NO-UNDO. /*роль основного счета*/
   DEF BUFFER loan FOR loan.      /*локализуем буфер*/

   FIND FIRST LOAN WHERE
              loan.contract  = iContract
          AND loan.cont-code = iContCode
      NO-LOCK NO-ERROR.

   IF NOT AVAIL loan THEN
      RETURN ?.

   vRole = GetXAttrInit(loan.class-code,"main-loan-acct").

   RETURN (IF vRole = ?  OR
              vRole = "" THEN
              loan.contract
           ELSE
              vRole).

END FUNCTION .

/*= Получение суммы аннуитетного платежа =*/

PROCEDURE GET_ANNUT_INFO:

   DEF INPUT PARAM iBegDate   AS DATE NO-UNDO. /*Дата начала*/
   DEF INPUT PARAM iEndDate   AS DATE NO-UNDO. /*Дата окончания*/
   DEF INPUT PARAM iSumma     AS DEC  NO-UNDO. /*Сумма кредита*/
   DEF INPUT PARAM iRate      AS DEC  NO-UNDO. /*Ставка по кредиту (% годовых)*/
   DEF INPUT PARAM iFlMoveInt AS INT64  NO-UNDO. /*Куда двигаем если попаданм на выходные*/

   DEF PARAM BUFFER loan-cond FOR loan-cond.   /*Наше условие*/

   DEF OUTPUT PARAM oSumma   AS DEC NO-UNDO.   /*Сумма аннуитетного платежа*/
   DEF OUTPUT PARAM oNumPers AS INT64 NO-UNDO.   /*Количество полных периодов*/

   DEF VAR vTmpDate       AS DATE NO-UNDO.
   DEF VAR vFirstCycleLog AS LOG  NO-UNDO.
   DEF VAR vNumPers       AS INT64  NO-UNDO.
   DEF VAR vSurr          AS CHAR NO-UNDO.
   DEF VAR vRate          AS DEC  NO-UNDO.
   DEF VAR vLp            AS INT64  NO-UNDO.
   DEF VAR vIsLastEndDate AS INT64  NO-UNDO. /* Обязательно ли, что последний платеж = оконч.договора. ДР АннуитПосл */
   DEF VAR vWorkGraf      AS CHAR NO-UNDO.   /* График работы */
   DEF VAR vBranch        AS CHAR NO-UNDO.   /* Подразделение */
   DEF VAR vRoundRub      AS INT64 INIT 2 NO-UNDO.   /* Значение ДР ОкругДоРуб с договора (округлять
                                                     ** ли аннуитетную сумму до рублей) */

   DEF BUFFER loan FOR loan.   /* Наш договор */

   /* Приводим ставку к периоду */
   CASE loan-cond.cred-period:
      WHEN "Н"  THEN vRate = iRate / 4800.
      WHEN "М"  THEN vRate = iRate / 1200.
      WHEN "ДН" THEN vRate = iRate * loan-cond.cred-date / 36500.
      WHEN "К"  THEN vRate = iRate / 400.
      WHEN "ПГ" THEN vRate = iRate / 200.
      WHEN "Г"  THEN vRate = iRate / 100.
      OTHERWISE  vRate = ?.
   END CASE.

   IF vRate = ? THEN RETURN "Некорректно указан период погашения".

   ASSIGN
      vTmpDate       = iBegDate
      vSurr          = GetSurrogateBuffer("loan-cond",(BUFFER loan-cond:HANDLE))
      vIsLastEndDate = INT64(GetXAttrValueEx("loan-cond",
                                           loan-cond.contract + "," + loan-cond.cont-code + "," + STRING(loan-cond.since),
                                           "АннуитПосл",
                                           GetXAttrInit(loan-cond.class-code,"АннуитПосл")))
      .
   FIND FIRST loan WHERE loan.contract  EQ loan-cond.contract
                     AND loan.cont-code EQ loan-cond.cont-code NO-LOCK NO-ERROR.
   IF AVAIL loan THEN DO:
      vBranch = GetBranchForLoan((BUFFER loan:HANDLE)).
      vWorkGraf = GetWorkGraf(loan.contract + "," + loan.cont-code, 
                              loan.Class-Code).
      IF GetXattrValueEx("loan", loan.contract + "," + loan.cont-code,"ОкругДоРуб", GetXattrInit(loan.class-code,"ОкругДоРуб")) EQ "Да" THEN vRoundRub = 0.
                                                                                                                                        ELSE vRoundRub = 2.
   END.
   ELSE
      ASSIGN
         vBranch = ?
         vWorkGraf = ?
         vRoundRub = IF GetSysConf ("ОкруглениеДоРублей") EQ "YES" THEN 0
                                                                   ELSE 2.
      .

   DO WHILE vTmpDate < iEndDate:

      /* Определение даты платежа с учетом периодичности. */
      vTmpDate = RE_MOVE_DATE (vTmpDate,
                               iEndDate,
                               loan-cond.cred-date,
                               loan-cond.cred-period,
                               iFlMoveInt,
                               loan-cond.since,
                               vBranch, 
                               vWorkGraf).


      /* В зависимости от ДР АннуитПосл, решаем, какая дата должна быть последней */
      IF vTmpDate > iEndDate THEN
      DO:
         vTmpDate = IF vIsLastEndDate EQ 0 THEN ?
                                           ELSE iEndDate.
      END.
         

      /* Выходим при вопросе. */
      IF vTmpDate = ? THEN
      DO:

         IF loan-cond.cred-period <> "П"
         THEN LEAVE.

         vTmpDate = iEndDate.

      END.

      vNumPers = vNumPers + 1.

   END.

   vLp = INT64(GetXAttrValueEx("loan-cond",vSurr,"КолЛьгтПер","0")).

   IF vNumPers = 0 OR
      vNumPers <= vLp
   THEN
      RETURN "Количество полных периодов меньше количества льготных".

   oSumma = GetAnnuitet(iSumma, vRate, vLp - vNumPers, 0, 0, vRoundRub).

   ASSIGN

      oNumPers = vNumPers
      .

   RETURN "".


END PROCEDURE.


/* Исключение плановой даты погашения 
yes - исключить*/
FUNCTION ExceptRepDate RETURN LOGICAL (
   INPUT iRepDate AS DATE,   
   BUFFER loan-cond FOR loan-cond):

   DEF BUFFER xterm-obl FOR term-obl.

   IF NOT AVAIL loan-cond THEN RETURN NO.
   IF iRepDate = ? THEN RETURN NO.

   FIND FIRST xterm-obl WHERE 
              xterm-obl.contract  = loan-cond.contract
          AND xterm-obl.cont-code = loan-cond.cont-code
          AND xterm-obl.idnt      = 201
          AND xterm-obl.end-date  = loan-cond.since
          AND xterm-obl.amt-rub   = MONTH(iRepDate)
          AND xterm-obl.sop       = YEAR(iRepDate)
       NO-LOCK NO-ERROR.

   IF AVAIL xterm-obl THEN DO:
       IF xterm-obl.sop-offbal = 1 THEN RETURN NO.
       ELSE RETURN YES.
   END.

   FIND FIRST xterm-obl WHERE 
              xterm-obl.contract  = loan-cond.contract
          AND xterm-obl.cont-code = loan-cond.cont-code
          AND xterm-obl.idnt      = 200
          AND xterm-obl.end-date  = loan-cond.since
          AND xterm-obl.amt-rub   = MONTH(iRepDate)
          AND xterm-obl.sop-date   <= iRepDate
       NO-LOCK NO-ERROR.

   IF AVAIL xterm-obl THEN RETURN YES.

   RETURN NO.

END FUNCTION.


/* Исключение плановой даты погашения 
yes - исключить*/
FUNCTION ExceptRepDateTemp RETURN LOGICAL (
   INPUT iRepDate AS DATE,   
   INPUT iContract AS CHAR,
   INPUT iContCode AS CHAR,
   INPUT iSince AS DATE):

   DEF BUFFER xterm-obl FOR term-obl.

   IF iRepDate = ? THEN RETURN NO.

   FIND FIRST xterm-obl WHERE 
              xterm-obl.contract  = iContract
          AND xterm-obl.cont-code = iContCode
          AND xterm-obl.idnt      = 201
          AND xterm-obl.end-date  = iSince
          AND xterm-obl.amt-rub   = MONTH(iRepDate)
          AND xterm-obl.sop       = YEAR(iRepDate)
       NO-LOCK NO-ERROR.

   IF AVAIL xterm-obl THEN DO:
       IF xterm-obl.sop-offbal = 1 THEN RETURN NO.
       ELSE RETURN YES.
   END.

   FIND FIRST xterm-obl WHERE 
              xterm-obl.contract  = iContract
          AND xterm-obl.cont-code = iContCode
          AND xterm-obl.idnt      = 200
          AND xterm-obl.end-date  = iSince
          AND xterm-obl.amt-rub   = MONTH(iRepDate)
          AND xterm-obl.sop-date   <= iRepDate
       NO-LOCK NO-ERROR.

   IF AVAIL xterm-obl THEN RETURN YES.

   RETURN NO.

END FUNCTION.

/* Функция перерасчет суммы аннуитетного платежа - аналогична функции
** CalcAnnuitet, используемой в f-cond при создании нового условия */
PROCEDURE CalcAnnuitet:

   DEF INPUT PARAM iContract   AS CHAR NO-UNDO.
   DEF INPUT PARAM iContCode   AS CHAR NO-UNDO.
   DEF INPUT PARAM iBegDate    AS DATE NO-UNDO. /*Дата начала*/
   DEF INPUT PARAM iEndDate    AS DATE NO-UNDO. /*Дата окончания*/
   DEF INPUT PARAM iSumma      AS DEC  NO-UNDO. /*Сумма кредита*/
   DEF INPUT PARAM iRate       AS DEC  NO-UNDO. /*Ставка по кредиту (% годовых)*/
   DEF INPUT PARAM iCredDate   AS INT64  NO-UNDO.
   DEF INPUT PARAM iCredPeriod AS CHAR NO-UNDO.
   DEF INPUT PARAM iCredMonth  AS CHAR NO-UNDO.
   DEF INPUT PARAM iLp         AS INT64  NO-UNDO.
   DEF INPUT PARAM iFlMoveInt  AS INT64  NO-UNDO. /*Куда двигаем если попаданм на выходные*/
   DEF INPUT PARAM iDiff       AS INT64  NO-UNDO. /* поправка для рассчета суммы аннуитета */
   DEF INPUT PARAM iSummaDepos AS DEC    NO-UNDO. /*Сумма связанного вклада*/
   DEF INPUT PARAM iFirstPer   AS INT64  NO-UNDO. /* Продолжительность первого периода в месяцах */
   DEF INPUT PARAM iPartAmount AS DEC    NO-UNDO. /* Доля */

   DEF OUTPUT PARAM oSumma     AS DEC  NO-UNDO.   /*Сумма аннуитетного платежа*/

   DEF VAR vTmpDate       AS DATE NO-UNDO.
   DEF VAR vFirstCycleLog AS LOG  NO-UNDO.
   DEF VAR vNumPers       AS INT64  NO-UNDO.
   DEF VAR vSurr          AS CHAR NO-UNDO.
   DEF VAR vRate          AS DEC  NO-UNDO.
   DEF VAR vLpBack        AS INT64  NO-UNDO.
   DEF VAR vExpLg         AS LOG  NO-UNDO. /* есть ли исключаемые месяцы */
   DEF VAR vIsLastEndDate AS INT64  NO-UNDO. /* Обязательно ли, что последний платеж = оконч.договора. ДР АннуитПосл */
   DEF VAR vAnnuitPoslInt AS INT64  NO-UNDO. /* Начальное знач. ДР АннуитПосл */
   DEF VAR vWorkGraf      AS CHAR NO-UNDO.   /* График работы */
   DEF VAR vBranch        AS CHAR NO-UNDO.   /* Подразделение */
   DEF VAR vRoundRub      AS INT64 INIT 2 NO-UNDO.   /* Значение ДР ОкругДоРуб с договора (округлять
                                                     ** ли аннуитетную сумму до рублей) */

   DEF BUFFER  xloan       FOR loan.   /* Наш договор */
   DEF BUFFER  xloan-cond  FOR loan-cond.
   DEF BUFFER  xterm-obl   FOR term-obl.

   DEF QUERY qry-pay       FOR tt-pay.

   EMPTY TEMP-TABLE tt-pay.
   IF iContract <> ? AND
      iContCode <> ?
   THEN
   DO:
      FIND FIRST xloan-cond WHERE
                 xloan-cond.contract  EQ iContract
             AND xloan-cond.cont-code EQ iContCode
             AND xloan-cond.since     GT iBegDate
      NO-LOCK NO-ERROR.
      FIND FIRST xloan WHERE
                 xloan.contract  EQ iContract
             AND xloan.cont-code EQ iContCode
      NO-LOCK NO-ERROR.

      IF     AVAIL xloan
         AND xloan.class-code EQ "loan-transh-ann" THEN 
      DO:
         oSumma = ?.
         RETURN.
      END.
      
      /* вызываем другой алгоритм для вычисления двойной суммы аннуитета */
       IF (AVAIL xloan
           AND xloan.class-code EQ "loan_dbl_ann")
          OR iFirstPer > 0 THEN 
       DO:
         RUN CalcAnnuitet2(iContract,  
                           iContCode,  
                           iBegDate,   
                           iEndDate,   
                           iSumma,     
                           iRate,      
                           iCredDate,  
                           iCredPeriod,
                           iCredMonth, 
                           iLp,        
                           iFlMoveInt, 
                           iDiff,      
                           iSummaDepos,
                           iFirstPer,   
                           iPartAmount,
                           ?,
                           OUTPUT oSumma) NO-ERROR.
         RETURN RETURN-VALUE.
       END.


      IF AVAIL xloan-cond THEN
         iEndDate = xloan-cond.since.
   END.

   IF AVAIL xloan THEN DO:
      vBranch = GetBranchForLoan((BUFFER xloan:HANDLE)).
      vWorkGraf = GetWorkGraf(iContract + "," + iContCode, 
                              xloan.Class-Code).
      IF GetXattrValueEx("loan", xloan.contract + "," + xloan.cont-code,"ОкругДоРуб", GetXattrInit(xloan.class-code,"ОкругДоРуб")) EQ "Да" THEN vRoundRub = 0.
                                                                                                                                           ELSE vRoundRub = 2.      
   END.
   ELSE
      ASSIGN
         vBranch = ?
         vWorkGraf = ?
         vRoundRub = IF GetSysConf ("ОкруглениеДоРублей") EQ "YES" THEN 0
                                                                   ELSE 2.
      .


   /* Приводим ставку к периоду */
   CASE iCredPeriod:
      WHEN "Н"  THEN vRate = iRate / 4800.
      WHEN "М"  THEN vRate = iRate / 1200.
      WHEN "ДН" THEN vRate = iRate * iCredDate / 36500.
      WHEN "К"  THEN vRate = iRate / 400.
      WHEN "ПГ" THEN vRate = iRate / 200.
      WHEN "Г"  THEN vRate = iRate / 100.
      OTHERWISE  vRate = ?.
   END CASE.

   IF vRate = ? THEN RETURN "Некорректно указан период погашения".

   ASSIGN
      vTmpDate       = iBegDate
      vNumPers       = - 1
      vExpLg         = NO
      vLpBack        = iLp
      vAnnuitPoslInt = INT64(GetXAttrInit("an-cond","АннуитПосл"))
      vIsLastEndDate = IF AVAIL xloan-cond THEN INT64(GetXAttrValueEx("loan-cond",
                                                                    xloan-cond.contract + "," + 
                                                                    xloan-cond.cont-code + "," + 
                                                                    STRING(xloan-cond.since),
                                                                    "АннуитПосл",
                                                                    STRING(vAnnuitPoslInt)))
                                           ELSE vAnnuitPoslInt
   .

   DO WHILE vTmpDate < iEndDate:

      /* Определение даты платежа с учетом периодичности. */
      vTmpDate = RE_MOVE_DATE (vTmpDate,
                               iEndDate + 366,
                               iCredDate,
                               iCredPeriod + ":" + iCredMonth,
                               iFlMoveInt,
                               iBegDate,
                               vBranch, 
                               vWorkGraf).


      /* В зависимости от ДР АннуитПосл, решаем, какая дата должна быть последней 
      ** если 0 - то создаем последний платеж не окончание догра
      ** если 1 - то создаем в дату окончания договора точно */
      IF vTmpDate > iEndDate THEN
      DO:
         vTmpDate = IF vIsLastEndDate EQ 0 THEN ?
                                           ELSE iEndDate.
      END.
         
      
      /* Выходим при вопросе. */
      IF vTmpDate = ? THEN
      DO:
         IF iCredPeriod <> "П"
         THEN LEAVE.
         vTmpDate = iEndDate.
      END.

      vNumPers = vNumPers + 1.

      CREATE tt-pay.
      ASSIGN
         tt-pay.period     =  vTmpDate
         tt-pay.pay        =  IF vLpBack NE 0 THEN NO ELSE YES
      .

      IF vLpBack NE 0 THEN
         vLpBack = vLpBack - 1.

   END. /* DO WHILE */
   
   /* Две проверки на прибавление доп. периода.
   ** Первая проверка - если у нас дата окончания совпадает с 
   ** плановым днем погашения т.е. на последний день у нас приходится платеж. 
   ** Вторая проверка - если у нас дата окончания НЕ совпадает с 
   ** последним днем платежа. В этом случае у нас должно быть одинаковое кол-во периодов
   ** как и в первом случае, но vTmpDate тогда "?" и прибавление проглатывалось */
   IF   vTmpDate  GE iEndDate 
     OR iCredDate NE DAY(iEndDate) THEN
      vNumPers = vNumPers + 1.
      
   FOR EACH   xterm-obl WHERE 
             (xterm-obl.contract    = iContract
          AND xterm-obl.cont-code   = iContCode
          AND xterm-obl.idnt        = 201
          AND xterm-obl.end-date    = xloan-cond.since
          AND xterm-obl.sop-offbal  NE 1)
          OR
             (xterm-obl.contract    = iContract
          AND xterm-obl.cont-code   = iContCode
          AND xterm-obl.idnt        = 200
          AND xterm-obl.end-date    = xloan-cond.since)
   NO-LOCK:

      FIND FIRST  tt-pay WHERE
                  tt-pay.pay           EQ YES
              AND MONTH(tt-pay.period) EQ xterm-obl.amt-rub
      NO-LOCK NO-ERROR.
      IF AVAIL tt-pay THEN
         IF (xterm-obl.idnt   EQ 201) THEN
            IF xterm-obl.sop     EQ YEAR(tt-pay.period) THEN
            DO:
               FIND CURRENT tt-pay EXCLUSIVE-LOCK.
               tt-pay.pay = NO.
               FIND CURRENT tt-pay NO-LOCK.
            END.
         ELSE
         IF (xterm-obl.idnt      EQ 200) THEN
            IF xterm-obl.sop-date   <= tt-pay.period THEN
            DO:
               FIND CURRENT tt-pay EXCLUSIVE-LOCK.
               tt-pay.pay = NO.
               FIND CURRENT tt-pay NO-LOCK.
            END.
   END.

   OPEN QUERY qry-pay PRESELECT EACH tt-pay  WHERE tt-pay.pay EQ NO NO-LOCK.
   iLp = NUM-RESULTS("qry-pay").

   IF vNumPers <= 0 OR
      vNumPers <= iLp
   THEN
      RETURN "Количество полных периодов [" + STRING(vNumPers) + "] меньше или равно количеству льготных [" + STRING(iLp) + "]".
   
   oSumma = GetAnnuitet(iSumma, vRate, iLp - vNumPers, iDiff, iSummaDepos, vRoundRub).

END PROCEDURE.

/* Функция перерасчет суммы аннуитетного платежа для двух периодов */
PROCEDURE CalcAnnuitet2:

   DEF INPUT PARAM iContract   AS CHAR NO-UNDO.
   DEF INPUT PARAM iContCode   AS CHAR NO-UNDO.
   DEF INPUT PARAM iBegDate    AS DATE NO-UNDO. /*Дата начала*/
   DEF INPUT PARAM iEndDate    AS DATE NO-UNDO. /*Дата окончания*/
   DEF INPUT PARAM iSumma      AS DEC  NO-UNDO. /*Сумма кредита*/
   DEF INPUT PARAM iRate       AS DEC  NO-UNDO. /*Ставка по кредиту (% годовых)*/
   DEF INPUT PARAM iCredDate   AS INT64  NO-UNDO.
   DEF INPUT PARAM iCredPeriod AS CHAR NO-UNDO.
   DEF INPUT PARAM iCredMonth  AS CHAR NO-UNDO.
   DEF INPUT PARAM iLp         AS INT64  NO-UNDO.
   DEF INPUT PARAM iFlMoveInt  AS INT64  NO-UNDO. /*Куда двигаем если попаданм на выходные*/
   DEF INPUT PARAM iDiff       AS INT64  NO-UNDO. /* поправка для рассчета суммы аннуитета */
   DEF INPUT PARAM iSummaDepos AS DEC    NO-UNDO. /*Сумма связанного вклада*/
   DEF INPUT PARAM iFirstPer   AS INT64  NO-UNDO. /* Продолжительность первого периода в месяцах */
   DEF INPUT PARAM iPartAmount AS DEC    NO-UNDO. /* Доля */
   DEF INPUT PARAM iNumAnnuit  AS INT64  NO-UNDO. /* Какую сумму аннуитета вычислять */

   DEF OUTPUT PARAM oSumma     AS DEC  NO-UNDO.   /*Сумма аннуитетного платежа*/
   
   DEF VAR vTmpDate       AS DATE   NO-UNDO.
   DEF VAR vFirstCycleLog AS LOG    NO-UNDO.
   DEF VAR vNumPers       AS INT64  NO-UNDO.
   DEF VAR vSurr          AS CHAR   NO-UNDO.
   DEF VAR vRate          AS DEC    NO-UNDO.
   DEF VAR vLpBack        AS INT64  NO-UNDO.
   DEF VAR vExpLg         AS LOG    NO-UNDO. /* есть ли исключаемые месяцы */
   DEF VAR vIsLastEndDate AS INT64  NO-UNDO. /* Обязательно ли, что последний платеж = оконч.договора. ДР АннуитПосл */
   DEF VAR vAnnuitPoslInt AS INT64  NO-UNDO. /* Начальное знач. ДР АннуитПосл */
   DEF VAR vWorkGraf      AS CHAR   NO-UNDO.   /* График работы */
   DEF VAR vBranch        AS CHAR   NO-UNDO.   /* Подразделение */
   DEF VAR vFirstAmt      AS DEC    NO-UNDO.   /* Сумма первого периода */
   DEF VAR vCondDate      AS DATE   NO-UNDO.   /* Дата условия, для которого рассчитываем сумму аннуитета */
   DEF VAR vSince         AS DATE   NO-UNDO.
   DEF VAR vVidRestr      AS CHAR   NO-UNDO. /* Вид реструктуризации */
   DEF VAR vIsRestr       AS LOG    NO-UNDO. /* Является ли условие реструктуризацией */
   DEF VAR vNumPersPast   AS INT64  NO-UNDO. /* Кол-во прошедших периодов до даты условия */
   DEF VAR vSummaPast     AS DEC    NO-UNDO. /* Сумма ОД, погашенная в периоде до даты условия */
   DEF VAR vSummaAnnPast  AS DEC    NO-UNDO. /* Предыдущая аннуитетная сумма */
   DEF VAR mCommRate      AS DEC    NO-UNDO. /* Предыдущая ставка */

   DEF BUFFER  xloan       FOR loan.   /* Наш договор */
   DEF BUFFER  xloan-cond  FOR loan-cond.
   DEF BUFFER  bloan-cond  FOR loan-cond.
   DEF BUFFER  xterm-obl   FOR term-obl.
   DEF BUFFER  bcomm-rate  FOR comm-rate.

   DEF QUERY qry-pay       FOR tt-pay.

   EMPTY TEMP-TABLE tt-pay.
   
   IF iContract <> ? AND
      iContCode <> ?
   THEN
   DO:
       
      FIND FIRST xloan-cond WHERE
                 xloan-cond.contract  EQ iContract
             AND xloan-cond.cont-code EQ iContCode
             AND xloan-cond.since     GT iBegDate
      NO-LOCK NO-ERROR.
      
      FIND FIRST xloan WHERE
                 xloan.contract  EQ iContract
             AND xloan.cont-code EQ iContCode
      NO-LOCK NO-ERROR.
   END.   

   IF AVAIL xloan THEN DO:
      vBranch = GetBranchForLoan((BUFFER xloan:HANDLE)).
      vWorkGraf = GetWorkGraf(iContract + "," + iContCode, 
                              xloan.Class-Code).
   END.
   ELSE
      ASSIGN
         vBranch = ?
         vWorkGraf = ?         
      .

   IF iNumAnnuit = ? THEN DO:
       IF NOT AVAIL xloan THEN iNumAnnuit = 1.
       ELSE IF iBegDate = xloan.open-date THEN iNumAnnuit = 1.       
   END.

   /* Приводим ставку к периоду */
   CASE iCredPeriod:
      WHEN "М"  THEN vRate = iRate / 1200.
      WHEN "ДН" THEN vRate = iRate * iCredDate / 36500.
      OTHERWISE  vRate = ?.
   END CASE.

   IF vRate = ? THEN RETURN "Некорректно указан период погашения".

   IF iFirstPer = ?   THEN  iFirstPer = 0.
   IF iPartAmount = ? THEN iPartAmount = 0.

   /* Ищем последнее условие, на котором заданы параметры 
  ** для расчета второй аннуитетной суммы */
  vCondDate = iBegDate.
  fcnd:
  DO WHILE iFirstPer   = 0 
       AND iPartAmount = 0:
       FIND LAST bloan-cond WHERE bloan-cond.contract  EQ iContract
                              AND bloan-cond.cont-code EQ iContCode
                              AND bloan-cond.since     LT vCondDate
      NO-LOCK NO-ERROR.
      IF NOT AVAIL bloan-cond THEN LEAVE fcnd.
      ASSIGN
          vCondDate   = bloan-cond.since 
          iPartAmount = DEC(GetXattrValueEx("loan-cond",
                                            bloan-cond.contract + "," 
                                            + bloan-cond.cont-code + "," + STRING(bloan-cond.since),
                                            "PartAmount",
                                            "0"))
          iFirstPer = INT(GetXattrValueEx("loan-cond",
                                          bloan-cond.contract + "," 
                                          + bloan-cond.cont-code + "," + STRING(bloan-cond.since),
                                          "FirstPeriod",
                                          "0"))
          .
  END.

   ASSIGN
      vTmpDate       = iBegDate
      vNumPers       = - 1
      vExpLg         = NO
      vLpBack        = iLp
      vAnnuitPoslInt = INT64(GetXAttrInit("an-cond","АннуитПосл"))
      vIsLastEndDate = IF AVAIL xloan-cond THEN INT64(GetXAttrValueEx("loan-cond",
                                                                    xloan-cond.contract + "," + 
                                                                    xloan-cond.cont-code + "," + 
                                                                    STRING(xloan-cond.since),
                                                                    "АннуитПосл",
                                                                    STRING(vAnnuitPoslInt)))
                                           ELSE vAnnuitPoslInt
     vIsRestr      = NO
     vSummaAnnPast = 0
   .

   IF  AVAIL xloan AND iNumAnnuit = ? THEN DO:
       ASSIGN
         vCondDate = iBegDate
         vTmpDate = xloan.open-date. /* для реструктуризации тут возможно надо поправить */   

       dt:
       DO WHILE vTmpDate < xloan.end-date:
          
          vNumPers = vNumPers + 1.
          
          IF vNumPers = iFirstPer THEN DO:
             vSince = vTmpDate.
              LEAVE dt.
          END.
    
          /* Определение даты платежа с учетом периодичности. */
          vTmpDate = RE_MOVE_DATE (vTmpDate,
                                   iEndDate + 366,
                                   iCredDate,
                                   iCredPeriod + ":" + iCredMonth,
                                   iFlMoveInt,
                                   iBegDate,
                                   vBranch, 
                                   vWorkGraf).
          
       END. /* DO WHILE */
    
       /* смотрим, в каком периоде (уменьшения или увеличения) создано условие */
       iNumAnnuit = IF vCondDate >= vSince THEN 2 ELSE 1.
        
       /* возвращаем значение переменных обратно */
       ASSIGN
          vTmpDate       = iBegDate
          vNumPers       = - 1
           .
   END.

   /* определяем, от какой суммы вычислять аннуитет. сумму */
   /* в периоде уменьшения ищем первую сумму */
   IF AVAIL xloan 
        AND iNumAnnuit = 1 THEN 
   DO:
       vTmpDate = xloan.open-date.
       /* В случае реструктуризации надо вычислить прошедшую сумму */
       IF iBegDate > xloan.open-date THEN DO:
           /* может быть задано в conf, если редактируем условие */
           vVidRestr = GetSysConf("Реструктуризация").
           IF vVidRestr EQ "Да" THEN vIsRestr = YES.
           ELSE IF vVidRestr EQ "Нет" THEN vIsRestr = NO.
           /* иначе определяем */
           ELSE DO:
              FIND LAST bloan-cond WHERE bloan-cond.contract  EQ iContract
                                     AND bloan-cond.cont-code EQ iContCode
                                     AND bloan-cond.since     EQ iBegDate
                 NO-LOCK NO-ERROR.
              IF AVAIL bloan-cond THEN DO:
                 vVidRestr = GEtXattrVAlueEx("loan-cond",
                                             bloan-cond.contract + "," 
                                             + bloan-cond.cont-code + "," + STRING(bloan-cond.since),
                                             "ВидРеструкт",
                                             "").
                 IF vVidRestr > "" THEN vIsRestr = YES.
                 IF vIsRestr THEN vSummaPast = iSumma.
              END. 
           END.
       END.

       FIND FIRST xterm-obl WHERE 
                  xterm-obl.contract    = iContract
              AND xterm-obl.cont-code   = iContCode
              AND xterm-obl.idnt        = 2
              AND xterm-obl.end-date    = xloan.open-date
           NO-LOCK NO-ERROR.
       IF AVAIL xterm-obl THEN
          iSumma = xterm-obl.amt-rub.  

       /* вычитаем, так как нам нужна плановая погашенная сумма, а не текущая задолженность */
       IF vIsRestr THEN vSummaPast = iSumma - vSummaPast.
       /* если не первое условие в периоде погашения и не реструктурзация,
       ** то сумму аннуитета берем с предыдущего условия */
       ELSE IF iBegDate > xloan.open-date THEN
       DO:
           mCommRate = 0.
           /* проверяем, что неизменилась ставка */
           bcm:
           FOR LAST bcomm-rate WHERE
                    bcomm-rate.commission = "%Кред"
                AND bcomm-rate.acct       = "0"
                AND bcomm-rate.kau        = iContract + "," + iContCode
                AND bcomm-rate.since      < iBegDate
              USE-INDEX kau NO-LOCK:
              mCommRate = bcomm-rate.rate-comm.
              LEAVE bcm.
           END.
           IF mCommRate = iRate THEN 
           DO:
              FIND LAST bloan-cond WHERE bloan-cond.contract  EQ iContract
                                     AND bloan-cond.cont-code EQ iContCode
                                     AND bloan-cond.since     LT iBegDate
                 NO-LOCK NO-ERROR.
              IF AVAIL bloan-cond THEN 
              DO:
                 vSummaAnnPast = DEC(GetXattrValueEx("loan-cond",
                                                     bloan-cond.contract + "," 
                                                     + bloan-cond.cont-code + "," + STRING(bloan-cond.since),
                                                     "АннуитПлат",
                                                     "0")) NO-ERROR.
                 IF (NOT ERROR-STATUS:ERROR) 
                     AND vSummaAnnPast > 0 THEN
                 DO:
                     oSumma = vSummaAnnPast.
                     RETURN.
                 END.   
              END.
           END.
       END.
   END.

   DO WHILE vTmpDate < iEndDate:

      /* Определение даты платежа с учетом периодичности. */
      vTmpDate = RE_MOVE_DATE (vTmpDate,
                               iEndDate + 366,
                               iCredDate,
                               iCredPeriod + ":" + iCredMonth,
                               iFlMoveInt,
                               iBegDate,
                               vBranch, 
                               vWorkGraf).


      /* В зависимости от ДР АннуитПосл, решаем, какая дата должна быть последней 
      ** если 0 - то создаем последний платеж не окончание догра
      ** если 1 - то создаем в дату окончания договора точно */
      IF vTmpDate > iEndDate THEN
      DO:
         vTmpDate = IF vIsLastEndDate EQ 0 THEN ?
                                           ELSE iEndDate.
      END.         
      
      /* Выходим при вопросе. */
      IF vTmpDate = ? THEN
      DO:
         IF iCredPeriod <> "П"
         THEN LEAVE.
         vTmpDate = iEndDate.
      END.

      vNumPers = vNumPers + 1.

      CREATE tt-pay.
      ASSIGN
         tt-pay.period     =  vTmpDate
         tt-pay.pay        =  IF vLpBack NE 0 THEN NO ELSE YES
      .

      IF vLpBack NE 0 THEN
         vLpBack = vLpBack - 1.

      IF vIsRestr 
         AND vTmpDate < iBegDate
          THEN vNumPersPast = vNumPersPast + 1.

   END. /* DO WHILE */

   /* Две проверки на прибавление доп. периода.
   ** Первая проверка - если у нас дата окончания совпадает с 
   ** плановым днем погашения т.е. на последний день у нас приходится платеж. 
   ** Вторая проверка - если у нас дата окончания НЕ совпадает с 
   ** последним днем платежа. В этом случае у нас должно быть одинаковое кол-во периодов
   ** как и в первом случае, но vTmpDate тогда "?" и прибавление проглатывалось */
   IF   vTmpDate  GE iEndDate 
     OR iCredDate NE DAY(iEndDate) THEN
      vNumPers = vNumPers + 1.

   FOR EACH   xterm-obl WHERE 
             (xterm-obl.contract    = iContract
          AND xterm-obl.cont-code   = iContCode
          AND xterm-obl.idnt        = 201
          AND xterm-obl.end-date    = xloan-cond.since
          AND xterm-obl.sop-offbal  NE 1)
          OR
             (xterm-obl.contract    = iContract
          AND xterm-obl.cont-code   = iContCode
          AND xterm-obl.idnt        = 200
          AND xterm-obl.end-date    = xloan-cond.since)
   NO-LOCK:

      FIND FIRST  tt-pay WHERE
                  tt-pay.pay           EQ YES
              AND MONTH(tt-pay.period) EQ xterm-obl.amt-rub
      NO-LOCK NO-ERROR.
      IF AVAIL tt-pay THEN
         IF (xterm-obl.idnt   EQ 201) THEN
            IF xterm-obl.sop     EQ YEAR(tt-pay.period) THEN
            DO:
               FIND CURRENT tt-pay EXCLUSIVE-LOCK.
               tt-pay.pay = NO.
               FIND CURRENT tt-pay NO-LOCK.
            END.
         ELSE
         IF (xterm-obl.idnt      EQ 200) THEN
            IF xterm-obl.sop-date   <= tt-pay.period THEN
            DO:
               FIND CURRENT tt-pay EXCLUSIVE-LOCK.
               tt-pay.pay = NO.
               FIND CURRENT tt-pay NO-LOCK.
            END.
   END.

   OPEN QUERY qry-pay PRESELECT EACH tt-pay  WHERE tt-pay.pay EQ NO NO-LOCK.
   iLp = NUM-RESULTS("qry-pay").

   IF vNumPers <= 0 OR
      vNumPers <= iLp
   THEN
      RETURN "Количество полных периодов [" + STRING(vNumPers) + "] меньше или равно количеству льготных [" + STRING(iLp) + "]".
   
   IF iFirstPer <= 0 OR
      iFirstPer <= iLp
   THEN
      RETURN "Количество периодов в периоде уменьшения [" + STRING(iFirstPer) + "] меньше или равно количеству льготных [" + STRING(iLp) + "]".

   IF iNumAnnuit = 1 THEN DO:
       IF   vIsRestr 
        AND vNumPersPast > 0 
        AND vSummaPast > 0 THEN
            oSumma = GetAnnuitet1(iSumma, iPartAmount, vRate, iFirstPer - vNumPersPast, iSummaDepos, 2) 
                     - GetAnnuitet2(vSummaPast, vRate, iFirstPer - vNumPersPast, 0, 2).
       ELSE 
            oSumma = GetAnnuitet1(iSumma, iPartAmount, vRate, iFirstPer, iSummaDepos, 2).
   END.      
   ELSE 
       oSumma = GetAnnuitet2(iSumma, vRate, vNumPers - iLp, iSummaDepos, 2). 

END PROCEDURE.

   /* Функция возвращает строку с количеством месяцев "M" или лет "Y",
   ** с учетом правописания */
FUNCTION YMinWords RETURNS CHARACTER (
   INPUT iSumma AS DECIMAL,
   INPUT iType  AS CHAR
   ):

   DEF VAR vText  AS CHAR NO-UNDO EXTENT INIT ["год","года","лет","месяц","месяца","месяцев"].
   DEF VAR vIndex AS INT64  NO-UNDO.
   DEF VAR vDec   AS LOG  NO-UNDO.
   DEF VAR vRet   AS CHAR NO-UNDO.

   IF iSumma GT 0 
      AND CAN-DO("M,Y", iType) THEN
   DO:
      ASSIGN
         vIndex = INT64(iSumma - TRUNCATE(iSumma / 100, 0) * 100)
         vDec   = IF vIndex GT 10 AND vIndex LT 15 THEN TRUE ELSE FALSE
         vIndex = INT64(iSumma - TRUNCATE(iSumma / 10, 0) * 10)
         vIndex = IF vIndex EQ 1 THEN 1 ELSE (IF vIndex LT 5 AND vIndex GT 1 THEN 2 ELSE 3)
         vIndex = IF vDec THEN 3 ELSE vIndex
         vIndex = IF iType  EQ "Y" THEN vIndex ELSE vIndex + 3
         vRet   = TRIM(STRING(iSumma))+ " " + vText[vIndex]
      .
   END.
   RETURN vRet.
END FUNCTION.

   /* Процедура проверяет ограничение по сроку аннуитета
   ** No - сохранение возможно, Yes - сохранение невозможно */
PROCEDURE CheckTermLimit.
   DEF INPUT  PARAMETER iClass  AS CHAR NO-UNDO. /* Класс договора */
   DEF INPUT  PARAMETER iDate1  AS DATE NO-UNDO. /* Дата начала договора */
   DEF INPUT  PARAMETER iDate2  AS DATE NO-UNDO. /* Дата окончания договора */
   DEF INPUT  PARAMETER iRate   AS DEC  NO-UNDO. /* %% ставка */
   DEF OUTPUT PARAMETER oResult AS LOG  NO-UNDO. /* Признак возможности сохранения договора */
   DEF OUTPUT PARAMETER oRetVal AS CHAR NO-UNDO. /* Признак возможности сохранения договора */

   DEF VAR vXattrInit AS CHAR NO-UNDO.
   DEF VAR vMonths    AS DEC  NO-UNDO.
   DEF VAR vMaxMon    AS DEC  NO-UNDO.
   DEF VAR vMontQuan  AS DEC  NO-UNDO.
   DEF VAR vYearQuan  AS DEC  NO-UNDO.

   ASSIGN
      oRetVal = ""
      oResult = FALSE
   .   
      /* Проверка начального значения реквизита "ОгрСрок" класса договора */
   vXattrInit = GetXattrInit(iClass, "ОгрСрок").
   IF    (vXattrInit EQ "Предупреждение")
      OR (vXattrInit EQ "ЗапретВвода"   ) THEN
   DO:
         /* Считаем количество месяцев между датами */
      vMonths = MonInPer(iDate1, iDate2).
        /* Определяем максимальное кол-во месяцев по формуле банка,
        ** отсекая дробную часть полученного значения */ 
      ASSIGN
         vMaxMon   = 1 + LOG(372 / 7, 1 + (iRate / 100) / 12)
         vMaxMon   = TRUNCATE(vMaxMon, 0)
         vYearQuan = TRUNCATE(vMaxMon / 12, 0)
         vMontQuan = vMaxMon - vYearQuan * 12
      .
        /* Проверяем на превышение этого периода */
      IF vMonths GE vMaxMon THEN
      DO:
         ASSIGN
            oRetVal   = "Для ставки кредитования " + TRIM(STRING(iRate)) + 
                        " возможен расчет планирования и построение графика аннуитетных платежей на срок не более чем " +
                        YMinWords(vMaxMon, "M") + 
                        (IF vYearQuan GT 0 THEN " (" + YMinWords(vYearQuan, "Y") + 
                        (IF vMontQuan GT 0 THEN " "  + YMinWords(vMontQuan, "M") ELSE "") + ")" ELSE "") + "."
            oRetVal   = IF vXattrInit EQ "ЗапретВвода" 
                           THEN oRetVal + "Сохранение договора/условия в базе невозможно."
                           ELSE "Предупреждение: " + oRetVal
            oResult   = IF vXattrInit EQ "ЗапретВвода" 
                           THEN TRUE
                           ELSE FALSE
         .
      END.
   END.
END PROCEDURE.

PROCEDURE SetGraph:
   DEFINE  INPUT PARAMETER iContract AS CHARACTER NO-UNDO.
   DEFINE  INPUT PARAMETER iContCode AS CHARACTER NO-UNDO.
   DEFINE  INPUT PARAMETER iCheck    AS LOGICAL   NO-UNDO. /* пересчитывать ли аннуитетную сумму */
   DEFINE OUTPUT PARAMETER oOk       AS LOGICAL   NO-UNDO.

   DEFINE VARIABLE vRate       AS CHAR NO-UNDO.
   DEFINE VARIABLE vI          AS INT64  NO-UNDO.
   DEFINE VARIABLE vSurr       AS CHAR NO-UNDO.
   DEFINE VARIABLE mAnnSumm    AS DEC  NO-UNDO.
   DEFINE VARIABLE mPer        AS INT64  NO-UNDO.
   DEFINE VARIABLE vTypePlat   AS CHAR NO-UNDO.

   DEFINE BUFFER loan-cond  FOR loan-cond.
   DEFINE BUFFER xloan-cond FOR loan-cond. /* Локализация буфера. */
   DEFINE BUFFER loan       FOR loan.
   DEFINE BUFFER b-loan     FOR loan.
   DEFINE BUFFER tloan      FOR loan.
   DEFINE BUFFER tloan-cond FOR loan-cond.
   DEFINE BUFFER comm-rate  FOR comm-rate.
   DEFINE BUFFER xcomm-rate FOR comm-rate.
   DEFINE BUFFER bcomm-rate FOR comm-rate.
   DEFINE BUFFER term-obl   FOR term-obl.

   DEFINE VARIABLE vCredOffset      AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE vIntOffset       AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE vOffset          AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE vDelayOffset     AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE vDelayOffsetInt  AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE proc-name        AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE params           AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mCommRate        AS DECIMAL     NO-UNDO.
   DEFINE VARIABLE vCondCount       AS INT64     NO-UNDO.

   FIND FIRST loan
        WHERE loan.contract  EQ iContract
          AND loan.cont-code EQ iContCode
      NO-LOCK NO-ERROR.
   FIND FIRST loan-cond
        WHERE loan-cond.contract  EQ iContract
          AND loan-cond.cont-code EQ iContCode
          AND loan-cond.since     GE loan.open-date
      NO-LOCK NO-ERROR.
   FIND FIRST term-obl
        WHERE term-obl.contract  EQ iContract
          AND term-obl.cont-code EQ icontCode
          AND term-obl.idnt      EQ 2
          AND term-obl.end-date  GE loan.open-date
      NO-LOCK NO-ERROR.

   IF AVAILABLE loan      AND
      AVAILABLE loan-cond AND
      AVAILABLE term-obl
   THEN
   DO:
      dbo:dbg("LOAN.PRO SetGraph", SUBSTITUTE(
              "certif:&1; iContract:&2; iContCode:&3.",
               dbocert:certif,iContract, iContCode)).
      GETGR:
      DO TRANSACTION ON ERROR  UNDO getgr, LEAVE getgr
                     ON ENDKEY UNDO getgr, LEAVE getgr:

         RUN GetClassMethod IN h_xclass (loan-cond.class-code, "ImpCorrect", "", "",
                                         OUTPUT proc-name,
                                         OUTPUT params).

         IF {assigned proc-name} THEN
         RUN RunClassMethod IN h_xclass (loan-cond.class-code, "ImpCorrect", "", "", "",
                                         loan.contract + "," + loan.cont-code) NO-ERROR.

         vRate = GetXattrEx(loan.class-code,'rate-list','Initial').
         DO vI = 1 TO NUM-ENTRIES(vRate):
            FOR EACH comm-rate
               WHERE comm-rate.kau        EQ loan.cont-code
                 AND comm-rate.acct       EQ '0'
                 AND comm-rate.currency   EQ loan.currency
                 AND comm-rate.commission EQ ENTRY(vI,vRate)
               USE-INDEX kau:
               FIND LAST xcomm-rate
                   WHERE xcomm-rate.kau        EQ loan.contract + ',' + loan.cont-code
                     AND xcomm-rate.acct       EQ '0'
                     AND xcomm-rate.currency   EQ loan.currency
                     AND xcomm-rate.commission EQ ENTRY(vI,vRate)
                     AND xcomm-rate.since      EQ comm-rate.since
                  USE-INDEX kau
                  EXCLUSIVE-LOCK NO-WAIT NO-ERROR.
               IF LOCKED xcomm-rate THEN
                  UNDO  getgr, LEAVE getgr.
               IF NOT AVAILABLE xcomm-rate THEN
                  CREATE xcomm-rate.
               BUFFER-COPY comm-rate EXCEPT kau comm-rate-id TO xcomm-rate.
               xcomm-rate.kau = loan.contract + ',' + loan.cont-code.
            END.
         END.
         /* надо сделать часть проверок, чтобы не перезатереть информацию */
         /*  сначала тип расчета */
         /* получаем суррогат для условий */
         vSurr = GetSurrogateBuffer("loan-cond",(BUFFER loan-cond:HANDLE)).
         /* получаем тип расчета */
         vTypePlat = GetXAttrValueEx('loan-cond',vSurr,'СхемаПлат',?).

         IF vTypePlat NE 'Дифференцированная' THEN
         DO:
            mAnnSumm = DECIMAL(GetXAttrValueEx('loan-cond',vSurr,'АннуитПлат','0')).
            /* рассчитываем сумму аннуитета */
            IF mAnnSumm = 0.0 OR
               iCheck
            THEN
            DO:
               FIND LAST bcomm-rate WHERE bcomm-rate.kau        EQ loan.contract + "," + loan.cont-code
                                      AND bcomm-rate.commission EQ "%Кред" NO-LOCK NO-ERROR.

               mCommRate = IF AVAIL bcomm-rate THEN bcomm-rate.rate-comm
                                               ELSE 0.

               vCredOffset = GetXAttrValueEx("loan",
                                             loan.contract + "," + loan.cont-code,
                                             "cred-offset",
                                             "--").

               RUN CalcAnnuitet(loan.contract,
                                loan.cont-code,
                                loan-cond.since,
                                loan.end-date,
                                term-obl.amt-rub,
                                mCommRate,
                                loan-cond.cred-date,
                                loan-cond.cred-period,
                                "1",
                                1,
                                LOOKUP(vCredOffset,"--,->,<-"),
                                INT64(GetXAttrValueEx("loan-cond", 
                                                    loan.contract + "," + loan.cont-code + "," + STRING(loan-cond.since), 
                                                    "АннуитКорр",
                                                    ?)
                                    ),
                                DEC(GetXAttrValueEx("loan", 
                                                    loan.contract + "," + loan.cont-code, 
                                                    "Sum-depos",
                                                    "0")
                                    ),
                                INT(GetXattrValueEx("loan-cond",
                                                    loan.contract + "," + loan.cont-code + "," + STRING(loan-cond.since),
                                                    "FirstPeriod",
                                                    "0")),
                                DEC(GetXattrValueEx("loan-cond",
                                                    loan.contract + "," + loan.cont-code + "," + STRING(loan-cond.since),
                                                    "PartAmount",
                                                    "0")),
                                OUTPUT mAnnSumm).
               
               UpdateSigns(loan-cond.class-code,
                           vSurr,
                           'АннуитПлат',
                           STRING(mAnnSumm),
                           ?).
            END.
            IF vTypePlat EQ ? THEN
               UpdateSigns(loan-cond.class-code,
                           vSurr,
                           'СхемаПлат',
                           'Аннуитетная',
                           ?).
            dbo:dbg("LOAN.PRO SetGraph", SUBSTITUTE(
                    "certif:&1; mAnnSumm:&2.",dbocert:certif,mAnnSumm)).
         END.

         ASSIGN
            vSurr           = loan.contract + "," + loan.cont-code
            vCredOffset     = GetXAttrValueEx("loan",vSurr,"cred-offset","")
            vIntOffset      = GetXAttrValueEx("loan",vSurr,"int-offset","")
            vDelayOffset    = GetXAttrValueEx("loan",vSurr,"delay-offset","")
            vDelayOffsetInt = GetXAttrValueEx("loan",vSurr,"delay-offset-int","")
            vOffset         = ",->,<-"
         .
         RUN SetSysConf IN h_base("ОБЯЗАТЕЛЬСТВА ПО ВОЗВРАТУ СДВИГ",
                                  STRING(LOOKUP(vCredOffset,vOffset))).
         RUN SetSysConf IN h_base("ПЛАТЕЖИ ПО ПРОЦЕНТАМ СДВИГ",
                                  STRING(LOOKUP(vIntOffset, vOffset))).
         RUN SetSysConf IN h_base("ОБЯЗ. ПО ВОЗВРАТУ СДВИГ ОКОН.СРОКА",
                                  STRING(LOOKUP(vDelayOffset,vOffset))).
         RUN SetSysConf IN h_base("ПЛАТ. ПО ПРОЦ. СДВИГ ОКОН.СРОКА",
                                  STRING(LOOKUP(vDelayOffsetInt,vOffset))).

         FOR EACH xloan-cond WHERE xloan-cond.contract  EQ loan.contract
                               AND xloan-cond.cont-code EQ loan.cont-code
         NO-LOCK:
            vCondCount = vCondCount + 1.
         END.

         IF    loan.class-code EQ "loan-transh-ann"
            OR loan.class-code EQ "loan-tran-lin-ann" THEN
         DO:
            /* копирование ставки, в случае необходимости  */
            RUN loansvodgr.p(loan.contract,ENTRY(1,loan.cont-code," "),loan-cond.since,"get").
            /* для каждого транша и самого договора */
            FOR EACH tloan WHERE (tloan.contract  EQ loan.contract
                              AND tloan.cont-code EQ loan.cont-code
                              AND NUM-ENTRIES(tloan.cont-code," ") GT 1)
                             OR  (tloan.contract  EQ loan.contract
                              AND tloan.cont-code EQ ENTRY(1,loan.cont-code," "))
                NO-LOCK,
                LAST tloan-cond WHERE tloan-cond.contract  EQ tloan.contract
                                  AND tloan-cond.cont-code EQ tloan.cont-code
                NO-LOCK BY NUM-ENTRIES(tloan.cont-code," ") DESC:

               /* считаем кол-во условий на течении */
               vCondCount = 0.
               FOR EACH xloan-cond WHERE   
                        xloan-cond.contract  = tloan.contract
                    AND xloan-cond.cont-code = tloan.cont-code
               NO-LOCK:
                  vCondCount = vCondCount + 1.
               END.
               FIND FIRST term-obl
                    WHERE term-obl.contract  EQ tloan.contract
                      AND term-obl.cont-code EQ tloan.cont-code
                      AND term-obl.idnt      EQ 2
                      AND term-obl.end-date  GE tloan.open-date
               NO-LOCK NO-ERROR.
               /* пересчет графиков */
               RUN mm-to.p (RECID(tloan),
                            RECID(tloan-cond),
                            term-obl.amt,
                            1,
                            YES,
                            YES,
                            YES,
                            YES,
                            ?,
                            vCondCount).
            END.
            /* строим сводный график по ссуде  */
            RUN loansvodgr.p(loan.contract,ENTRY(1,loan.cont-code," "),loan-cond.since,"set").
         END.
         ELSE 
         DO :
            /* пересчет графиков */
            RUN mm-to.p (RECID(loan),
                         RECID(loan-cond),
                         term-obl.amt,
                         1,
                         YES,
                         YES,
                         YES,
                         YES,
                         ?,
                         vCondCount).
            dbo:dbg("LOAN.PRO SetGraph", SUBSTITUTE(
                    "certif:&1; term-obl.amt:&2; vCondCount:&3.", 
                    dbocert:certif,term-obl.amt,vCondCount)).
         END.

         RUN DeleteOldDataProtocol IN h_base("ПЛАТЕЖИ ПО ПРОЦЕНТАМ СДВИГ").
         RUN DeleteOldDataProtocol IN h_base("ОБЯЗАТЕЛЬСТВА ПО ВОЗВРАТУ СДВИГ").
         RUN DeleteOldDataProtocol IN h_base("ОБЯЗ. ПО ВОЗВРАТУ СДВИГ ОКОН.СРОКА").
         RUN DeleteOldDataProtocol IN h_base("ПЛАТ. ПО ПРОЦ. СДВИГ ОКОН.СРОКА").

         /* Создание связи условий страхования заявки и договора со страховщиком */
         vSurr = "4082,4083".
         DO vI = 1 TO NUM-ENTRIES(vSurr):
            FOR EACH term-obl
               WHERE term-obl.contract  EQ loan.contract
                 AND term-obl.cont-code EQ loan.cont-code
                 AND term-obl.idnt      EQ INT64(ENTRY(vI,vSurr)),
               FIRST b-loan
               WHERE b-loan.contract  EQ "ДогСтрах"
                 AND b-loan.cust-id   EQ term-obl.sop-offbal
                 AND b-loan.open-date LE loan.open-date
                 AND (b-loan.end-date GE loan.open-date
                  OR  b-loan.end-date EQ ?):
               ASSIGN
                  term-obl.lnk-contract  = b-loan.contract
                  term-obl.lnk-cont-code = b-loan.cont-code
                  .
            END.
         END.

         oOk = YES.
      END.
   END.
END PROCEDURE.

PROCEDURE CorrLoanCond.
   DEFINE INPUT  PARAMETER iContract AS CHARACTER   NO-UNDO.
   DEFINE INPUT  PARAMETER iContCode AS CHARACTER   NO-UNDO.

   DEFINE VARIABLE mProdKod         AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mProdPogPr       AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mProdPogOD       AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mProdPogODt      AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mCredOffset      AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mDelayOffset     AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mIntOffset       AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mDelayOffsetInt  AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mSurrLCond       AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mDRProd          AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mKredPl          AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mAnnuPl          AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mCount           AS INT64       NO-UNDO.

   DEFINE BUFFER loan      FOR loan.
   DEFINE BUFFER loan-cond FOR loan-cond.

   dbo:dbg("LOAN.PRO CorrLoanCond", SUBSTITUTE(
           "certif:&1; iContract:&2; iContCode:&3.",
           dbocert:certif,iContract,iContCode)).
   MAIN:
   DO ON ERROR  UNDO MAIN, LEAVE MAIN
      ON ENDKEY UNDO MAIN, LEAVE MAIN:

      FIND FIRST loan WHERE loan.contract  EQ iContract
                        AND loan.cont-code EQ iContCode NO-LOCK NO-ERROR.
      IF NOT AVAIL loan THEN
         UNDO MAIN, LEAVE MAIN.

      mProdKod = GetXAttrValueEx("loan",
                                 loan.contract + "," + loan.cont-code,
                                 "ПродКод",
                                 "").

      dbo:dbg("LOAN.PRO CorrLoanCond", SUBSTITUTE(
              "certif:&1; mProdKod:&2.",dbocert:certif,mProdKod)).

      IF NOT AvailCode("ПродЛин", mProdKod) THEN
         UNDO MAIN, LEAVE MAIN.

      mProdPogPr = GetRefVal("ПродПог",
                             loan.open-date,
                             mProdKod + "," + "%").

      mProdPogOD = GetRefVal("ПродПог",
                             loan.open-date,
                             mProdKod + "," + "ОД").

      IF {assigned mProdPogOD } THEN
      DO:
         ASSIGN
            mProdPogODt = ENTRY(NUM-ENTRIES(mProdPogOD), mProdPogOD)
            mCount      = GetRefCrVal ("ПродПог",
                                       "Параметры",
                                       loan.open-date,
                                       mProdKod + "," + "ОД",
                                       (TEMP-TABLE ttIndicate:HANDLE)
                                      )
         .

         FOR FIRST ttIndicate 
             WHERE {assigned ttIndicate.fComment } :
             loop1:
             DO mCount = 1 TO NUM-ENTRIES(ttIndicate.fComment) :
                mDRProd = ENTRY(mCount, ttIndicate.fComment).
                IF NUM-ENTRIES(mDRProd,":") NE 2 THEN 
                NEXT loop1.
                IF TRIM(ENTRY(1,mDRProd,":")) EQ "АннуитПлат" THEN
                mAnnuPl = TRIM(ENTRY(2,mDRProd,":")).
                IF TRIM(ENTRY(1,mDRProd,":")) EQ "КредПлат"   THEN
                mKredPl = TRIM(ENTRY(2,mDRProd,":")).
             END.
         END.
      END.

      dbo:dbg("LOAN.PRO CorrLoanCond", SUBSTITUTE(
              "certif:&1; mProdPogPr:&2; mProdPogOD:&3; mProdPogODt:&4; mKredPl:&5; mAnnuPl:&6.", 
               dbocert:certif,mProdPogPr,mProdPogOD,mProdPogODt,mKredPl,mAnnuPl)).

      FIND LAST loan-cond WHERE loan-cond.contract  EQ loan.contract
                            AND loan-cond.cont-code EQ loan.cont-code EXCLUSIVE-LOCK NO-ERROR.
      IF NOT AVAIL loan-cond THEN
         UNDO MAIN, LEAVE MAIN.

      mSurrLCond = loan-cond.contract + "," + loan-cond.cont-code + "," + STRING(loan-cond.since).

      UpdateSigns(loan-cond.class-code, mSurrLCond, 'СхемаПлат', STRING(NOT {assigned mProdPogPr }, "Аннуитетная/"), ?).

      IF mProdPogODt EQ "ДД" THEN
         UpdateSigns(loan-cond.class-code, mSurrLCond, "ДатаПогВыч", "ДД", ?).

      /* ОД */
      ASSIGN
         loan-cond.cred-period = ENTRY(1, mProdPogOD)
         loan-cond.cred-date   = (IF mProdPogODt EQ "ДД" THEN DAY(loan.open-date)
                                                         ELSE INT64(ENTRY(2, mProdPogOD))) WHEN NUM-ENTRIES(mProdPogOD) GT 1
         loan-cond.cred-month  = INT64(ENTRY(3, mProdPogOD)) WHEN NUM-ENTRIES(mProdPogOD) GT 2
         loan-cond.delay1      = INT64(ENTRY(7, mProdPogOD)) WHEN NUM-ENTRIES(mProdPogOD) GT 6
         mCredOffset           = (IF ENTRY(4, mProdPogOD) EQ "--" THEN ""
                                                                  ELSE ENTRY(4, mProdPogOD)) WHEN NUM-ENTRIES(mProdPogOD) GT 3
         mDelayOffset          = (IF ENTRY(8, mProdPogOD) EQ "--" THEN ""
                                                                  ELSE ENTRY(8, mProdPogOD)) WHEN NUM-ENTRIES(mProdPogOD) GT 7
      .
      IF NUM-ENTRIES(mProdPogOD) GT 4 THEN
      UpdateSigns(loan-cond.class-code, mSurrLCond, "КолЛьгтПер",   ENTRY(5, mProdPogOD), ?).
      IF NUM-ENTRIES(mProdPogOD) GT 5 THEN
      UpdateSigns(loan-cond.class-code, mSurrLCond, "cred-mode",    ENTRY(6, mProdPogOD), ?).
      UpdateSigns(loan-cond.class-code, mSurrLCond, "cred-offset",  mCredOffset,          ?).
      UpdateSigns(loan-cond.class-code, mSurrLCond, "delay-offset", mDelayOffset,         ?).

      /* %% */
      IF {assigned mProdPogPr } 
      THEN
      DO:
         dbo:dbg("LOAN.PRO CorrLoanCond", SUBSTITUTE(
                 "certif:&1; assigned mProdPogPr:YES",dbocert:certif)).
         ASSIGN
            loan-cond.int-period = ENTRY(1, mProdPogPr)
            loan-cond.int-date   = (IF mProdPogODt EQ "ДД" THEN DAY(loan.open-date)
                                                           ELSE INT64(ENTRY(2, mProdPogPr))) WHEN NUM-ENTRIES(mProdPogPr) GT 1
            loan-cond.int-month  = INT64(ENTRY(3, mProdPogPr)) WHEN NUM-ENTRIES(mProdPogPr) GT 2
            loan-cond.delay      = INT64(ENTRY(7, mProdPogPr)) WHEN NUM-ENTRIES(mProdPogPr) GT 6
            mIntOffset           = (IF ENTRY(4, mProdPogPr) EQ "--" THEN ""
                                                                    ELSE ENTRY(4, mProdPogPr)) WHEN NUM-ENTRIES(mProdPogPr) GT 3
            mDelayOffsetInt      = (IF ENTRY(8, mProdPogPr) EQ "--" THEN ""
                                                                    ELSE ENTRY(8, mProdPogPr)) WHEN NUM-ENTRIES(mProdPogPr) GT 7
         .
         IF NUM-ENTRIES(mProdPogPr) GT 4 THEN
         UpdateSigns(loan-cond.class-code, mSurrLCond, "КолЛьгтПерПрц",    ENTRY(5, mProdPogPr), ?).
         IF NUM-ENTRIES(mProdPogPr) GT 5 THEN
         UpdateSigns(loan-cond.class-code, mSurrLCond, "int-mode",         ENTRY(6, mProdPogPr), ?).
         UpdateSigns(loan-cond.class-code, mSurrLCond, "int-offset",       mIntOffset,           ?).
         UpdateSigns(loan-cond.class-code, mSurrLCond, "delay-offset-int", mDelayOffsetInt,      ?).
         IF {assigned mKredPl } THEN
         UpdateSigns(loan-cond.class-code, mSurrLCond, "КредПлат",         mKredPl,              ?).
      END.
      ELSE
      DO:
         dbo:dbg("LOAN.PRO CorrLoanCond", SUBSTITUTE(
                 "certif:&1; assigned mProdPogPr:NO",dbocert:certif)).
         ASSIGN
            loan-cond.int-period = loan-cond.cred-period
            loan-cond.int-date   = loan-cond.cred-date
            loan-cond.int-month  = loan-cond.cred-month
            loan-cond.delay      = loan-cond.delay1
         .

         IF NUM-ENTRIES(mProdPogOD) GT 4 THEN
         UpdateSigns(loan-cond.class-code, mSurrLCond, "КолЛьгтПерПрц",    ENTRY(5, mProdPogOD), ?).
         IF NUM-ENTRIES(mProdPogOD) GT 5 THEN
         UpdateSigns(loan-cond.class-code, mSurrLCond, "int-mode",         ENTRY(6, mProdPogOD), ?).
         UpdateSigns(loan-cond.class-code, mSurrLCond, "int-offset",       mCredOffset,          ?).
         UpdateSigns(loan-cond.class-code, mSurrLCond, "delay-offset-int", mDelayOffset,         ?).
         IF {assigned mAnnuPl } THEN
         UpdateSigns(loan-cond.class-code, mSurrLCond, "АннуитПлат",       mAnnuPl,              ?).
      END.
   END.
END PROCEDURE.
   /* ================================================================---== */
   /* Расчитывать проценты для выноса на просрочку по алгоритму ОдинБанка ? */
FUNCTION FUseAlgOdin RETURNS LOG(
   INPUT iContract AS CHAR,   /* Назначение договора */     
   INPUT iContCode AS CHAR,   /* Номер договора */     
   INPUT iDate     AS DATE    /* На дату */
   ):
   DEF VAR oReturn         AS LOG  NO-UNDO.  
   DEF VAR vSurr           AS CHAR NO-UNDO.
   DEF VAR vProbegNextPlan AS CHAR NO-UNDO.
   DEF VAR vProbegNextFull AS CHAR NO-UNDO. 
      /* Локализация буфера */
   DEF BUFFER b-loan-cond FOR loan-cond.
      /* Поиск последнего условия действующего на дату iDate */
   FIND LAST b-loan-cond WHERE
             b-loan-cond.contract  EQ iContract
      AND    b-loan-cond.cont-code EQ iContCode
      AND    b-loan-cond.since     LE iDate
   NO-LOCK NO-ERROR.
      /* Получим значения логических ДР (с учетом начального значения) 
      ** ProbegNextPlan и ProbegNextFull найденного условия договора */
   IF AVAIL b-loan-cond THEN
      ASSIGN
         vSurr           = b-loan-cond.contract + "," + 
                           b-loan-cond.cont-code + "," + 
                           STRING(b-loan-cond.since)
         vProbegNextPlan = GetXattrValueEx("loan-cond", 
                                           vSurr, 
                                           "ProbegNextPlan", 
                                           GetXattrInit(b-loan-cond.class-code, 
                                                        "ProbegNextPlan"))
         vProbegNextFull = GetXattrValueEx("loan-cond", 
                                           vSurr, 
                                           "ProbegNextFull", 
                                           GetXattrInit(b-loan-cond.class-code, 
                                                        "ProbegNextFull"))
         oReturn         = IF    (vProbegNextFull EQ "ДА"
                              AND vProbegNextPlan EQ "ДА")
                              THEN TRUE
                              ELSE FALSE
      . 
   RETURN oReturn.
END FUNCTION.


   /* ===================================================-=-==--=== */
   /* Сумма процентов, в валюте договора, которую нужно вынести на 
   ** просрочку на переданную дату по переданному параметру        */
PROCEDURE PSumDelayProc:
   DEF INPUT  PARAM iContract AS CHAR NO-UNDO.   /* Назначение договора */     
   DEF INPUT  PARAM iContCode AS CHAR NO-UNDO.   /* Номер договора */     
   DEF INPUT  PARAM iDate     AS DATE NO-UNDO.   /* На дату */
   DEF INPUT  PARAM iParam    AS INT64  NO-UNDO.   /* Параметр для определения непогашенного остатка */
   DEF OUTPUT PARAM oSum      AS DEC  NO-UNDO.   /* Сумма %% на просрочку  */
      /* Объявление переменных */
   DEF VAR vSumm-t            AS DEC  NO-UNDO. /* Сумма непогашенного остатка по %% */
   DEF VAR vListOper          AS CHAR NO-UNDO. /* Список операций НП ProbegNext/ОплатПроц */
   DEF VAR vListParamOst      AS CHAR NO-UNDO. /* Список параметров остатков НП ProbegNext/СуммаПроц */  
   DEF VAR vListParamPr       AS CHAR NO-UNDO. /* Список параметров просрочки НП ProbegNext/ПроцПр */  
   DEF VAR vParams            AS CHAR NO-UNDO. /* Настройка для определения остатка на параметре НП ProbegNext/ОстПр */  
   DEF VAR vParamsList        AS CHAR NO-UNDO EXTENT 2. /* Список параметров в настройке vParams и их настроек */
   DEF VAR vParamsLstT        AS CHAR NO-UNDO EXTENT 2. /* Список значений параметров в настройке и их знаки */
   DEF VAR vDatePog           AS DATE NO-UNDO. /* Дата последнего гашения %% в пред.периоде */
   DEF VAR vSumParamOst       AS DEC  NO-UNDO. /* Сумма остатков на параметрах vListParamOst */
   DEF VAR vSumParamPr        AS DEC  NO-UNDO. /* Сумма остатков на параметрах vListParamPr */
   DEF VAR vSumParam          AS DEC  NO-UNDO. /* Сумма остатков на параметрах vParams */
   DEF VAR vSum               AS DEC  NO-UNDO. /* Остаток на параметре */
   DEF VAR vDbSum             AS DEC  NO-UNDO.
   DEF VAR vCrSum             AS DEC  NO-UNDO.
   DEF VAR vI                 AS INT64  NO-UNDO.
   DEF VAR vJ                 AS INT64  NO-UNDO.
   DEF VAR vParamsT           AS CHAR NO-UNDO.
   DEF VAR vPredDate          AS DATE NO-UNDO. /* Дата предыдущего планового платежа */
      /* Локализация буферов */
   DEF BUFFER b-loan     FOR loan.
   DEF BUFFER b-loan-int FOR loan-int.
   DEF BUFFER x-loan-int FOR loan-int.
   DEF BUFFER b-term-obl FOR term-obl.
   DEF BUFFER x-term-obl FOR term-obl.
   DEF BUFFER b-chowhe   FOR chowhe.
   DEF BUFFER x-chowhe   FOR chowhe.

      /* Поиск договора */
   FIND FIRST b-loan WHERE 
              b-loan.contract  EQ iContract
      AND     b-loan.cont-code EQ iContCode
   NO-LOCK NO-ERROR.
   IF AVAIL b-loan THEN
   DO:
      /* Ищем последний плановый платеж по процентам на дату iDate */
      FIND LAST b-term-obl WHERE 
                b-term-obl.contract  EQ iContract
         AND    b-term-obl.cont-code EQ iContCode
         AND    b-term-obl.idnt      EQ 1
         AND    b-term-obl.end-date  LE iDate
      NO-LOCK NO-ERROR.
      IF AVAIL b-term-obl THEN
      DO:
            /* Корректируем iDate датой найденного планового обязательства */
         iDate = b-term-obl.end-date.
            /* Определим список параметров, для расчета остатка по процентам */
         vListParamOst = REPLACE(FGetSettingEx("ProbegNext", "СуммаПроц", "", NO), " ", "").
            /* Расcчитываем непогашенный остаток по процентам на плановую дату */
         RUN summ-t1.p (OUTPUT vSumm-t,
                        RECID(b-term-obl),
                        RECID(b-loan)).
         IF b-term-obl.amt-rub GT vSumm-t THEN
         DO:
            /* Определим дату последнего гашения процентов по предыдущем периоде - vDatePog. */
               /* Получим список операций оплаты %% */
            vListOper = REPLACE(FGetSettingEx("ProbegNext", "ОплатПроц", "", NO), " ", "").
               /* Сначала ищем предыдущий плановый платеж по договору относительно текущего планового платежа */
            FIND LAST x-term-obl WHERE 
                      x-term-obl.contract  EQ iContract
               AND    x-term-obl.cont-code EQ iContCode
               AND    x-term-obl.idnt      EQ 1
               AND    x-term-obl.end-date  LT b-term-obl.end-date
            NO-LOCK NO-ERROR.
            vPredDate = IF AVAIL x-term-obl 
                           THEN x-term-obl.end-date /* Определим дату предыдущего планового платежа */
                           ELSE b-loan.open-date.   /* Если его нет, то берем дату открытия договора */
               /* Запускаем цикл по списку операций погашения процентов vListOper (НП ProbegNext/ОплатПроц) */
            DO vI = 1 TO NUM-ENTRIES(vListOper):
                  /* Сначала идет основная операция (ENTRY(1)), если есть парные, то они следуют через слэш */
               FIND FIRST b-chowhe WHERE
                          b-chowhe.id-op EQ INT64(ENTRY(1, ENTRY(vI, vListOper), "/"))
               NO-LOCK NO-ERROR.
               IF AVAIL b-chowhe THEN
               DO:
                     /* Проверяем была ли такая операция в период с vPredDate по b-term-obl.end-date */
                  BLK:
                  FOR EACH b-loan-int WHERE 
                           b-loan-int.contract  EQ b-loan.contract
                     AND   b-loan-int.cont-code EQ b-loan.cont-code
                     AND   b-loan-int.id-d      EQ b-chowhe.id-d
                     AND   b-loan-int.id-k      EQ b-chowhe.id-k
                     AND   b-loan-int.mdate     GT vPredDate
                     AND   b-loan-int.mdate     LE b-term-obl.end-date
                  NO-LOCK 
                  BY b-loan-int.mdate DESCENDING:
                     IF NUM-ENTRIES(ENTRY(vI, vListOper), "/") EQ 1 THEN
                     DO:       
                           /* Клиент таки заглянул в банк для погашения %% */
                        vDatePog = b-loan-int.mdate.
                        LEAVE BLK.
                     END.
                     ELSE
                     DO:
                           /* Ищем хотя бы одну парную операцию из списка, например "100/10/46"
                           ** для операции 100 это парные 10 или 46 */
                        DO vJ = 2 TO NUM-ENTRIES(ENTRY(vI, vListOper), "/"):
                           FIND FIRST x-chowhe WHERE
                                      x-chowhe.id-op EQ INT64(ENTRY(vJ, ENTRY(vI, vListOper), "/"))
                           NO-LOCK NO-ERROR.
                           IF AVAIL x-chowhe THEN
                           DO:
                                 /* Проверяем была ли парная операция за дату b-loan-int.mdate */
                              FIND FIRST x-loan-int WHERE 
                                         x-loan-int.contract  EQ b-loan.contract
                                 AND     x-loan-int.cont-code EQ b-loan.cont-code
                                 AND     x-loan-int.id-d      EQ x-chowhe.id-d
                                 AND     x-loan-int.id-k      EQ x-chowhe.id-k
                                 AND     x-loan-int.mdate     EQ b-loan-int.mdate
                              NO-LOCK NO-ERROR.
                              IF AVAIL x-loan-int THEN
                              DO:
                                 vDatePog = b-loan-int.mdate.
                                 LEAVE BLK.
                              END.
                           END.
                        END.
                     END.
                  END.
               END.
            END. /* vDatePog */

               /* Если не найдено ни одного гашения, то возвращаем сумму непогашенного остатка   */
            IF vDatePog NE ? THEN
               oSum = vSumm-t.

               /* Значит клиент что-то гасил из процентов в этом периоде */
            ELSE
            DO:
                  /* Суммируем остатки по параметрам на дату vDatePog. */
               DO vI = 1 TO NUM-ENTRIES(vListParamOst):
                  RUN STNDRT_PARAM (iContract, 
                                    iContCode,
                                    INT64(ENTRY(vI, vListParamOst)),
                                    vDatePog,
                                    OUTPUT vSum,
                                    OUTPUT vDbSum,
                                    OUTPUT vCrSum).
                  vSumParamOst = vSumParamOst + vSum.
               END.
               IF vSumParamOst GE 0 THEN
                  oSum = vSumParamOst.
            END.
         END.
         
            /* Вся задолженность непогашена */
         ELSE
         DO:
            /* Сумма просрочки = сумма всех непогашенных на плановую дату процентов по графику (с учетом всех непогашенных сумм за прошлые даты 
            ** в  графике, если эти  суммы есть) за вычетом остатка на ПДТР по  уже отражённой на счетах просрочке */
               /* Суммируем остатки по параметрам на дату iDate. */
            DO vI = 1 TO NUM-ENTRIES(vListParamOst):
               RUN STNDRT_PARAM (iContract, 
                                 iContCode,
                                 INT64(ENTRY(vI, vListParamOst)),
                                 iDate,
                                 OUTPUT vSum,
                                 OUTPUT vDbSum,
                                 OUTPUT vCrSum).
               vSumParamOst = vSumParamOst + vSum.
            END.
            IF vSumParamOst NE 0 THEN
                  /* Значит, что не все проценты на дату погашения оплачены */ 
               oSum = vSumParamOst.
         END.

         IF oSum GT 0 THEN
         DO:
            ASSIGN
                  /* Получим список параметров просрочки */
               vListParamPr = REPLACE(FGetSettingEx("ProbegNext", "ПроцПр", "", NO), " ", "")
                  /* Получим настройку для определения непогашенного остатка на параметре */
               vParams      = REPLACE(FGetSettingEx("ProbegNext",  "ОстПр", "", NO), " ", "")
            .
               /* Суммируем остатки по параметрам на дату iDate. */
            DO vI = 1 TO NUM-ENTRIES(vListParamPr):
               RUN STNDRT_PARAM (iContract,
                                 iContCode,
                                 INT64(ENTRY(vI, vListParamPr)),
                                 iDate,
                                 OUTPUT vSumParamPr,
                                 OUTPUT vDbSum,
                                 OUTPUT vCrSum).
                  /* Уменьшим полученную сумму просрочки oSum на сумму, уже вынесенную на просрочку */ 
               oSum = oSum - vSumParamPr.
            END.

               /* Создаем список параметров настроки vParams, в значении которого,
               ** может находиться список через ";", а значение параметра составное (список параметров со знаком).
               ** Например "4=4;33=33+34+35-77".*/
            DO vI = 1 TO NUM-ENTRIES(vParams, ";"):
               IF NUM-ENTRIES(ENTRY(vI, vParams, ";"), "=") GT 1 THEN
                  ASSIGN 
                        /* Собственно, сами параметры, из примера: "4,33" */
                     vParamsList[1] = vParamsList[1] + 
                                     (IF vParamsList[1] NE "" THEN "," ELSE "") + 
                                      ENTRY(1, ENTRY(vI, vParams, ";"), "=")
                        /* А тут будут их настройки - "4,33+34+35-77" */
                     vParamsList[2] = vParamsList[2] + 
                                     (IF vParamsList[2] NE "" THEN "," ELSE "") + 
                                      ENTRY(2, ENTRY(vI, vParams, ";"), "=")
                  .
            END.

            IF iParam NE -1 
            THEN DO:
                  /* Проверим, есть ли параметр iParam в списке vParamsList */
               vI = LOOKUP(STRING(iParam), vParamsList[1]).  
               IF vI GT 0 THEN
               DO:
                  ASSIGN 
                     vJ             = 1
                     vParamsT       = vParamsList[2] /* ENTRY(2, vParamsList[2]) */
                     vParamsLstT[1] = ""
                     vParamsLstT[2] = ""
                  .
                     /* Разбираемся со списком параметров в настройке */
                  DO vI = 1 TO NUM-ENTRIES(REPLACE(vParamsT, "-", "+"), "+"):
                     ASSIGN 
                           /* Сюда запишем список параметров, суммируемых для параметра iParam */
                        vParamsLstT[1] = vParamsLstT[1] + 
                                        (IF vParamsLstT[1] NE "" THEN "," ELSE "") + 
                                         ENTRY(vI, REPLACE(vParamsT, "-", "+"), "+")
                           /* Вычисляем позицию знака в строке */
                        vJ             = INDEX(vParamsT, (ENTRY(vI, REPLACE(vParamsT, "-", "+"), "+")), vJ)
                           /* А сюда список знаков (+/-) для этих параметров */
                        vParamsLstT[2] = vParamsLstT[2] + 
                                        (IF vParamsLstT[2] NE "" THEN "," ELSE "") + 
                                        (IF vJ LE 1 THEN "+" ELSE SUBSTR(vParamsT, vJ - 1, 1))
                     .
                  END.
                     /* Получим остаток на переданном параметре iParam, как сумму (учитывая знак) параметров, 
                     ** перечисленных после знака "=", на дату погашения iDate */
                  DO vI = 1 TO NUM-ENTRIES(vParamsLstT[1]):
                     RUN STNDRT_PARAM (iContract,
                                       iContCode,
                                       INT64(ENTRY(vI, vParamsLstT[1])),
                                       iDate,
                                       OUTPUT vSum,
                                       OUTPUT vDbSum,
                                       OUTPUT vCrSum).
                     vSumParam = vSumParam + (vSum * (IF ENTRY(vI, vParamsLstT[2]) EQ "-" THEN -1 ELSE 1)).
                  END.
               END.
               ELSE
               DO:
                     /* Просто получим остаток на переданном параметре iParam на дату iDate */
                  RUN STNDRT_PARAM (iContract,
                                    iContCode,
                                    iParam,
                                    iDate,
                                    OUTPUT vSumParam,
                                    OUTPUT vDbSum,
                                    OUTPUT vCrSum).
               END.
                  /* Корректируем сумму просрочки по процентам */
               oSum = MIN(oSum, vSumParam).
            END.
         END.
      END.
   END.
END PROCEDURE.

PROCEDURE pGetEpsLoan:
   DEF INPUT  PARAM iContract AS CHAR NO-UNDO.
   DEF INPUT  PARAM iContCode AS CHAR NO-UNDO.
   DEF INPUT  PARAM iDate     AS DATE NO-UNDO.
   DEF OUTPUT PARAM oEps      AS DEC  NO-UNDO.
   DEF OUTPUT PARAM oAddPay   AS LOG  NO-UNDO.

   RUN pGetEpsLoanEx IN THIS-PROCEDURE (iContract,
                                        iContCode,
                                        iDate,
                                        ?,
                                        OUTPUT oEps,
                                        OUTPUT oAddPay ).
   
END PROCEDURE.

PROCEDURE pGetEpsLoanEx:
   DEF INPUT  PARAM iContract AS CHAR NO-UNDO.
   DEF INPUT  PARAM iContCode AS CHAR NO-UNDO.
   DEF INPUT  PARAM iDate     AS DATE NO-UNDO.
   DEF INPUT  PARAM iTypeEPS  AS CHAR NO-UNDO.
   DEF OUTPUT PARAM oEps      AS DEC  NO-UNDO.
   DEF OUTPUT PARAM oAddPay   AS LOG  NO-UNDO.

   DEF VAR vAccur   AS DEC   NO-UNDO.
   DEF VAR vTryNum  AS INT64   NO-UNDO.
   DEF VAR vStep    AS DEC   NO-UNDO. /* Шаг, для наращивания ЭПС */
   DEF VAR flag     AS LOG   NO-UNDO. /* yes - увеличиваем, no - уменьшаем ЭПС */
   DEF VAR vI       AS INT64   NO-UNDO.
   DEF VAR vSummPay AS DEC   NO-UNDO. /* Общая сумма платежей */
   DEF VAR vBegDate AS DATE  NO-UNDO. /* Дата выдачи кредита  */
   DEF VAR vSumma   AS DEC   NO-UNDO. /* Сумма для подбора ЭПС */
   DEF VAR vInsurFl AS LOG   NO-UNDO. /* включать в расчет ЭПС страховые платежи? */
   DEF VAR vPer     AS INT64 NO-UNDO. /* Число дней в периоде */
   DEF VAR vSroc    AS INT64 NO-UNDO. /* Число дней от даты начала кредита */
   DEF VAR vZnamen  AS DEC   NO-UNDO. /* Знаменятель формулы */
   DEF VAR vEpsForm AS INT64 NO-UNDO. /* Число дней от даты начала кредита */
   DEF VAR vOkrPer  AS INT64 NO-UNDO. /* Точность округления числа периодов в году */
   DEF VAR vPerInY  AS DEC   NO-UNDO. /* Число периодов в году */
   
   DEF BUFFER loan FOR loan.
   
   ASSIGN
      /* Повысим точность, чтобы округлить с точность <= vAccur */
      vAccur   = dec(FGetSetting("ЭПС", "ЭПСТочн", ?)) 
      vTryNum = INT64(FGetSetting("ЭПС", "ЭПСКолП", ?))
      vInsurFl = FGetSetting("ЭПС", "ЭПСВклСтрахПл" , "") EQ "ДА"
      vOkrPer  = INT64(FGetSetting("ПСК229ФЗ", "ПСК229ОкрЧБП","0"))
   .
   BLCK:
   DO
   ON ERROR    UNDO BLCK, LEAVE BLCK:
      RUN RE_B_LOAN (iContract,iContCode,BUFFER loan).
      IF NOT AVAIL loan THEN LEAVE blck.
      ASSIGN
         vBegDate = loan.open-date 
         oEps = 0.1
         vStep = 0.1
         flag = YES
      .
      CASE iTypeEPS:
         WHEN "ЦБРеф" THEN
            RUN filleps-cbref.p (iContract, 
                                 iContCode, 
                                 iDate, 
                                 OUTPUT TABLE ttReportTable).
         OTHERWISE
            RUN filleps.p (iContract, 
                           iContCode, 
                           iDate, 
                           OUTPUT TABLE ttReportTable).
      END CASE.
      
      oAddPay = CAN-FIND (FIRST ttReportTable WHERE 
                                ttReportTable.tf_additional-charges GT 0 
                             OR ttReportTable.tf_actual-payment     GT 0
                          NO-LOCK).
      /* Определение по какой ф-ле делать расчет ЭПС:  1 - 353-ФЗ; 2 - 229-ФЗ */
      RUN GetEpsForm(iContract, iContCode, iDate, OUTPUT vEpsForm).
      CASE vEpsForm:
         WHEN 1 THEN
         DO:
            vPer = 365.
            
            FIND FIRST ttReportTable NO-LOCK NO-ERROR.
            
            IF AVAIL ttReportTable THEN
               vBegDate = ttReportTable.tf_payment-date.
         END.
         WHEN 2 THEN
            RUN GetBasePer(iContract,
                           iContCode,
                           iDate,
                           TABLE ttReportTable BY-REFERENCE,
                           OUTPUT vPer).
      END CASE.
      vPerInY = ROUND (365 / vPer, vOkrPer).
      DO vi=1 TO vTryNum:
         vSumma = 0.
         FOR EACH ttReportTable:
         ASSIGN
            vSummPay = ttReportTable.tf_sum-percent +
                       ttReportTable.tf_basic-sum-loan +
                       ttReportTable.tf_additional-charges
            vSummPay = vSummPay + ttReportTable.tf_actual-payment WHEN vInsurFl
               vSroc    = ttReportTable.tf_payment-date - vBegDate
         .
            CASE vEpsForm:
               WHEN 1 THEN
                  vZnamen = EXP((1 + oEps), vSroc / vPer)
                  NO-ERROR.
               WHEN 2 THEN
                  vZnamen = (1 + oEps * (vSroc MODULO vPer) / vPer) *
                             EXP((1 + oEps), TRUNCATE (vSroc / vPer , 0))
                  NO-ERROR.
            END CASE.
            IF ERROR-STATUS:ERROR THEN
            DO:
               {puttolog.i 
                   &mes    = "'Договор №: ' + iContCode + '. Расчет ПСК невозможен.'"
                   &stream = " stream vStream "
               }
            END.
            vSumma   = vSumma + vSummPay / vZnamen.
         END.
         IF vSumma LT 0 AND flag EQ YES THEN
         DO:
            flag  = NO.
            vStep = vStep / 3.
         END.
         IF vSumma GT 0 AND flag EQ NO THEN
         DO:
            flag = YES.
            vStep = vStep / 3.
         END.
         IF (vStep * vPerInY) GE vAccur THEN  DO: /* !! */
            IF flag EQ YES THEN
               oEps = oEps + vStep.
            ELSE 
               oEps = oEps - vStep.
         END.
         ELSE LEAVE blck.
      END.
   END. /* blck */
   {puttolog.i
      &mes    = "'Договор №: ' + iContCode + '. Расчет ПСК.'"
      &stream = " stream vStream "
   }
   {puttolog.i
      &mes    = "'i = ' + STRING(oEps)"
      &stream = " stream vStream "
   }
   {puttolog.i
      &mes    = "'НП ПСК229ОкрЧБП = ' + STRING(vOkrPer)"
      &stream = " stream vStream "
   }
   {puttolog.i
      &mes    = "'ЧБП = ' + STRING(vPerInY)"
      &stream = " stream vStream "
   }
   oEps = oEps * vPerInY.
   /* Округлим с точность <= vAccur, т.е. значение vAccur из НП округлится до 0 */
   oEps = ROUND( oEps / vAccur, 0) * vAccur.
   IF oEps LT 0 THEN
   DO: 
   /* =============== fev =============== */
   /* RUN Fill-SysMes ("","","","Отрицательное значение ЭПС будет заменено нулем"). */
   /* =============== end =============== */
      oEps = 0.
   END.
   {puttolog.i
      &mes    = "'ПСК = ' + STRING(oEps)"
      &stream = " stream vStream "
   }
END PROCEDURE.

FUNCTION GetEpsLoanEx RETURNS DEC
  (iContract  AS CHAR,  /*назначение*/
   iContCode  AS CHAR,  /*номер договора*/
   iDate      AS DATE,
   iTypeEPS   AS CHAR):

   DEF VAR vEps    AS DEC NO-UNDO. /* ЕПС */
   DEF VAR vAddPay AS LOG NO-UNDO.

   RUN pGetEpsLoanEx (iContract,
                      iContCode,
                      iDate,
                      iTypeEPS,
                      OUTPUT vEps,
                      OUTPUT vAddPay).
   RETURN vEps.
END FUNCTION.

FUNCTION GetEpsLoan RETURNS DEC
  (iContract  AS CHAR,  /*назначение*/
   iContCode  AS CHAR,  /*номер договора*/
   iDate      AS DATE):

   DEF VAR vEps    AS DEC NO-UNDO. /* ЕПС */

   vEps = GetEpsLoanEx (iContract,
                        iContCode,
                        iDate,
                        ?).
   
   RETURN vEps.
END FUNCTION.

FUNCTION GetRoundEpsLoanEx RETURNS CHAR
  (iClassCode AS CHAR,  /* Класс */
   iEps       AS DEC,
   iCode      AS CHAR):

   DEF VAR vEps AS CHAR NO-UNDO.

   DEF BUFFER xattr FOR xattr.

   RUN GetXAttr IN h_xclass (iClassCode, iCode, BUFFER Xattr).
   
   IF NOT AVAIL Xattr THEN
      RETURN STRING(iEps).      
   
   vEps = TRIM(STRING(iEps, Xattr.Data-Format)).

   RETURN vEps.
END FUNCTION.

   /* Функция округления ЭПС до формата
      заданного на классе договора */
FUNCTION GetRoundEpsLoan RETURNS CHAR
  (iClassCode AS CHAR,  /* Класс */
   iEps       AS DEC):      
   
   DEF VAR vEps AS CHAR NO-UNDO.
   
   vEps = GetRoundEpsLoanEx (iClassCode,
                             iEps,
                             "ЭПС").

   RETURN vEps.
END FUNCTION.
   /* вычисление суммы комиссии на дату по договору */
PROCEDURE CalcCommLoan:
   
   DEF INPUT  PARAM iContract AS CHAR NO-UNDO.
   DEF INPUT  PARAM iContCode AS CHAR NO-UNDO.
   DEF INPUT  PARAM iComm     AS CHAR NO-UNDO.
   DEF INPUT  PARAM iBegDate  AS DATE NO-UNDO.
   DEF INPUT  PARAM iEndDate  AS DATE NO-UNDO.
   DEF OUTPUT PARAM oSum      AS DEC  NO-UNDO.

   RUN lncommshsum.p (OUTPUT oSum, iContract, iContCode, iComm, iBegDate, iEndDate,NO).

END PROCEDURE.

/* Определение суммы лимита по условиям */
PROCEDURE GetLCondSumm:
    DEF INPUT  PARAM iContract AS CHARACTER NO-UNDO.
    DEF INPUT  PARAM iContCode AS CHARACTER NO-UNDO.
    DEF INPUT  PARAM iDate     AS DATE NO-UNDO.
    DEF OUTPUT PARAM oSumm     AS DECIMAL NO-UNDO.

    DEF VAR vPayType AS CHARACTER NO-UNDO. /* тип условия */
    DEF VAR vPaySum  AS DECIMAL   NO-UNDO. /* доп. сумма на условии */
    
    FOR EACH loan-cond WHERE 
             loan-cond.contract = iContract
         AND loan-cond.cont-code = iContCode
         AND loan-cond.since <= iDate
         NO-LOCK:

        ASSIGN
            vPayType = GetXattrValueEx("loan-cond",
                                       loan-cond.contract 
                                       + "," + loan-cond.cont-code 
                                       + "," + STRING(loan-cond.since),
                                       "PayType",
                                       "")
            vPaySum = DEC(GetXattrValueEx("loan-cond",
                                          loan-cond.contract 
                                          + "," + loan-cond.cont-code 
                                          + "," + STRING(loan-cond.since),
                                          "PaySum",
                                          "0"))
                .
         
         IF vPaySum = 0 THEN DO:
             FIND LAST term-obl WHERE 
                       term-obl.contract = iContract
                   AND term-obl.cont-code = iContCode
                   AND term-obl.idnt = 2
                   AND term-obl.end-date <= loan-cond.since
                 NO-LOCK NO-ERROR.
             IF AVAIL term-obl THEN 
                vPaySum = term-obl.amt-rub.
         END.

         IF vPayType = "Выдача" 
            THEN oSumm = oSumm + vPaySum.
         ELSE IF vPayType = "Погашение" 
                 OR vPayType = "ДосрПогаш"             
            THEN oSumm = oSumm - vPaySum.    
         /*ELSE IF vPayType = "Остаток"                  
            THEN oSumm = vPaySum.  */
         ELSE IF oSumm = 0 THEN oSumm = vPaySum.
    END.


END PROCEDURE.

PROCEDURE GetSumLoanInt:
   DEF INPUT  PARAM iContract AS CHAR NO-UNDO. /* назначение */
   DEF INPUT  PARAM iContCode AS CHAR NO-UNDO. /* номер договора */
   DEF INPUT  PARAM iChowhe   AS INT64  NO-UNDO. /* номер операции */
   DEF INPUT  PARAM iBegDate  AS DATE NO-UNDO. /* дата начала */
   DEF INPUT  PARAM iEndDate  AS DATE NO-UNDO. /* дата конца */
   DEF OUTPUT PARAM oSumInt   AS DEC  NO-UNDO. /* сумма операций */

   DEFINE BUFFER loan     FOR loan.     /* Локализация буфера. */
   DEFINE BUFFER chowhe   FOR chowhe.   /* Локализация буфера. */
   DEFINE BUFFER loan-int FOR loan-int. /* Локализация буфера. */

   FIND FIRST loan WHERE loan.contract  EQ iContract
                     AND loan.cont-code EQ iContCode
      NO-LOCK NO-ERROR.
   IF AVAIL loan 
   THEN DO:
      FIND FIRST chowhe WHERE chowhe.id-op = ichowhe 
         NO-LOCK NO-ERROR.
      IF AVAIL chowhe THEN
      DO:  
         FOR EACH loan-int WHERE loan-int.contract  EQ loan.contract
                             AND loan-int.cont-code EQ loan.cont-code
                             AND loan-int.id-d      EQ chowhe.id-d
                             AND loan-int.id-k      EQ chowhe.id-k 
                             AND loan-int.mdate     GE iBegDate
                             AND loan-int.mdate     LE iEndDate
         NO-LOCK:
            oSumInt = oSumInt + loan-int.amt-rub.
         END.
      END.
   END.
END PROCEDURE.

/* Процедура расчета плавающей ставки по данным из правила */
PROCEDURE CalcCommCondRate.
   DEF INPUT PARAM iContract    AS CHAR NO-UNDO. /* Назначение договора */
   DEF INPUT PARAM iContCode    AS CHAR NO-UNDO. /* Номер догвоора */
   DEF INPUT PARAM iCommission  AS CHAR NO-UNDO. /* Код ставки */
   DEF INPUT PARAM iDate        AS DATE NO-UNDO. /* Дата */
   DEF OUTPUT PARAM oDateChange AS DATE NO-UNDO. /* Ближайшая плановая дата смены ставки */
   DEF OUTPUT PARAM oBaseRate   AS DEC  NO-UNDO. /* Базовая ставка на дату смены */
   DEF OUTPUT PARAM oRate       AS DEC  NO-UNDO. /* Ставка */

   DEF VAR vBegDate  AS DATE NO-UNDO. /* Дата, от которой считаем */
   DEF VAR vDateReal AS DATE NO-UNDO. /* Дата, от которой считаем */
   DEF VAR vMoveDay  AS INT64  NO-UNDO. /* Количество дней на которое двигаем */
   DEF VAR vMoveMon  AS INT64  NO-UNDO. /* Количество месяцев на которое двигаем */
   DEF VAR vMoveYear AS INT64  NO-UNDO. /* Количество лет на которое двигаем */
   DEF VAR vChDate   AS DATE NO-UNDO. /* Искомая, ближайшая дата смены ставки */
   DEF VAR vKvartN   AS INT64  NO-UNDO.
   DEF VAR vQuant    AS INT64  NO-UNDO.
   DEF VAR vNDS      AS DECIMAL NO-UNDO. /* множитель НДС */
   DEF VAR vNDSAct   AS CHARACTER NO-UNDO. /* действие с НДС */
   DEF VAR vSurr     AS CHARACTER NO-UNDO. /* суррогат comm-cond */

   DEF BUFFER loan      FOR loan.      /* Локализация буфера */
   DEF BUFFER comm-rate FOR comm-rate. /* Локализация буфера */

   mb:
   DO ON ERROR UNDO, LEAVE:
      
      /* Сначала ищем договор */
      FIND FIRST loan WHERE loan.contract  EQ iContract
                        AND loan.cont-code EQ (IF mPlasStavTransh 
                                               THEN ENTRY(1,iContCode," ") 
                                               ELSE         iContCode
                                              )
      NO-LOCK NO-ERROR.
      IF NOT AVAIL loan THEN
      DO:
         RUN Fill-SysMes IN h_tmess ("","","0","Не найден договор для расчета плавающей ставки.").
         LEAVE mb.
      END.

      /* Ищем правило расчета плавающей ставки */
      FIND LAST comm-cond WHERE comm-cond.contract   EQ iContract
                            AND comm-cond.cont-code  EQ iContCode
                            AND comm-cond.commission EQ iCommission
                            AND comm-cond.since      LE iDate
      NO-LOCK NO-ERROR.

      /* Если не найден - вываливаемся */
      IF   NOT AVAIL comm-cond 
        OR ( AVAIL comm-cond 
        AND NOT comm-cond.FloatType ) THEN
         LEAVE mb.
      
      /* Отсчет ведем от даты ввода действующего условия расчета 
      ** плавающей ставки (найденный comm-cond)
      ** Тепрь на основании полей 
      ** Period - периодичность
      ** Delay - сдвиг в рабочих днях (минус полученная дата)
      ** Quantity - длительность периода (кол-во периодов) 
      ** Day - день в периоде 
      ** Month - месяц в периоде, если это Квартал,Полугод или Год 
      ** расчитываем на какой период надо будет двигать дату */
      
      CASE comm-cond.period:
         WHEN "ГД" THEN
            ASSIGN
               vBegDate  = DATE(IF comm-cond.month NE 0 AND comm-cond.month < 13 THEN comm-cond.month ELSE MONTH(loan.open-date),
                               IF comm-cond.day NE 0 THEN comm-cond.day ELSE DAY(loan.open-date),
                               YEAR(comm-cond.since))
               vMoveYear = 1.
         WHEN "КД" THEN
            ASSIGN
               vBegDate = DATE(IF comm-cond.month NE 0 AND comm-cond.month < 3 THEN comm-cond.month ELSE MONTH(loan.open-date),
                               IF comm-cond.day NE 0 THEN comm-cond.day ELSE DAY(loan.open-date),
                               YEAR(loan.open-date))
               vMoveMon = 3.
         WHEN "МД" THEN
            ASSIGN
               vBegDate = DATE(MONTH(loan.open-date),
                               IF comm-cond.day NE 0 THEN comm-cond.day ELSE DAY(loan.open-date),
                               YEAR(loan.open-date))
               vMoveMon = 1.
         WHEN "НД" THEN
            ASSIGN
               vBegDate = loan.open-date
               vMoveDay = 7.
         WHEN "Г" THEN /* от начала календарного года */
            ASSIGN
               vBegDate = DATE(IF comm-cond.month NE 0 AND comm-cond.month < 13 THEN comm-cond.month ELSE 1,
                               IF comm-cond.day NE 0 THEN comm-cond.day ELSE 1,
                               YEAR(comm-cond.since))
               vMoveYear = 1.
         WHEN "Д" THEN
            ASSIGN
               vBegDate = comm-cond.since /* Ежедневно */
               vMoveDay = 1.
         WHEN "К" THEN
         DO:
            vKvartN = MONTH(comm-cond.since).
            IF CAN-DO("1,2,3",STRING(MONTH(comm-cond.since))) THEN
               vKvartN = IF comm-cond.month NE 0 AND comm-cond.month < 4 THEN 1 + comm-cond.month
                                                                         ELSE 1.
            IF CAN-DO("4,5,6",STRING(MONTH(comm-cond.since))) THEN
               vKvartN = IF comm-cond.month NE 0 AND comm-cond.month < 4 THEN 4 + comm-cond.month
                                                                         ELSE 4.
            IF CAN-DO("7,8,9",STRING(MONTH(comm-cond.since))) THEN
               vKvartN = IF comm-cond.month NE 0 AND comm-cond.month < 4 THEN 7 + comm-cond.month
                                                                         ELSE 7.
            IF CAN-DO("10,11,12",STRING(MONTH(comm-cond.since))) THEN
               vKvartN = IF comm-cond.month NE 0 AND comm-cond.month < 4 THEN 10 + comm-cond.month
                                                                         ELSE 10.
            ASSIGN
               vBegDate = DATE(vKvartN,1,YEAR(comm-cond.since)) /* от начала календарного квартала */
               vMoveMon = 3.
         END.
         WHEN "М" THEN
            ASSIGN
               vBegDate = DATE(MONTH(comm-cond.since),
                               IF comm-cond.day NE 0 THEN comm-cond.day ELSE 1,
                               YEAR(comm-cond.since)) /* от начала календарного месяца */
               vMoveMon = 1.
         WHEN "Н" THEN
         DO:
            DO WHILE WEEKDAY(vBegDate) NE 2: /* по weekday - понедельник = 2 */
               vBegDate = vBegDate + 1.
            END.
            vMoveDay = 7.
         END.
      END CASE.
      /* Количество периодов */
      vQuant = IF comm-cond.quantity EQ 0 THEN 1
                                          ELSE comm-cond.quantity.
      
      /* Т.к. у нас задано кол-во периодов, то независимо от того, превышает ли искомая дата
      ** введенную, надо сделать количество определенных итераций.
      ** например для изменения ставки каждые 2 месяца, ставится периодичность "М"-ежемесяцчно,
      ** а поле Quantity = 2...*/
      whl:
      DO WHILE vBegDate <= iDate:
         IF vBegDate EQ iDate THEN
            LEAVE whl.
         
         /* Если за первый цикл сдвига не нашли искомую дату, повторяем цикл */
         IF vQuant EQ 0 THEN
            vQuant = comm-cond.quantity.
         
         IF comm-cond.quantity NE 0 THEN
         DO:
            DO WHILE vQuant NE 0:
               vBegDate = GoMonth(vBegDate,vMoveYear * 12 + vMoveMon) + vMoveDay.
               vQuant = vQuant - 1.
            END.
         END.
         ELSE
            vBegDate = GoMonth(vBegDate,vMoveYear * 12 + vMoveMon) + vMoveDay.
      END.

      IF vBegDate NE ? THEN
         oDateChange = vBegDate.
      
      vSurr   = GetSurrogateBuffer("comm-cond", BUFFER comm-cond:HANDLE).
      vNDS    = DECIMAL(GetXAttrValueEx("comm-cond", vSurr, "НДС", "0")) NO-ERROR.
      vNDSAct = GetXAttrValueEx("comm-cond", vSurr, "НДСДейств", "").
      RUN CalcFloatRate (iContract,
                         iContCode,
                         comm-cond.source,
                         IF comm-cond.source EQ "Общие ставки" THEN comm-cond.BaseCode
                                                               ELSE comm-cond.commission,
                         oDateChange,
                         comm-cond.action,
                         comm-cond.BaseChange,
                         IF iDate EQ loan.open-date THEN 
                            comm-cond.firstdelay
                         ELSE
                            comm-cond.delay,
                         OUTPUT vDateReal,
                         OUTPUT oBaseRate,
                         OUTPUT oRate).
      /* НДС учитывается только для договоров факторинга */
      IF     vNDS      NE ?
         AND vNDS      GT 0
         AND iContract EQ "factor" THEN
      DO:
         CASE vNDSAct:
            WHEN "*" THEN
               oRate = oRate * vNDS.
         END CASE.
      END.
   END. /* mb: */

END PROCEDURE.

/* Процедура расчета значения плавающей ставки */
PROCEDURE CalcFloatRate.

   DEF INPUT PARAM iContract   AS CHAR NO-UNDO. /* Назначение договора */
   DEF INPUT PARAM iContCode   AS CHAR NO-UNDO. /* Номер догвоора */
   DEF INPUT PARAM iSource     AS CHAR NO-UNDO. /* Источник - из ставок базового модуля или кредитного договора */
   DEF INPUT PARAM iBaseCode   AS CHAR NO-UNDO. /* Код базовой ставки */
   DEF INPUT PARAM iDate       AS DATE NO-UNDO. /* Дата */
   DEF INPUT PARAM iAction     AS CHAR NO-UNDO. /* Действие - "+,-,*,/"*/
   DEF INPUT PARAM iBaseChange AS DEC  NO-UNDO. /* Величина, на которую изменяется базовая ставка */
   DEF INPUT PARAM iFirstDelay AS INT64 NO-UNDO. /* Сдвиг первоначальной даты (для общих ставок) */
   DEF OUTPUT PARAM oDateChange AS DATE NO-UNDO. /* Дата смены ставки */
   DEF OUTPUT PARAM oBaseRate   AS DEC  NO-UNDO. /* Базовая ставка на дату смены */
   DEF OUTPUT PARAM oRate       AS DEC  NO-UNDO. /* Результат (модифицированная ставка) */

   DEF VAR vWorkGraf   AS CHARACTER NO-UNDO.
   DEF VAR vCurr       AS CHARACTER NO-UNDO.
   DEF VAR vSurr       AS CHARACTER NO-UNDO.
   DEF VAR vDelay      AS INT64     NO-UNDO.
   DEF VAR vWork       AS LOGICAL   NO-UNDO INITIAL YES.
   DEF VAR vI          AS INT64     NO-UNDO.

   DEF BUFFER loan FOR loan. /* Локализация буфера */

   mb:
   DO ON ERROR UNDO, LEAVE:
      ASSIGN
         vWorkGraf   = FGetSetting("ГрафикПС","","")     
         oDateChange = iDate
      .

      IF iSource EQ "Из договора" THEN
      DO:
         /* Ищем договор */
         FIND FIRST loan WHERE loan.contract  EQ iContract
                           AND loan.cont-code EQ iContCode
         NO-LOCK NO-ERROR.

         /* Если не найден - вываливаемся */
         IF NOT AVAIL loan THEN
         DO:
            RUN Fill-SysMes IN h_tmess ("","","0","Не найден договор для расчета плавающей ставки.").
            LEAVE mb.
         END.
         /* по договору базовая ставка на утро */
         oBaseRate = GET_COMM (iBaseCode,
                               ?,
                               loan.currency,
                               loan.contract + "," + loan.cont-code,
                               0.00, 
                               0, 
                               oDateChange - 1 ).
      END.
      ELSE DO:

         DC:
         DO WHILE iFirstDelay GT 0 :
               
            ASSIGN
               iFirstDelay  = iFirstDelay - 1.

            IF vWorkGraf NE "" THEN DO:                 
               ASSIGN
                 oDateChange = oDateChange - 1 
                 vWork       = IsWorkDayGraf (oDateChange, vWorkGraf).
                 
                
               DO WHILE vWork EQ NO:
                  ASSIGN
                     oDateChange = oDateChange - 1 
                     vWork       = IsWorkDayGraf (oDateChange, vWorkGraf).                    
               END.
               IF vWork EQ ? THEN DO:
               	  oDateChange = ? . 
               	  RETURN .
               END.	  
            END.   
            ELSE
               oDateChange = PrevWorkDay(oDateChange).
           

         END.
                  
         oBaseRate = GET_COMM (iBaseCode,
                               ?,
                               "",
                               "",
                               0.00, 
                               0, 
                               oDateChange ).
      END.
    	                         
      CASE iAction:
         WHEN "+" THEN
            oRate = oBaseRate + iBaseChange.
         WHEN "-" THEN
            oRate = oBaseRate - iBaseChange.
         WHEN "*" THEN
            oRate = oBaseRate * iBaseChange.
         WHEN "/" THEN
            oRate = oBaseRate / iBaseChange.
      END CASE.
   END. /* mb: */

END PROCEDURE.

   /* Нахождение полной стоимости кредита */
FUNCTION GetPSKLoan RETURNS DEC
  (iContract  AS CHAR,  /*назначение*/
   iContCode  AS CHAR,  /*номер договора*/
   iDate      AS DATE):

   DEF VAR vPsk    AS DEC NO-UNDO. /* ПСК */

   RUN filleps.p (iContract, iContCode, iDate, OUTPUT TABLE ttReportTable).

   FOR EACH ttReportTable:
      vPsk = vPsk + ttReportTable.tf_sum-percent +
                    ttReportTable.tf_basic-sum-loan +
                    ttReportTable.tf_additional-charges.
   END.    

   FIND FIRST term-obl WHERE term-obl.contract  EQ iContract
                         AND term-obl.cont-code EQ iContCode
                         AND term-obl.idnt      EQ 2
                       NO-LOCK NO-ERROR.

   vPsk = vPsk + term-obl.amt-rub.

   RETURN vPsk.
END FUNCTION.

   /* Процедура определения ведения операций на транше 
   ** если oOk = TRUE,  тогда операции ведутся на транше,
   ** если oOk = FALSE, тогда операции не ведутся на транше */
PROCEDURE CHECK_CHOWHE_TRANSH:
   DEF INPUT  PARAMETER iContract AS CHAR      NO-UNDO. /* Назначение договора */
   DEF INPUT  PARAMETER iContCode AS CHAR      NO-UNDO. /* Номер договора      */
   DEF INPUT  PARAMETER iAcctType AS CHAR      NO-UNDO. /* Роль счета          */
   DEF OUTPUT PARAMETER oOk       AS LOG       NO-UNDO. /* Результат обработки */

   DEF VAR vi          AS INT64  NO-UNDO.
   DEF VAR vTranshCls  AS CHAR   NO-UNDO.  /* классы траншей */
   DEF VAR vOpList     AS CHAR   NO-UNDO.  /* операции из СписОпер */

   DEF BUFFER bloan FOR loan.

   RUN RE_B_LOAN(iContract,
                 iContCode,
                 BUFFER bloan).

   IF NUM-ENTRIES(iContCode," ") GT 1 THEN 
   DO: /* Транш */
      vOpList = GetXattrInit(bloan.class-code,"СписОпер").
      FOR EACH code WHERE code.parent = iAcctType AND code.class = "ТипСчДог" NO-LOCK:
         IF CAN-DO(vOpList,REPLACE(REPLACE(code.code,"Дб",""),"Кр","")) THEN 
         DO:
            oOk = TRUE.
            LEAVE.
         END.
      END.
      IF NOT oOk THEN RETURN.  /* Операции не ведутся на транше */
   END.
   ELSE IF bloan.cont-type = "Течение" THEN 
   DO: /* Течение */
      vTranshCls = GetXattrInit(bloan.class-code,"ДопКлассыДляТеч").
      DO vi = 1 TO NUM-ENTRIES(vTranshCls):
         vOpList = GetXattrInit(ENTRY(vi,vTranshCls),"СписОпер").
         FOR EACH code WHERE code.parent = iAcctType AND code.class = "ТипСчДог" NO-LOCK:
            IF CAN-DO(vOpList,REPLACE(REPLACE(code.code,"Дб",""),"Кр","")) THEN 
            DO:
               oOk = TRUE.
               LEAVE.
            END.
         END.
         IF oOk THEN RETURN.  /* Операции ведутся на траншах */
      END.
   END.

END PROCEDURE.

FUNCTION GetGarOwner RETURNS CHARACTER (INPUT iSurr AS CHARACTER,
                                        INPUT iDate AS DATE).
   DEF VAR oGarOwner AS CHARACTER NO-UNDO.
   DEF VAR vVidDogOb AS CHARACTER NO-UNDO.
   DEF VAR vCustRole AS CHARACTER NO-UNDO.

   DEF BUFFER bcust-role FOR cust-role.

   ASSIGN
      vVidDogOb = GetXAttrValueEx("term-obl",
                                  iSurr,
                                  "ВидДогОб",
                                  "")
      vCustRole = GetCode("СобствОбРоли",
                          vVidDogOb)
   .
   FOR EACH bcust-role WHERE
            bcust-role.file-name  EQ "term-obl"
      AND   bcust-role.surrogate  EQ iSurr
      AND   bcust-role.Class-Code EQ vCustRole
      AND   bcust-role.open-date  LE iDate
      AND  (bcust-role.close-date EQ ?
         OR bcust-role.close-date GT iDate)
   NO-LOCK
   BY bcust-role.open-date:
      oGarOwner = (IF {assigned oGarOwner} THEN oGarOwner + "|" ELSE "") +
                  bcust-role.cust-cat + "," + bcust-role.cust-id.
   END.
   IF NOT {assigned oGarOwner} THEN
      oGarOwner = GetXattrValueEx("term-obl",
                                  iSurr,
                                  "СобствОб",
                                  "").
   RETURN oGarOwner.
END FUNCTION.

/* =============================-===
   ** Определение базового периода в соответствие с 229-ФЗ */
PROCEDURE GetBasePer:
   DEF INPUT  PARAM iContract AS CHAR  NO-UNDO.    /* Назначение договора */
   DEF INPUT  PARAM iContCode AS CHAR  NO-UNDO.    /* Номер договора */
   DEF INPUT  PARAM iDate     AS DATE  NO-UNDO.    /* На дату */
   DEF INPUT  PARAM TABLE FOR ttReportTable BIND.  /* Таблица с платежами */
   DEF OUTPUT PARAM oBasePer  AS INT64 NO-UNDO.    /* Базовый период */

   DEF VAR vLoanBP AS CHAR  NO-UNDO. /* ДР ПСК229БП */
   DEF VAR vMesBP  AS INT64 NO-UNDO. /* НП ПСК229ДлМес */
   DEF VAR vPer    AS CHAR  NO-UNDO. /* Периодичность погашения */
   DEF VAR vDt     AS DATE  NO-UNDO.
   DEF VAR vFlSY   AS LOG   NO-UNDO. /* признак наличие интервала меньше года */
   DEF VAR vCount  AS INT64 NO-UNDO. /* кол-во периодов погашения */
   DEF VAR vSrAmt  AS DEC   NO-UNDO. /* среднее арифмет. длит. периодов */
   DEF VAR vSpRas  AS LOG   NO-UNDO. /* способ расчета БП */

        /* Базовые периоды и их длительность стандартных базовых периодов */
    DEF VAR vKndPer        AS CHAR    NO-UNDO
        INIT "ДН,Н,Д,М,К,ПГ,Г". /* в порядке увеличения продолжительности */
    DEF VAR vContinPer     AS CHAR    NO-UNDO
        INIT "1,7,10,30,90,180,365". /* в порядке, соответ.предыдущему списку */

   DEF BUFFER loan          FOR loan.
   DEF BUFFER loan-cond     FOR loan-cond.
   DEF BUFFER btReportTable FOR ttReportTable.

   main:
   DO ON ERROR  UNDO, RETURN
      on endkey undo, return:

      FIND FIRST loan WHERE loan.contract  EQ iContract
                        AND loan.cont-code EQ iContCode
      NO-LOCK NO-ERROR.
      IF NOT AVAIL loan THEN
          LEAVE main.
      FIND LAST loan-cond WHERE loan-cond.contract  EQ loan.contract
                            AND loan-cond.cont-code EQ loan.cont-code
                            AND loan-cond.since     LE iDate
      NO-LOCK NO-ERROR.
      IF NOT AVAIL loan-cond THEN
         LEAVE main.
      /* сначала проверяем ДР ПСК229БП */
      vLoanBP = GetXattrValueEx("loan",
                                loan.contract + "," + loan.cont-code,
                                "ПСК229БП",
                                "").
      {puttolog.i
          &mes    = "'Договор №: ' + iContCode + '~n ДР ПСК229БП = ' + vLoanBP"
          &stream = " stream vStream "
      }
      /* Если установлена индивидуальная настройка БП для договора */
      IF {assigned vLoanBP}
         AND NUM-ENTRIES(vLoanBP,"=") GT 1 THEN
      DO:
         vPer = ENTRY(1,vLoanBP,"=").
         CASE vPer:
             WHEN "Д" THEN
                 oBasePer = INT64(ENTRY(2,vLoanBP,"=")) NO-ERROR.
             WHEN "М" THEN
                oBasePer = INT64(TRUNCATE(DEC(ENTRY(2,vLoanBP,"=")) *
                                  INT64(ENTRY(LOOKUP("М",vKndPer),vContinPer)),0)) NO-ERROR.
             WHEN "Г" THEN
                oBasePer = INT64(TRUNCATE(DEC(ENTRY(2,vLoanBP,"=")) *
                                 INT64(ENTRY(LOOKUP("Г",vKndPer),vContinPer)),0)) NO-ERROR.
             OTHERWISE
             DO:
                {puttolog.i
                    &mes    = "'Договор №: ' + iContCode + '~n Неверно задан ДР ПСК229БП = ' + vLoanBP + '. Некорректный период.'"
                    &stream = " stream vStream "
                }
             END.
         END CASE.
         IF ERROR-STATUS:ERROR THEN
         DO:
            {puttolog.i
                &mes    = "'Договор №: ' + iContCode + '~n Неверно задан ДР ПСК229БП = ' + vLoanBP"
                &stream = " stream vStream "
            }
         END.
      END.
      /* Если БП требуется рассчитать по параметрам договора */
      ELSE
      DO:
         IF SESSION:DEBUG-ALERT THEN
         DO:
            {puttolog.i
                &mes    = "'Договор №: ' + iContCode + '~n Периодичность платежей по ОД = ' + loan-cond.cred-period + '; по %% = ' + loan-cond.int-period"
                &stream = " stream vStream "
            }
         END.
         /* если погашение по произвольной схеме или в конце срока */
         IF     CAN-DO("П,Кс",loan-cond.cred-period)
            AND CAN-DO("П,Кс",loan-cond.int-period) THEN
         DO:
            /* проверяем, есть ли интервалы меньше года */
            FIND FIRST btReportTable NO-ERROR.
            IF AVAIL btReportTable THEN
               vDt = btReportTable.tf_payment-date.
            FOR EACH ttReportTable WHERE
                     ttReportTable.tf_payment-date GT btReportTable.tf_payment-date
                     BY ttReportTable.tf_id
                     BY ttReportTable.tf_payment-date:
                /* если есть интервал меньше года */
                IF ttReportTable.tf_payment-date - vDt LT 365 THEN
                DO:
                   vFlSY = TRUE.
                   LEAVE.
                END.
                vDt = ttReportTable.tf_payment-date.
            END.
            /* нет периодов меньше года */
            IF NOT vFlSY THEN
               oBasePer = 365.
            /* Если есть интервалы меньше года  */
            ELSE
            DO:
               /* рассчитываем среднее арифметическое длительности периодов */
               /* отдельно по ОД */
               IF AVAIL btReportTable THEN
                  vDt = btReportTable.tf_payment-date.
               FOR EACH ttReportTable WHERE
                        ttReportTable.tf_payment-date   GT btReportTable.tf_payment-date
                    AND ttReportTable.tf_basic-sum-loan NE 0
                     BY ttReportTable.tf_id
                     BY ttReportTable.tf_payment-date:
                   ASSIGN
                      vSrAmt = vSrAmt + ttReportTable.tf_payment-date - vDt +
                               (IF vDt EQ btReportTable.tf_payment-date THEN 0 ELSE 1)
                      vCount = vCount + 1
                      vDt    = ttReportTable.tf_payment-date.
               END.
               /* отдельно по процентам */
               IF AVAIL btReportTable THEN
                  vDt = btReportTable.tf_payment-date.
               FOR EACH ttReportTable WHERE
                        ttReportTable.tf_payment-date   GT btReportTable.tf_payment-date
                    AND ttReportTable.tf_sum-percent NE 0
                     BY ttReportTable.tf_id
                     BY ttReportTable.tf_payment-date:
                   ASSIGN
                      vSrAmt = vSrAmt + ttReportTable.tf_payment-date - vDt +
                               (IF vDt EQ btReportTable.tf_payment-date THEN 0 ELSE 1)
                      vCount = vCount + 1
                      vDt    = ttReportTable.tf_payment-date.
               END.
               /* вычисляем среднее арифметическое для ОД и %% */
               IF vCount GT 0 THEN
                  vSrAmt = ROUND(vSrAmt / vCount,0).
               /* Получаем длительность месяцев, признанных стандартным */
               vMesBP = INT64(FGetSetting("ПСК229ФЗ", "ПСК229ДлМес","0")) NO-ERROR.
               {puttolog.i
                  &mes    = "'Договор №: ' + iContCode + '~n НП ПСК229ДлМес = ' + STRING(vMesBP)"
                  &stream = " stream vStream "
               }
               IF vSrAmt GT 0 THEN
               DO:
                  /* Если меньше, чем пол месяца, то берем это кол-во дней */
                  IF vSrAmt / vMesBP LT 0.5 THEN
                     oBasePer = vSrAmt.
                  ELSE IF vSrAmt / vMesBP LE 1 THEN
                     oBasePer = vMesBP.
                  ELSE
                  DO:
                     /* округляем до целого числа месяцев */
                     oBasePer = ROUND(vSrAmt / vMesBP,0).
                     /* Если больше или равно 12, то берем год */
                     IF oBasePer GE 12 THEN
                        oBasePer = 365.
                     ELSE
                        oBasePer = oBasePer * vMesBP.
                  END.
               END.
            END.
         END.
         ELSE
         DO:
            /* Получаем наиболее короткий период, исключая произвольную схему
            и гашение в конце срока */
            IF CAN-DO("П,Кс",loan-cond.cred-period) THEN
               vPer = loan-cond.int-period.
            ELSE IF CAN-DO("П,Кс",loan-cond.int-period) THEN
               vPer = loan-cond.cred-period.
            ELSE
               vPer = (IF LOOKUP(loan-cond.cred-period,vKndPer) LT
                          LOOKUP(loan-cond.int-period,vKndPer) THEN
                          loan-cond.cred-period
                       ELSE loan-cond.cred-period).
            /* Вычисляем способ расчета базового периода: заданный или расчетный */
            vSpRas = FGetSetting("ЭПС", "СпРасчБП", "Нет") EQ "Да".
            IF vSpRas THEN
            DO:
               oBasePer = 1000000.
               /* если периодичность совпадает с периодичностью по ОД */
               IF loan-cond.cred-period EQ vPer THEN
               DO:
                  /* подсчитываем частоту встречи периодичности платежей в днях */
                  {empty tt-perpay}
                  vDt = loan.open-date.
                  FOR EACH ttReportTable WHERE
                           ttReportTable.tf_basic-sum-loan NE 0
                     BY ttReportTable.tf_id
                     BY ttReportTable.tf_payment-date:
                     FIND FIRST tt-perpay WHERE tt-perpay.CntDays EQ ttReportTable.tf_payment-date - vDt 
                     NO-ERROR.
                     IF NOT AVAIL tt-perpay THEN
                     DO:
                        CREATE tt-perpay.
                        tt-perpay.cntDays = ttReportTable.tf_payment-date - vDt.
                     END.
                     ASSIGN
                        tt-perpay.cnt = tt-perpay.cnt + 1
                        vDt           = ttReportTable.tf_payment-date.
                  END.
                  /* поиск наиболее часто встречающегося */
                  vCount = 0.
                  FOR EACH tt-perpay NO-LOCK:
                      vCount = MAX(vCount,tt-perpay.cnt).
                  END.
                  /* определение наиболее короткого из часто встречающихся */
                  FOR EACH tt-perpay WHERE tt-perpay.cnt EQ vCount NO-LOCK:
                      oBasePer = MIN(oBasePer,tt-perpay.CntDays).
                  END.
               END.
               /* если периодичность совпадает с периодичностью по %% */
               IF loan-cond.int-period EQ vPer THEN
               DO:
                  /* подсчитываем частоту встречи периодичности платежей в днях */
                  {empty tt-perpay}
                  vDt = loan.open-date.
                  FOR EACH ttReportTable WHERE
                           ttReportTable.tf_sum-percent NE 0
                     BY ttReportTable.tf_id
                     BY ttReportTable.tf_payment-date:
                     FIND FIRST tt-perpay WHERE tt-perpay.CntDays EQ ttReportTable.tf_payment-date - vDt 
                     NO-ERROR.
                     IF NOT AVAIL tt-perpay THEN
                     DO:
                        CREATE tt-perpay.
                        tt-perpay.cntDays = ttReportTable.tf_payment-date - vDt.
                     END.
                     ASSIGN
                        tt-perpay.cnt = tt-perpay.cnt + 1
                        vDt           = ttReportTable.tf_payment-date.
                  END.
                  /* поиск наиболее часто встречающегося */
                  vCount = 0.
                  FOR EACH tt-perpay NO-LOCK:
                      vCount = MAX(vCount,tt-perpay.cnt).
                  END.
                  /* определение наиболее короткого из часто встречающихся */
                  FOR EACH tt-perpay WHERE tt-perpay.cnt EQ vCount NO-LOCK:
                      oBasePer = MIN(oBasePer,tt-perpay.CntDays).
                  END.
               END.
            END.
            ELSE
               oBasePer = MIN(INT64(ENTRY(LOOKUP(vPer,vKndPer),vContinPer)) * 
                              IF loan-cond.cred-period EQ "ДН" THEN loan-cond.cred-date ELSE 1,
                              INT64(ENTRY(LOOKUP(vPer,vKndPer),vContinPer)) * 
                              IF loan-cond.int-period EQ "ДН" THEN loan-cond.int-date ELSE 1)
               NO-ERROR.

         END.
      END.
   END.

   FINALLY:
      {puttolog.i
         &mes    = "'Договор №: ' + iContCode + '~n Базовый период  = ' + STRING(oBasePer) + ' дней'"
         &stream = " stream vStream "
      }
   END FINALLY.
END PROCEDURE.

   /* =============================-===
   ** Определение по какой ф-ле делать расчет ЭПС:  1 - 353-ФЗ; 2 - 229-ФЗ */
PROCEDURE GetEpsForm:
   DEF INPUT  PARAM iContract AS CHAR  NO-UNDO.    /* Назначение договора */
   DEF INPUT  PARAM iContCode AS CHAR  NO-UNDO.    /* Номер договора */
   DEF INPUT  PARAM iDate     AS DATE  NO-UNDO.    /* На дату */
   DEF OUTPUT PARAM oEpsForm  AS INT64 NO-UNDO INIT 1. /* Базовый период */

   DEF VAR vDt229 AS DATE NO-UNDO.
   DEF VAR vFl229 AS CHAR NO-UNDO.
   DEF VAR vLoanT AS CHAR NO-UNDO.

   main:
   DO ON ERROR  UNDO, RETURN
      on endkey undo, return:

      FIND FIRST loan WHERE loan.contract  EQ iContract
                        AND loan.cont-code EQ iContCode
      NO-LOCK NO-ERROR.
      IF NOT AVAIL loan THEN
          LEAVE main.
      vFl229 = GetXAttrValueEx("loan",
                               loan.contract + "," + loan.cont-code,
                               "ПСК229ФЗ",
                               "").
      {puttolog.i
         &mes    = "'Договор №: ' + iContCode + '~n ДР ПСК229ФЗ = ' + vFl229 "
         &stream = " stream vStream "
      }
      IF vFl229 EQ "Да" THEN
      DO:
         oEpsForm = 2.
         LEAVE main.
      END.
      ELSE IF vFl229 EQ "Нет" THEN
         LEAVE main.

      /* Дата, с которой действует алгоритм 229-ФЗ */
      vDt229 = DATE(FGetSetting("ПСК229ФЗ", "ПСК229Дата",?)) NO-ERROR.
      IF ERROR-STATUS:ERROR THEN
      DO:
         {puttolog.i
                &mes    = "'Договор №: ' + iContCode + '~n НП ПСК229Дата установлен некорректно '"
                &stream = " stream vStream "
              }
         LEAVE main.
      END.
      /* если дата расчет по 229-ФЗ позже переданной */
      IF vDt229 GT iDate THEN
         LEAVE main.

      /* список классов , для которых применяется второй алгоритм расчета */
      vLoanT = FGetSetting("ПСК229ФЗ", "ПСК229классы","").
      {puttolog.i
         &mes    = "'Договор №: ' + iContCode + '~n НП ПСК229классы = ' + vLoanT "
         &stream = " stream vStream "
      }
      IF NOT CAN-DO(vLoanT,loan.class-code) THEN
         LEAVE main.

      /* список типов  , для которых применяется второй алгоритм расчета */
      vLoanT = FGetSetting("ПСК229ФЗ", "ПСК229типы","").
      {puttolog.i
         &mes    = "'Договор №: ' + iContCode + '~n НП ПСК229типы = ' + vLoanT "
         &stream = " stream vStream "
      }
      IF NOT CAN-DO(vLoanT,loan.cont-type) THEN
         LEAVE main.

      oEpsForm = 2.
   END. /* main */

   FINALLY:
      {puttolog.i
         &mes    = "'Договор №: ' + iContCode + '~n Алгоритм расчета ЭПС  = ' + STRING(oEpsForm) "
         &stream = " stream vStream "
      }
   END FINALLY.
END PROCEDURE.
/* $LINTENV ='1ut' */
/* $LINTVSS ='$/ws2-tst/bq/' */
/* $LINTDATE='12/11/2015 16:42:17.458+04:00' */
/* $LINTUSER='mimo' */
/* $LINTMODE='1' */
/* $LINTFILE='loan.pro' */
/*prosignCXCtjLq1beaBD7+PKLs3qQ*/