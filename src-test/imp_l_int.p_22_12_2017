/*
               Банковская интегрированная система БИСквит
    Copyright: (C) 1992-2007 ЗАО "Банковские информационные системы"
     Filename: 
      Comment: Создаем операции по реестрам Союза
   Parameters:
         Uses:
      Used by:
      Created: kam
     Modified: 
*/



/* Пробуем конвертнуть в дату */
/* Входная строка в формате 20161232 */
FUNCTION ConvertDate RETURN DATE(INPUT iDate AS CHARACTER):
    DEFINE VAR returnDate AS DATE NO-UNDO INIT ?.
    DEFINE VAR mTmpStr AS CHAR NO-UNDO.
    DEFINE VAR mTmpDay AS INT64 NO-UNDO.
    DEFINE VAR mTmpMonth AS INT64 NO-UNDO.
    DEFINE VAR mTmpYear AS INT64 NO-UNDO.
    DEFINE VAR mTmpDate AS DATE NO-UNDO.

    ERROR-STATUS:ERROR = NO.
    mTmpStr = TRIM(iDate).
    /* mTmpStr = TRIM(REPLACE(iDate,"/","")). */
        /* формат yyyymmdd */
        IF LENGTH(mTmpStr) = 8 THEN DO:
            ERROR-STATUS:ERROR = NO.
            mTmpYear = INT(SUBSTRING(mTmpStr,1,4)) NO-ERROR.
            IF ERROR-STATUS:ERROR = YES THEN RETURN.
            ERROR-STATUS:ERROR = NO.
            mTmpMonth = INT(SUBSTRING(mTmpStr,5,2)) NO-ERROR.
            IF ERROR-STATUS:ERROR = YES THEN RETURN.
            ERROR-STATUS:ERROR = NO.
            mTmpDay = INT(SUBSTRING(mTmpStr,7,2)) NO-ERROR.
            IF ERROR-STATUS:ERROR = YES THEN RETURN.
            ERROR-STATUS:ERROR = NO.
            mTmpDate = DATE (mTmpMonth,mTmpDay,mTmpYear) NO-ERROR.
            IF ERROR-STATUS:ERROR = NO THEN DO:
                returnDate = mTmpDate.
            END.
        END.
        /* формат dd.mm.yyyy */
        ELSE DO: IF LENGTH(mTmpStr) = 10 THEN DO:
            ERROR-STATUS:ERROR = NO.
            mTmpYear = INT(SUBSTRING(mTmpStr,7,4)) NO-ERROR.
            IF ERROR-STATUS:ERROR = YES THEN RETURN.
            ERROR-STATUS:ERROR = NO.
            mTmpMonth = INT(SUBSTRING(mTmpStr,4,2)) NO-ERROR.
            IF ERROR-STATUS:ERROR = YES THEN RETURN.
            ERROR-STATUS:ERROR = NO.
            mTmpDay = INT(SUBSTRING(mTmpStr,1,2)) NO-ERROR.
            IF ERROR-STATUS:ERROR = YES THEN RETURN.
            ERROR-STATUS:ERROR = NO.
            mTmpDate = DATE (mTmpMonth,mTmpDay,mTmpYear) NO-ERROR.
            IF ERROR-STATUS:ERROR = NO THEN DO:
                returnDate = mTmpDate.
            END.
        END.
        END.
       
    RETURN returnDate.
    
END FUNCTION.

/* Проверяет, является ли строка - числом */
FUNCTION ConvertDecimal RETURN DECIMAL (iStr AS CHAR):
   DEF VAR vRes AS DECIMAL NO-UNDO.
   ERROR-STATUS:ERROR = NO.
   vRes = DECIMAL(TRIM(iStr)) NO-ERROR.
   IF ERROR-STATUS:ERROR = YES THEN vRes = -1.
   RETURN vRes.
END FUNCTION.

{sh-defs.i}
/* {ksh-defs.i NEW} */
{globals.i}  
 {topkind.def} 


{getdate.i}

/*
{intrface.get tmess}
{intrface.get pbase} */
{intrface.get xclass}
{intrface.get corr}
/*
DEF VAR fname AS CHAR VIEW-AS FILL-IN NO-UNDO.
*/
DEF VAR fstr AS CHAR INIT '' NO-UNDO.

DEF VAR sId AS CHAR NO-UNDO.
DEF VAR sCode AS CHAR NO-UNDO.
DEF VAR sDate AS DATE NO-UNDO.
DEF VAR sOp AS DECIMAL NO-UNDO.
DEF VAR sSum AS DECIMAL NO-UNDO.
DEF VAR iInt AS INT64 NO-UNDO.
DEF VAR sname AS CHAR NO-UNDO.

DEFINE BUFFER loan FOR loan.
DEFINE BUFFER loan-acct FOR loan-acct.

DEFINE VARIABLE mRes     AS LOGICAL     NO-UNDO.
DEFINE VARIABLE mMessage AS CHARACTER   NO-UNDO.
DEFINE VARIABLE mOK      AS LOGICAL     NO-UNDO.
DEF VAR idd AS INT64 NO-UNDO.
DEF VAR idk AS INT64 NO-UNDO.
DEF VAR nn AS INT64 NO-UNDO.

DEFINE TEMP-TABLE ttOp
    FIELD in-recid AS RECID
	FIELD in-cont-code AS CHAR
	FIELD in-op-date AS DATE
	FIELD in-id-op AS DECIMAL
    FIELD in-amt-rub AS DECIMAL
    index idx in-recid
    index idx3 in-op-date
.

/*
{getdate.i}
*/
	
sname = '/data/home2/bis/quit41d/imp-exp/roscap/in/' + STRING(YEAR(TODAY),"9999") + STRING(MONTH(TODAY),"99") + STRING(DAY(TODAY),"99") + 'clnd_fact.txt'.
sname = '/data/home/kam/' + STRING(YEAR(TODAY),"9999") + STRING(MONTH(TODAY),"99") + STRING(DAY(TODAY),"99") + 'clnd_fact.txt'.

{getfile.i &filename=sname &mode=must-exist }
iInt = 0.

IF SEARCH (fname) = ? THEN DO:
	MESSAGE ("Файл не найден " + fname) VIEW-AS ALERT-BOX.
	RETURN.
END.

{empty ttOp}
INPUT FROM VALUE(fname) CONVERT TARGET "ibm866"  SOURCE "1251".

REPEAT ON ENDKEY UNDO, LEAVE:
    IMPORT UNFORMATTED fstr.
	fstr = REPLACE(fstr,'"','').
	fstr = REPLACE(fstr,' ','').
	iInt = iInt + 1.
	if num-entries ( fstr,';') > 4 then do:

		sId = TRIM(ENTRY(1,fstr,';')).
		sDate = ConvertDate(ENTRY(2,fstr,';')).
		sOp = ConvertDecimal(ENTRY(3,fstr,';')).
		sSum = ConvertDecimal(ENTRY(5,fstr,';')).

		IF sDate <> ? AND sSum > 0 AND sDate <> end-date THEN DO:

			FIND FIRST loan WHERE RECID(loan) = INT(sId) 
				NO-LOCK NO-ERROR.
			IF AVAIL loan THEN DO:
			/*	FIND FIRST ttOp WHERE in-recid = INT64(sId) no-error.
				IF not avail ttOp Then */
				CREATE ttOp.

						ASSIGN
							ttOp.in-recid = INT(sId)
							ttOp.in-cont-code = loan.cont-code
							ttOp.in-op-date = sDate
							ttOp.in-id-op = sOp
							ttOp.in-amt-rub = sSum
						.
					END. /* IF sSum > 0 THEN DO: */
			END.
		RELEASE ttOp.
	end.
    fstr = ''.
 END. /* IMPORT UNFORMATTED fstr. */
/*
message iInt view-as alert-box.
*/

DEF VAR lastDate AS DATE NO-UNDO.
DEF VAR myMonth AS INT64 NO-UNDO.
DEF VAR myYear AS INT64 NO-UNDO.
DEF VAR tekSum AS DECIMAL NO-UNDO.
DEF VAR tmpDate AS DATE NO-UNDO.
DEF BUFFER ttOp1 FOR ttOp.


RUN SETSUM(INPUT 110).

RUN SETSUM1(INPUT 117).

RUN SETSUM(INPUT 117).

RUN SETNULL(INPUT '119,106,109,298').

FOR EACH ttOp WHERE ttOp.in-amt-rub > 0 no-lock break by ttOp.in-recid by ttOp.in-op-date:
    FIND FIRST loan WHERE RECID(loan) = ttOp.in-recid NO-LOCK NO-ERROR.
        IF NOT AVAIL loan THEN LEAVE.
        RUN getOPID(INPUT ttOp.in-id-op, OUTPUT idd, OUTPUT idk ).
    IF idd <> ? AND idk <> ? THEN DO:
        nn = 1.

        FIND LAST loan-int WHERE loan-int.contract = loan.contract
		AND loan-int.cont-code = loan.cont-code 
		AND loan-int.mdate = ttOp.in-op-date NO-LOCK NO-ERROR.
	IF AVAIL loan-int THEN nn = loan-int.nn + 1.

        CREATE loan-int.
        ASSIGN
            loan-int.op-date   = ttOp.in-op-date
            loan-int.mdate     = ttOp.in-op-date
            loan-int.id-k      = idk
            loan-int.id-d      = idd
            loan-int.op        = -2
			loan-int.op-entry  = -1
            loan-int.amt-rub   = ttOp.in-amt-rub
            loan-int.nn        = DECIMAL(nn)
            loan-int.avt       = FALSE
             loan-int.contract = loan.contract
            loan-int.user-id   = 'SERVSOUZ'
            loan-int.cont-code = loan.cont-code
        .
    END.
END.

{intrface.del}


RETURN.

PROCEDURE GetName:
 DEF INPUT PARAMETER cat AS CHARACTER.
 DEF INPUT PARAMETER id AS INT64.
 DEF OUTPUT PARAMETER sname AS CHARACTER.
 
 IF cat = "Ч" THEN
  DO:
   FIND FIRST PERSON 
   WHERE PERSON.PERSON-ID = id
   NO-LOCK NO-ERROR.
    IF AVAIL PERSON THEN
    /* ФИО клиента */
    sname = PERSON.NAME-LAST + " " + PERSON.FIRST-NAMES.
  END.
 ELSE
  DO:
   FIND FIRST CUST-CORP 
   WHERE CUST-CORP.CUST-ID = id
   NO-LOCK NO-ERROR.
    IF AVAIL CUST-CORP THEN
    /* наименование организации */
    sname = CUST-CORP.CUST-STAT + " " + CUST-CORP.NAME-CORP.
  END.
END PROCEDURE.

PROCEDURE getOPID:
    DEF INPUT PARAMETER opSouz AS DECIMAL.
    DEF OUTPUT PARAMETER idd AS INT64.
    DEF OUTPUT PARAMETER idk AS INT64. 
    idd = ?.
    idk = ?.
    CASE int64(opSouz):
        WHEN 105 THEN DO:  
        /* 362 Погашение просроченных процентов (факт) */
            idd = 5.
            idk = 10.
        END.
        WHEN 106 THEN DO:  /* 50 Погашение просроченного ОД (факт) */
            idd = 5.
            idk = 7.
        END.
        WHEN 108 THEN DO:  /* 46 Погашение процентов (факт) */
            idd = 5.
            idk = 35.
        END.
        WHEN 109 THEN DO:  /* 5 Погашение ОД (факт) */
            idd = 1.
            idk = 2.
        END.
        WHEN 110 THEN DO:  /* 65 начисление % */
            idd = 33.
            idk = 32.
        END.
        WHEN 111 THEN DO:  /* 98 Перевод процентов на просрочку (факт) */
            idd = 10.
            idk = 33.
        END.
        WHEN 112 THEN DO:  /* 2 Перевод ОД на просрочку (факт) */
            idd = 7.
            idk = 0.
        END.        
/*        WHEN 116 then do:  /* 19 Начислено пени за проср. проц. (автом) */
            idd = 12.
            idk = 5.
        end.
*/
        WHEN 117 THEN DO:  /* 365 Начисление %% на треб. за проср.осн.долг */
            idd = 233.
            idk = 8.
        END.        
        WHEN 118 THEN DO:  /* 53 Списание с баланса просроченных процентов (К) */
            idd = 24.
            idk = 10.
        END.
        WHEN 119 THEN DO:  /* 478 Оплата требов. на проср О/Д 302-П */
            idd = 5.
            idk = 233.
        END.
        WHEN 298 THEN DO:  /* 298 Перенос %% с треб. на проср.%% за пр.о.д */
            idd = 210.
            idk = 233.            
        END.
    END CASE.    
END PROCEDURE.

PROCEDURE SETSUM:
DEF INPUT PARAMETER tmpop as INT64.
tekSum = 0.
FOR EACH ttOp WHERE ttOp.in-amt-rub > 0 
    AND (ttOp.in-id-op = tmpop)
    BREAK BY ttOp.in-recid by ttOp.in-op-date:
    IF FIRST-OF(ttOp.in-recid) AND FIRST-OF(ttOp.in-op-date) THEN DO:
        FIND FIRST loan WHERE RECID(loan) = ttOp.in-recid NO-LOCK NO-ERROR.
        IF NOT AVAIL loan THEN LEAVE.
        tekSum = 0.
        myMonth = Month(ttOp.in-op-date).
        myYear = Year(ttOp.in-op-date).
        lastDate = date_correct(myMonth,0,31,myYear).
/* message lastDate view-as alert-box. */
        FOR EACH ttOp1
          WHERE ttOp1.in-recid EQ ttOp.in-recid
          BY ttOp1.in-op-date DESC:
            tmpDate = ttOp1.in-op-date.
          LEAVE.
        END.
    END.
    tekSum = tekSum + ttOp.in-amt-rub.
    FIND FIRST term-obl WHERE 
        term-obl.contract EQ 'Кредит'
    AND term-obl.cont-code = loan.cont-code 
    AND term-obl.idnt = 1  
    AND term-obl.end-date = ttOp.in-op-date
    /* AND term-obl.amt-rub > 0 */  
     NO-LOCK NO-ERROR.
    IF AVAIL term-obl 
       OR ttOp.in-op-date = lastDate THEN
      /* OR myMonth <> Month(ttOp.in-op-date)  */ 
       DO:
           ttOp.in-amt-rub = tekSum. 
           tekSum = 0.
           myMonth = Month(ttOp.in-op-date).
           myYear = Year(ttOp.in-op-date).
           lastDate = date_correct(myMonth,0,31,myYear).
/*           message lastDate view-as alert-box. */
       END.
    ELSE DO:
/*       if tmpop = 117 then do:
           def buffer ttOp2 for ttOp.
             find first ttOp where
                ttOp.   
        ttOp.in-recid = INT(sId)
                            ttOp.in-cont-code = loan.cont-code
                            ttOp.in-op-date = sDate
                            ttOp.in-id-op = sOp
                            ttOp.in-amt-rub = sSum
                            
       end.
       else */ 
       do: 
           ttOp.in-amt-rub = 0.
       end. 
    END.
    IF ttOp.in-op-date = tmpDate AND tekSum <> 0 THEN ttOp.in-amt-rub = tekSum.
END.

END PROCEDURE.

/* считаем 298 операцию  +- */
/*
PROCEDURE Set298:
def var tmsum as decimal no-undo.

FOR EACH ttOp WHERE ttOp.in-amt-rub > 0 
    and ttOp.in-id-op = 298
    BREAK BY ttOp.in-recid by ttOp.in-op-date :
    IF FIRST-OF(ttOp.in-recid) AND FIRST-OF(ttOp.in-op-date) THEN DO:
        tmsum = 0.
        tmdate = date("01/01/2001").        
    end.
        for each ttOp3 where ttOp3.in-op-date <= ttOp.in-op-date
            and ttOp3.in-op-date > tmdate
            and ttOp3.in-recid= ttOp.in-recid
            and ttOp3.in-amt-rub > 0
            and ttOp3.in-id-op = 119
            no-lock no-error by ttOp3.in-op-date:
            tmsum = tmsum + ttOp3.in-amt-rub.  /* 478: Погашение %% по просроченной */
        end.
    

end.
    
    
END PROCEDURE.    
*/

/* удаляем операции в день ОВ */
PROCEDURE SetNull:
DEF INPUT PARAMETER listOP as char.
DEF BUFFER ttOp3 FOR ttOp.
def var i as int no-undo.
def var tmsum as decimal no-undo.

FOR EACH ttOp WHERE ttOp.in-amt-rub > 0 
    BREAK BY ttOp.in-recid by ttOp.in-op-date desc:
    IF FIRST-OF(ttOp.in-recid) AND FIRST-OF(ttOp.in-op-date) THEN DO:
        do i = 1 TO num-entries(listOp):
            find first ttOp3 where 
                ttOp3.in-recid EQ ttOp.in-recid
                and ttOp3.in-id-op = int(entry (i,listOp))
                and ttOp3.in-op-date = ttOp.in-op-date
                no-error.
            if avail ttOp3 then ttOp3.in-amt-rub = 0.
        end.
    end.
end.

END PROCEDURE.

/* 298 операция */
PROCEDURE SETSUM1:
DEF INPUT PARAMETER tmpop as INT64.
DEF BUFFER ttOp2 FOR ttOp.
DEF BUFFER ttOp4 FOR ttOp.
def var tmpdate2 as date no-undo.
def var tekSum298 as decimal no-undo.
def var tmpdate298 as date no-undo.

tekSum = 0.
tekSum298 = 0.

FOR EACH ttOp WHERE ttOp.in-amt-rub > 0 
    AND ttOp.in-id-op = tmpop
    BREAK BY ttOp.in-recid by ttOp.in-op-date:
    IF FIRST-OF(ttOp.in-recid) AND FIRST-OF(ttOp.in-op-date) THEN DO:
        FIND FIRST loan WHERE RECID(loan) = ttOp.in-recid NO-LOCK NO-ERROR.
        IF NOT AVAIL loan THEN LEAVE.
        tekSum = 0.
        FOR EACH ttOp1
          WHERE ttOp1.in-recid EQ ttOp.in-recid
          BY ttOp1.in-op-date DESC:
            tmpDate = ttOp1.in-op-date.
          LEAVE.
        END.
        tmpdate298 = date("01/01/2001").        
        tekSum298 = 0.
    END.

    for each term-obl where term-obl.contract EQ 'Кредит'
        AND term-obl.cont-code = loan.cont-code 
        AND term-obl.idnt = 1  
        AND term-obl.end-date >= ttOp.in-op-date 
        no-lock by term-obl.end-date:
          if term-obl.end-date > tmpdate then tmpdate2 = tmpdate.         
            else tmpdate2 = term-obl.end-date.
          find first ttOp2 where   
              ttOp2.in-recid = ttOp.in-recid
              and ttOp2.in-cont-code = ttOp.in-cont-code
              and ttOp2.in-op-date = tmpdate2
              and ttOp2.in-id-op = 298
              no-error.
          if avail ttOp2 then do:
              ttOp2.in-amt-rub = ttOp2.in-amt-rub + ttOp.in-amt-rub.
          end.
          else do:

              for each ttOp4 where ttOp4.in-op-date <= tmpdate2
                and ttOp4.in-op-date > tmpdate298
                and ttOp4.in-recid= ttOp.in-recid
                and ttOp4.in-amt-rub > 0
                and ttOp4.in-id-op = 119
                no-lock by ttOp4.in-op-date:
                tekSum298 = tekSum298 + ttOp4.in-amt-rub.  /* 478: Погашение %% по просроченной */
              end.
              tekSum298 = tekSum298 - ttOp.in-amt-rub.
              IF tekSum298 < 0 THEN DO:
                CREATE ttOp2.
                ASSIGN
                ttOp2.in-recid = ttOp.in-recid
                ttOp2.in-cont-code = ttOp.in-cont-code
                ttOp2.in-op-date = tmpdate2
                ttOp2.in-id-op = 298
                ttOp2.in-amt-rub = - tekSum298
                .
                RELEASE ttOp2.
              END.
              
              tmpdate298 = tmpdate2.
               
          end.
        leave.    
    end.

END.

END PROCEDURE.


 
