/*              
               Банковская интегрированная система БИСквит
    Copyright: (C) 1992-2017 ЗАО "Банковские информационные системы"
     Filename: PP-BAS64.P
      Comment: Библиотека функций обработки base64 в XML
   Procedures:
         BS64ImportInit
         BS64ImportData
         BS64ImportFinis
         BS64FileRequest
         Base64Decode
   Parameters: iClass      - код класса
               iInstance   - содержимое класса iClass
      Created: 07.06.2006 NIK
     Modified:
*/
{form.def}
{exchange.equ}

DEFINE VAR m64Bin    AS INT64 EXTENT 127   NO-UNDO.
DEFINE VAR mFilePath AS CHAR                 NO-UNDO.

{intrface.get tmess}
{intrface.get strng}
{intrface.get exch}

{pfuncdef
   &LIBDEF        = "YES"
   &NAME          = "bas64"
   &LIBNAME       = "Библиотека функций обработки base64 в XML"
   &DESCRIPTION   = "Библиотека функций обработки base64 в XML"
   }
   
&GLOB NO-BASE-PROC YES
                                       /* Отключение отладки, иначе процедура
                                          падает при переполнении строки      */ 
&GLOB IS-DEBUG NO
&UNDEFINE IS-DEBUG 

DEFINE temp-table ttFile NO-UNDO
    FIELD FileName AS CHAR
    INDEX FileName FileName
.

RUN BS64FillDecode.
/*----------------------------------------------------------------------------*/
/* Начинает обработку тэга <Object>                                           */
/*----------------------------------------------------------------------------*/
PROCEDURE BS64ImportInit:
   DEFINE INPUT PARAMETER iFormat   AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iInstance AS handle   NO-UNDO.
   mFilePath = ?.
   {empty ttFile}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Декодирует base64 -> bin и кладет итог в файл                              */
/*----------------------------------------------------------------------------*/
PROCEDURE BS64ImportData:
   DEFINE INPUT  PARAMETER iInstance           AS HANDLE   NO-UNDO.
   DEFINE INPUT  PARAMETER iData               AS MEMPTR   NO-UNDO.

   DEFINE VAR    vFlagSet                  AS LOGICAL  NO-UNDO.
   DEFINE VAR    vSize                     AS INT64    NO-UNDO.
   DEFINE VAR    vData                     AS memptr   NO-UNDO.
   DEFINE VAR    vFilePath                 AS CHAR     NO-UNDO.
   DEFINE VAR    vItm                      AS INT64    NO-UNDO.
   DEFINE VAR    vPos                      AS INT64    NO-UNDO.

MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i  MAIN}      

      vSize = GET-SIZE(iData).     
      vSize = (truncate(vSize / 4, 0) + 1) * 3 + 1.
      set-size(vData) = vSize NO-ERROR. {&ON-ERROR}

      RUN Base64Decode (iData, vData).

   DO vItm = 1 TO vSize:
      vPos  = GET-BYTE(vData,vItm).
      IF vPos EQ 0 THEN PUT-BYTE (vData,vItm) = 32. 
   END.

NAME:
      DO WHILE YES:
         vFilePath = "./" + string(etime,"9999999999") + ".xml".
         CREATE ttFile.
         ASSIGN
            ttFile.FileName = vFilePath
         NO-ERROR.

         IF SEARCH(vFilePath) EQ ? THEN LEAVE NAME.
      END.

      OUTPUT TO VALUE(vFilePath).
      EXPORT vData.
      OUTPUT CLOSE.

      mFilePath = vFilePath.

      vFlagSet = YES.
   END.

   set-size(vData) = 0.
   {doreturn.i  vFlagSet}
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Вызвает обработчик xml, передавя ему ранее сохраненный файл                */
/*----------------------------------------------------------------------------*/
PROCEDURE BS64ImportFinis:
   DEFINE INPUT PARAMETER iFormat   AS CHAR     NO-UNDO.
   DEFINE INPUT PARAMETER iInstance AS handle   NO-UNDO.

   DEFINE VAR    hInstance          AS handle   NO-UNDO.
   DEFINE VAR    vFlagSet           AS LOGICAL INIT ?        NO-UNDO.
   DEFINE VAR    vFilePathImp       AS CHAR     NO-UNDO.
   DEFINE VAR    vFileExchID        AS INT64    NO-UNDO.    
   DEFINE VAR    vLTxt              AS LONGCHAR NO-UNDO INIT "".
   DEFINE VAR    vLTxtF             AS LONGCHAR NO-UNDO INIT "".

MAIN:
   DO ON ERROR UNDO MAIN, RETRY MAIN:
      {do-retry.i MAIN}

      SUBSCRIBE   TO "IXML-FILE-REQUEST" ANYWHERE RUN-PROCEDURE "BS64FileRequest":U.

      FOR EACH ttFile:
         COPY-LOB FILE ttFile.FileName TO vLTxtF NO-CONVERT.
         ASSIGN
            vLTxt = TRIM(vLTxt) + TRIM(vLTxtF)
         NO-ERROR.
      END.
      COPY-LOB FROM vLTxt TO FILE mFilePath.
  
      IF {assigned mFilePath} THEN         
         RUN i-xmlone.p (iInstance:Name, iInstance).
      
      IF SEARCH(mFilePath) NE ? THEN os-delete VALUE(mFilePath).

      vFlagSet = YES.
   END.
   UNSUBSCRIBE TO "IXML-FILE-REQUEST".
END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Возвращает имя сохраненного файла для обработчика XML                      */
/*----------------------------------------------------------------------------*/
PROCEDURE BS64FileRequest:
   DEFINE OUTPUT PARAMETER oFlag       AS LOGICAL INIT NO   NO-UNDO.
   DEFINE OUTPUT PARAMETER oFilePath   AS CHAR              NO-UNDO.

   oFlag = {assigned mFilePath} AND SEARCH(mFilePath) NE ?.
   IF oFlag THEN oFilePath = mFilePath.

END PROCEDURE.
/*----------------------------------------------------------------------------*/
/* Выполняет преобразование base64 -> bin                                     */
/*----------------------------------------------------------------------------*/
PROCEDURE Base64Decode:
   DEFINE INPUT PARAMETER iSrc  AS MEMPTR NO-UNDO.
   DEFINE INPUT PARAMETER oTrg  AS memptr NO-UNDO.

   DEFINE VAR vLen   AS INT64  NO-UNDO.
   DEFINE VAR vItm   AS INT64  NO-UNDO.
   DEFINE VAR vSym   AS INT64  NO-UNDO.
   DEFINE VAR vTrg   AS INT64  NO-UNDO.
   DEFINE VAR vStep  AS INT64  NO-UNDO.
   DEFINE VAR vJtm   AS INT64  NO-UNDO.
   DEFINE VAR vPos   AS INT64  NO-UNDO.

   &IF DEFINED(IS-DEBUG) &THEN
   DEFINE VAR vRes   AS CHAR     NO-UNDO.
   &ENDIF

   vStep = 0.
   vTrg  = 0.
   vJtm  = 0.
   vLen = GET-SIZE(iSrc).

   DO vItm = 1 TO vLen - 1:
      vStep = vStep + 1.
      vPos  = GET-BYTE(iSrc,vItm).
      IF vPos LE 0 OR vPos GT 127 THEN RETURN.
      vSym  = m64Bin[vPos].

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("Base64Decode","SYM:" + string(chr(GET-BYTE(iSrc,vItm)),"  x") + string(vSym,">>>9")).
      &ENDIF

      CASE vStep:
         WHEN 1 THEN vTrg = vSym * 4.       /* первые 2/3 первого байта       */
         WHEN 2 THEN DO:                    /* последние 1/3 первого байта    */
            ASSIGN
               vTrg                 = vTrg + truncate(vSym / 16, 0)
               vJtm                 = vJtm + 1
               PUT-BYTE (oTrg,vJtm) = vTrg
            .

            &IF DEFINED(IS-DEBUG) &THEN
            SUBSTRING(vRes,vJtm,1) = chr(vTrg).
            RUN dbgprint.p ("Base64Decode","TRG:" + string(vStep,">>9") +
                                                    string(vTrg,">>>9") +
                                              " " + chr(vTrg)).
            &ENDIF

            vTrg = (vSym modulo 16) * 16.   /* Первая половина второго байта  */
         END.
         WHEN 3 THEN DO:
            ASSIGN
               vTrg                 = vTrg + truncate(vSym / 4, 0)
               vJtm                 = vJtm + 1
               PUT-BYTE (oTrg,vJtm) = vTrg
            .

            &IF DEFINED(IS-DEBUG) &THEN
            SUBSTRING(vRes,vJtm,1) = chr(vTrg).
            RUN dbgprint.p ("Base64Decode","TRG:" + string(vStep,">>9") +
                                                    string(vTrg,">>>9") +
                                              " " + chr(vTrg)).
            &ENDIF

            vTrg = (vSym modulo 4) * 64.
         END.
         WHEN 4 THEN DO:
            ASSIGN
               vTrg                 = vTrg + vSym
               vJtm                 = vJtm + 1
               PUT-BYTE (oTrg,vJtm) = vTrg
            .

            &IF DEFINED(IS-DEBUG) &THEN
            SUBSTRING(vRes,vJtm,1) = chr(vTrg).
            RUN dbgprint.p ("Base64Decode","TRG:" + string(vStep,">>9") +
                                                    string(vTrg,">>>9") +
                                              " " + chr(vTrg)).
            &ENDIF
            vStep = 0.
         END.
      END CASE.

      &IF DEFINED(IS-DEBUG) &THEN
      RUN dbgprint.p ("Base64Decode","RES:" + string(vTrg,">>>9")     +
                                    "vItm:" + string(vItm,">>>>>>>9") +
                                       " "  + vRes).
      &ENDIF
   END.

END PROCEDURE.
/*----------------------------------------------------------------------------*/
/*                                                                            */
/*----------------------------------------------------------------------------*/
PROCEDURE BS64FillDecode PRIVATE:
   ASSIGN
      m64Bin[asc("A")] = 0
      m64Bin[asc("B")] = 1
      m64Bin[asc("C")] = 2
      m64Bin[asc("D")] = 3
      m64Bin[asc("E")] = 4
      m64Bin[asc("F")] = 5
      m64Bin[asc("G")] = 6
      m64Bin[asc("H")] = 7
      m64Bin[asc("I")] = 8
      m64Bin[asc("J")] = 9
      m64Bin[asc("K")] = 10
      m64Bin[asc("L")] = 11
      m64Bin[asc("M")] = 12
      m64Bin[asc("N")] = 13
      m64Bin[asc("O")] = 14
      m64Bin[asc("P")] = 15
      m64Bin[asc("Q")] = 16
      m64Bin[asc("R")] = 17
      m64Bin[asc("S")] = 18
      m64Bin[asc("T")] = 19
      m64Bin[asc("U")] = 20
      m64Bin[asc("V")] = 21
      m64Bin[asc("W")] = 22
      m64Bin[asc("X")] = 23
      m64Bin[asc("Y")] = 24
      m64Bin[asc("Z")] = 25
      m64Bin[asc("a")] = 26
      m64Bin[asc("b")] = 27
      m64Bin[asc("c")] = 28
      m64Bin[asc("d")] = 29
      m64Bin[asc("e")] = 30
      m64Bin[asc("f")] = 31
      m64Bin[asc("g")] = 32
      m64Bin[asc("h")] = 33
      m64Bin[asc("i")] = 34
      m64Bin[asc("j")] = 35
      m64Bin[asc("k")] = 36
      m64Bin[asc("l")] = 37
      m64Bin[asc("m")] = 38
      m64Bin[asc("n")] = 39
      m64Bin[asc("o")] = 40
      m64Bin[asc("p")] = 41
      m64Bin[asc("q")] = 42
      m64Bin[asc("r")] = 43
      m64Bin[asc("s")] = 44
      m64Bin[asc("t")] = 45
      m64Bin[asc("u")] = 46
      m64Bin[asc("v")] = 47
      m64Bin[asc("w")] = 48
      m64Bin[asc("x")] = 49
      m64Bin[asc("y")] = 50
      m64Bin[asc("z")] = 51
      m64Bin[asc("0")] = 52
      m64Bin[asc("1")] = 53
      m64Bin[asc("2")] = 54
      m64Bin[asc("3")] = 55
      m64Bin[asc("4")] = 56
      m64Bin[asc("5")] = 57
      m64Bin[asc("6")] = 58
      m64Bin[asc("7")] = 59
      m64Bin[asc("8")] = 60
      m64Bin[asc("9")] = 61
      m64Bin[asc("+")] = 62
      m64Bin[asc("/")] = 63
      m64Bin[asc("=")] = 0
   .
END PROCEDURE.
/******************************************************************************/
/* $LINTFILE='pp-bas64.p' */
/* $LINTMODE='1,5,6,3' */
/* $LINTENV ='dpl' */
/* $LINTVSS ='$/ws3-dpl/bq' */
/* $LINTUSER='mike' */
/* $LINTDATE='06/12/2016 14:39:14.794+03:00' */
/*prosignz0VpWTwpN0KVHHqvEmchCQ*/