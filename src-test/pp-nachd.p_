/*
               Банковская интегрированная система БИСквит
    Copyright: (C) 1992-2005 ЗАО "Банковские информационные системы"
     Filename: PP-NACHD.P
      Comment: Персистентная бибдиотека для начисления %%. Здесь все схемы начисления и сам nachkin.p
   Parameters:
         Uses: {inter39n.i}, {intr_pln.i}, {inter66n.i}, {intr_ybn.i}.
      Used by: 
      Created: 27.09.2005 15:35 SAP     
     Modified: 11.10.2005 12:23 SAP       
     Modified: 24.10.2005 12:02 SAP       
     Modified: 29.10.2005 17:44 SAP       
     Modified: 09.03.2006 15:44 SAP       
     Modified: 01.06.2007 13:44 fEAk     <comment>
*/

/*
В результате ускорения процедуры резервирования сюда попали схемы:

Nach_bal -  Начисление на полный остаток по постоянной ставке, выбранной исходя 
            из остатка на начало (пролонгацию) вклада. 
nchmin_o -  Начисление с выбором ставки исходя из минимального остатка
Nach39   -  Начисление на полный остаток по постоянной ставке, выбранной исходя 
            из остатка на текущую дату. 
Nach_pl  -  Начисление на всеь остаток по плавающей ставке             
nach5995 -  Начисление на полный остаток с выбором ставки в зависимости от реального времени 
            "отлежания вклада"
nach5995 -  Начисление на полный остаток с выбором ставки в зависимости от реального времени 
            "отлежания вклада". Работает со сводными счетами. 
nach6606 -  Процент комиссии расчитывается на основании основной комиссии, 
            действующей на дату начала договора или доп. соглашения, и базовой комиссии, 
            которая изменяется в течение периода.  при этом :
            1.  Основная комиссия постоянна во всем периоде, ищется  на дату начала 
                договора с учетом длительности вклада 
            2.  Базовая комиссия, изменяющаяся во времени , ищется с учетом 
                длительности вклада и остатка на счете              
nach-mp  -  Мобильный+ "   причисление начисленных процентов к сумме вкладов производится 
            по окончанию каждого процентного периода длительностью в 3 месяца. 
            Процентная ставка для вновь начинающегося процентного периода устанавливается 
            равной текущей ставке для данного вида частного вклада;
            Измененная процентная ставка начинает действовать со след. процентного периода.

nachk39  -  Аналог Nach39, работающей со сводными счетами
nach_kpl -  Аналог Nach_pl  для работы со сводными счетами                      
n_kauful -  Аналог nach_bal для работы со сводными счетами

nach39_  -  Аналог Nach39, с комиссией на глобальную дату

nach_ybl -  Схема начисления для вклада "за рамки приличного". 
            На период изътия проценты считаются по ставке в доп.реке ИзъятСтавка.
            
n_kaucon -  Начисление на субостаток вклада (без учета начисленных процентов). 
            Процентная ставка должна быть выбрана действующая на дату открытия в 
            зависимости от суммы и срока, с учетом изменения суммы.
            
n_kau_pl -  Начисление на субостаток вклада (без учета начисленных процентов). 
            Плавающая процентная ставка 
   
Таблица соответствий схем начисления: стандартная/по сводным счетам:
nach39.p        nachk39.p
nach_scl.p      nach_ksc.p
nach_pl.p       nach_kpl.p
nach_bal.p      n_kauful.p 
*/

{globals.i}
{sh-defs.i}
{ksh-defs.i NEW}
{ksh-temp.i new}
{intrface.get date} 
{intrface.get tmess} 
{intrface.get xclass} 
{intrface.get dps}
{intrface.get refer}
{def-ret.i}
{def_work.i new}
{dpsproc.def}
{sh-temp.i "new"}
{intrkost.i}
DEF TEMP-TABLE tt-MinAmm NO-UNDO
      FIELD srok        AS INT64 
      FIELD summ        AS DECIMAL
      FIELD real-summ   AS DECIMAL
      FIELD real-date   AS DATE 
   INDEX idx_srok srok.

&GLOB NoDef
{begtrans.i} /* Продолжительность довложения */
{tr_ost.i new}

def  temp-table fost-base LIKE fost. /*для начисления по основной ставке на весь период вклада*/
def  temp-table fost-ext  LIKE fost. /*для начисления на суммы превышения минимального остатка по ставке д/в*/  

DEF TEMP-TABLE tt-commrate NO-UNDO 
   LIKE comm-rate 
   FIELD real-date AS DATE
   FIELD real-summ AS DECIMAL
   FIELD cr-recid  AS RECID
   INDEX ind commission acct currency kau min-value period since.

DEF TEMP-TABLE tt-MinAmmSumm NO-UNDO 
   LIKE tt-commrate.

DEF VAR vFostMin AS DEC NO-UNDO.
DEF VAR vMinOst AS DEC NO-UNDO.
DEF VAR vFostSince AS DATE NO-UNDO.
DEF VAR iNach AS INT64 NO-UNDO INIT 0.

&IF DEFINED(use-tt) = 0
&THEN
    {prn-ved.def 
        &offnew="/*" 
        &new-nach = new-nach
        &tt = Nchk-tt
    }

    {cr-nach.i   &no-svget="/*"}

    /* Обьявляем этот препроцессор глобально, чтоб использовать его в "intr_crn.i" 
    ** и не передавать его препроцессором через тучу инклюдов */
    &GLOB Nachkin-tt Nchk-tt
&ELSE
    &GLOB Nachkin-tt Nachkin-tt
&ENDIF

{intrface.get dpspr}
{chktake.i}

DEF VAR vPlane_date  AS LOG                  NO-UNDO. 
DEF VAR fl-nach      AS INT64                  NO-UNDO.
DEF VAR comm-ost     LIKE acct-pos.balance   NO-UNDO.
DEF VAR mPer         AS CHAR                 NO-UNDO.

DEFINE BUFFER xfost FOR fost.

DEFINE TEMP-TABLE comm-mp NO-UNDO LIKE comm-rate
   FIELD cr-recid    AS RECID
   FIELD end-per     AS DATE    /* Дата окончания периода, когда действует данная ставка */
   FIELD period-len  AS INT64 /* Длина периода */
   INDEX ind commission acct currency kau min-value period since
.

vPlane_date = FGetSetting("Учет%%План", ?, "") = "Да".

PROCEDURE nachkin .
    DEF INPUT  PARAM rid1            AS RECID             NO-UNDO.
    DEF INPUT  PARAM in-commi        LIKE comm-rate.commi NO-UNDO.
    DEF INPUT  PARAM rid             AS RECID             NO-UNDO.
    DEF INPUT  PARAM end-date1       AS DATE              NO-UNDO.
    DEF INPUT  PARAM str-kau         LIKE kau.kau         NO-UNDO.
    DEF INPUT  PARAM fl-print        AS LOGICAL           NO-UNDO.
    DEF OUTPUT PARAM xresult         AS DECIMAL           NO-UNDO.
    DEF OUTPUT PARAM xresult-ref     AS DECIMAL           NO-UNDO.
    DEF INPUT-OUTPUT PARAM beg-date1 AS DATE              NO-UNDO.
    DEF OUTPUT PARAM fl              AS INT64.
    
    
    DEF VAR bdate    AS DATE    NO-UNDO.
    DEF VAR beg      AS DATE    NO-UNDO.
    DEF VAR xresult1 AS DECIMAL NO-UNDO.

    FIND interest-sch-line WHERE
                           RECID(interest-sch-line) EQ rid1
                           NO-LOCK NO-ERROR.
    FIND acct WHERE
              RECID(acct) EQ rid NO-LOCK NO-ERROR.
    
    FIND loan WHERE
              loan.contract  EQ ENTRY(1,str-kau)
          AND loan.cont-code EQ ENTRY(2,str-kau)
          NO-LOCK NO-ERROR.
    
    IF NOT AVAIL loan THEN RETURN.
    IF NOT AVAIL acct THEN RETURN.
    beg = beg-date1.
    fl = -1.
    QQ:
    REPEAT WITH FRAME prn TRANSACTION ON ERROR UNDO QQ,
                                               LEAVE QQ ON ENDKEY UNDO QQ,
                                               LEAVE QQ :
      fl = 1 .
      bdate = beg-date1 .      

      IF NOT SearchPFile(interest-sch-line.proc-name) THEN
      DO:
         MESSAGE "Процедура схемы начисления процентов~n["
            + interest-sch-line.interest-sch + "] не определена."
                 VIEW-AS ALERT-BOX WARNING.
         RETURN.
      END.
      
      RUN VALUE(interest-sch-line.proc-name) (RECID(interest-sch-line),
                                              in-commi,
                                              RECID(acct),
                                              beg,
                                              end-date1,
                                              str-kau,
                                              fl-print,
                                              INPUT-OUTPUT xresult,
                                              INPUT-OUTPUT beg-date1,
                                              OUTPUT xresult1) 
         NO-ERROR.
      IF ERROR-STATUS:ERROR THEN
      DO:
         MESSAGE "Ошибка запуска схемы начисления <" + interest-sch-line.interest-sch + ">: " + ERROR-STATUS:GET-MESSAGE(1)
            VIEW-AS ALERT-BOX INFO BUTTONS OK.
         UNDO QQ, LEAVE QQ.
      END.      
      
      IF beg = bdate THEN xresult-ref = xresult1 .
    
      CASE RETURN-VALUE :
         WHEN "1" THEN
                LEAVE QQ.
    
         WHEN "-1" THEN
         DO :
            UNDO QQ, LEAVE QQ.
         END.
    
         OTHERWISE
         DO:
            IF beg-date1 GE end-date1 THEN
               LEAVE QQ.
         END. /*OTHERWISE*/
      END CASE.
    END. /*REPEAT*/
    RUN DeleteOldDataProtocol IN h_base("Davos_min_ost").
    fl = 0.
END PROCEDURE .

/*****************************************************************************/                
/*****************************************************************************/                
/*******************Здесь начинаются схемы начисления*************************/                
/*****************************************************************************/                
/*****************************************************************************/                
PROCEDURE nach_ins:
def input param rid1             as recid             no-undo. 
def input param in-commi         like comm-rate.commi no-undo.
def input param rid              as recid             no-undo.
def input param beg              as date              no-undo.
def input param end-date1        as date              no-undo.
def input param str-kau          like kau.kau         no-undo.
def input param fl-print         as logical           no-undo.
def input-output param xresult   as decimal           no-undo.
def input-output param beg-date1 as date              no-undo.
def output param xresult-ref     as decimal           no-undo.

DEF VAR mSince       AS DATE                 NO-UNDO.
DEF VAR mPenCommi    AS CHAR                 NO-UNDO.
DEF VAR mPenCommRate AS DECIMAL              NO-UNDO.
DEF VAR dat-commi    AS DATE                 NO-UNDO.
DEF VAR end-commi    AS DATE                 NO-UNDO.
DEF VAR in-status    LIKE op.op-status       NO-UNDO.
DEF VAR comm-ost     like acct-pos.balance   no-undo.

DEF VAR vRet-RCom          AS CHARACTER NO-UNDO.

DEFINE VAR vActualRate     AS DECIMAL NO-UNDO. /* Реальная ставка, на которую нужно умножать остаток */
DEFINE VAR vActualCommCode AS CHAR    NO-UNDO. /* Реальный код комиссии */

DEFINE BUFFER bcomm-rate FOR comm-rate.
   {get_status.i}
   in-status = chr(251).
   
   FIND FIRST acct WHERE RECID(acct) EQ rid 
      NO-LOCK NO-ERROR.
   IF NOT AVAIL acct THEN 
      RETURN '{&next1}'.
   
   FIND FIRST interest-sch-line WHERE RECID(interest-sch-line) EQ rid1
      NO-LOCK NO-ERROR.
   
   FIND FIRST loan WHERE loan.contract  eq ENTRY(1,str-kau) 
                     AND loan.cont-code eq ENTRY(2,str-kau)
      NO-LOCK NO-ERROR. 
   
   IF in-commi NE fGetSetting("ЦбРефПред", ?, "%ЦбРеф") THEN
     RUN Get_Last_Param in h_dpspc (RECID(loan),
                                    end-date1,
                                    end-date1,
                                    "commission",
                                    OUTPUT in-commi).
   
   FIND FIRST loan-cond WHERE loan-cond.contract  EQ loan.contract 
                          AND loan-cond.cont-code EQ loan.cont-code
      NO-LOCK NO-ERROR.
   
   {empty fost}
   /*Удаление лишнего */
   run del_kau_ost.
   /* Получение остатков по субаналитическим счетам */
   run cr_summ_ost(beg-date1,
                   end-date1 + 1,
                   rid,
                   IF loan.end-date NE ? THEN 'ОстВклС' 
                                         ELSE 'ОстВклВ', 
                   IF loan.end-date NE ? THEN 'НачПрС1' 
                                         ELSE 'НачПрВ').
   
   /*Пересчет остатков по плановым датам*/
   RUN rclcfost (loan.contract,
                 loan.cont-code,
                 ?,
                 acct.acct,
                 acct.currency).
   
   beg-date1  = beg-date1 + 1.
   
   /* определение параметров лоя выбора комисии - даты, по которой учитывается изменение комиссии - это дата открытия/пролонгации вклада и
   продолжительности вклада , если вклад до востребования, то продолжительность берется = 0 */
   RUN Get_Date_Comm in h_dpspc (RECID(loan),
                                 beg-date1,
                                 OUTPUT dat-commi, 
                                 OUTPUT end-commi).
   
   if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф") then 
      dat-commi = beg.
   
    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.
   
   IF in-commi = fGetSetting("ЦбРефПред", ?, "%ЦБреф") THEN 
   DO: 
      {inter_pn.i
         &offdef = "/*"
         &d-beg      = beg-date1
         &d-end      = end-date1
         &sum        = fost
         &since      = since
         &rcom       = in-commi
         &proc       = xresult
         &balance    = balance
         &comm-rate  = comm-rate         
         &dat-comm   = dat-commi
      }
   END.
   ELSE 
   DO:
      DEFINE VAR lPeriodBegDate AS DATE NO-UNDO.
      DEFINE VAR lCoveredPeriod AS INT64 NO-UNDO.
   
      {empty comm-mp}
      FOR EACH commission WHERE commission.commission EQ in-commi
                          NO-LOCK
                          BREAK BY commission.currency BY commission.min-value BY commission.period:
          IF FIRST-OF(commission.min-value) THEN DO:
             lPeriodBegDate = dat-commi + IF dat-commi EQ loan.open-date /* Начинаем отсчет сроков от даты открытия вклада */
                                          THEN 1
                                          ELSE 0. 
             lCoveredPeriod = 0.
          END.
          /* Определяем основную ставку для выбранного периода  */
          FIND LAST comm-rate WHERE comm-rate.commission =  commission.commission
                                AND comm-rate.currency   =  commission.currency
                                AND comm-rate.min-value  =  commission.min-value
                                AND comm-rate.period     =  commission.period
                                AND comm-rate.acct       =  acct.acct
                                AND comm-rate.since      <= dat-commi
                              NO-LOCK NO-ERROR.
          IF NOT AVAILABLE comm-rate THEN 
          FIND LAST comm-rate WHERE comm-rate.commission =  commission.commission
                                AND comm-rate.filial-id = shfilial
                                AND comm-rate.branch-id = ""
                                AND comm-rate.currency   =  commission.currency
                                AND comm-rate.min-value  =  commission.min-value
                                AND comm-rate.period     =  commission.period
                                AND comm-rate.acct       =  "0"
                                AND comm-rate.since      <= dat-commi
                              NO-LOCK NO-ERROR.
          CREATE comm-mp.
          IF NOT AVAILABLE comm-rate THEN DO:
            ASSIGN
               comm-mp.acct        = "0"
               comm-mp.commission  = commission.commission
               comm-mp.currency    = commission.currency
               comm-mp.kau         = ""
               comm-mp.min-value   = commission.min-value
               comm-mp.rate-comm   = 0
               comm-mp.rate-fixed  = no
               
               comm-mp.since       = lPeriodBegDate
               comm-mp.period      = 0
               comm-mp.cr-recid    = RECID(comm-rate)
               comm-mp.end-per     = lPeriodBegDate + commission.period - lCoveredPeriod - 1
               comm-mp.period-len  = commission.period - lCoveredPeriod
            .
          END.
          ELSE DO:
            BUFFER-COPY comm-rate EXCEPT comm-rate.since TO comm-mp NO-ERROR.  
            ASSIGN 
               comm-mp.since       = lPeriodBegDate
               comm-mp.period      = 0
               comm-mp.cr-recid    = RECID(comm-rate)
               comm-mp.end-per     = lPeriodBegDate + commission.period - lCoveredPeriod - 1
               comm-mp.period-len  = commission.period - lCoveredPeriod
            .
          END.
          
          lPeriodBegDate = lPeriodBegDate + commission.period - lCoveredPeriod.
          lCoveredPeriod = commission.period.
          
          IF LAST-OF(commission.min-value) THEN DO:
             CREATE comm-mp.
             ASSIGN
                comm-mp.acct        = "0"
                comm-mp.commission  = commission.commission
                comm-mp.currency    = commission.currency
                comm-mp.kau         = ""
                comm-mp.min-value   = commission.min-value
                comm-mp.rate-comm   = 0.0
                comm-mp.rate-fixed  = no
                
                comm-mp.since       = lPeriodBegDate
                comm-mp.period      = 0
                comm-mp.cr-recid    = RECID(comm-rate)
                comm-mp.end-per     = ?
                comm-mp.period-len  = ?
             .
          END.
      END.
      
      {inter_pn.i
         &d-beg      = beg-date1
         &d-end      = end-date1
         &sum        = fost
         &since      = since
         &rcom       = in-commi
         &proc       = xresult
         &balance    = balance
         &comm-rate  = comm-mp         
         &dat-comm   = dat-commi
         &cr-recid   = YES            
         &offdef     = "/*"      
         
         &correctsh  = YES
      }
   END.

END PROCEDURE.

/*****************************************************************************/                
PROCEDURE nach_int.
&UNDEFINE DefVarStat
def input param rid1             as recid             no-undo. 
def input param in-commi         like comm-rate.commi no-undo.
def input param rid              as recid             no-undo.
def input param beg              as date              no-undo.
def input param end-date1        as date              no-undo.
def input param str-kau          like kau.kau         no-undo.
def input param fl-print         as logical           no-undo.
def input-output param xresult   as decimal           no-undo.
def input-output param beg-date1 as date              no-undo.
def output param xresult-ref     as decimal           no-undo.

DEF VAR mSince       AS DATE                 NO-UNDO.
DEF VAR mPenCommi    AS CHAR                 NO-UNDO.
DEF VAR mPenCommRate AS DECIMAL              NO-UNDO.
DEF VAR dat-commi    AS DATE                 NO-UNDO.
DEF VAR end-commi    AS DATE                 NO-UNDO.
DEF VAR in-status    LIKE op.op-status       NO-UNDO.
DEF VAR comm-ost     like acct-pos.balance   no-undo.

DEF VAR vRet-RCom          AS CHARACTER NO-UNDO.

DEFINE VAR vActualRate     AS DECIMAL NO-UNDO. /* Реальная ставка, на которую нужно умножать остаток */
DEFINE VAR vActualCommCode AS CHAR    NO-UNDO. /* Реальный код комиссии */

DEFINE BUFFER bcomm-rate FOR comm-rate.
DEFINE VAR ii       AS INT64 NO-UNDO  INIT 1.
   {get_status.i}
   in-status = chr(251).
   
   FIND FIRST acct WHERE RECID(acct) EQ rid 
      NO-LOCK NO-ERROR.
   IF NOT AVAIL acct THEN 
      RETURN '{&next1}'.
   
   FIND FIRST interest-sch-line WHERE RECID(interest-sch-line) EQ rid1
      NO-LOCK NO-ERROR.
   
   FIND FIRST loan WHERE loan.contract  eq ENTRY(1,str-kau) 
                     AND loan.cont-code eq ENTRY(2,str-kau)
      NO-LOCK NO-ERROR. 
   
   IF in-commi NE fGetSetting("ЦбРефПред", ?, "%ЦбРеф") THEN
     RUN Get_Last_Param in h_dpspc (RECID(loan),
                                    end-date1,
                                    end-date1,
                                    "commission",
                                    OUTPUT in-commi).
   
   FIND FIRST loan-cond WHERE loan-cond.contract  EQ loan.contract 
                          AND loan-cond.cont-code EQ loan.cont-code
      NO-LOCK NO-ERROR.
   
   {empty fost}
   /*Удаление лишнего */
   run del_kau_ost.
   /* Получение остатков по субаналитическим счетам */
   run cr_summ_ost(beg-date1,
                   end-date1 + 1,
                   rid,
                   IF loan.end-date NE ? THEN 'ОстВклС' 
                                         ELSE 'ОстВклВ', 
                   IF loan.end-date NE ? THEN 'НачПрС1' 
                                         ELSE 'НачПрВ').
   
   /*Пересчет остатков по плановым датам*/
   RUN rclcfost (loan.contract,
                 loan.cont-code,
                 ?,
                 acct.acct,
                 acct.currency).
   
   beg-date1  = beg-date1 + 1.
   
   /* определение параметров лоя выбора комисии - даты, по которой учитывается изменение комиссии - это дата открытия/пролонгации вклада и
   продолжительности вклада , если вклад до востребования, то продолжительность берется = 0 */
   RUN Get_Date_Comm in h_dpspc (RECID(loan),
                                 beg-date1,
                                 OUTPUT dat-commi, 
                                 OUTPUT end-commi).
   
   if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф") then 
      dat-commi = beg.
   
    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.
   
   IF in-commi = fGetSetting("ЦбРефПред", ?, "%ЦБреф") THEN 
   DO: 
      {inter_pn.i
         &offdef = "/*"
         &d-beg      = beg-date1
         &d-end      = end-date1
         &sum        = fost
         &since      = since
         &rcom       = in-commi
         &proc       = xresult
         &balance    = balance
         &comm-rate  = comm-rate         
         &dat-comm   = dat-commi
      }
   END.
   ELSE 
   DO:
      DEFINE VAR lPeriodBegDate AS DATE NO-UNDO.
      DEFINE VAR lCoveredPeriod AS INT64 NO-UNDO.
   
      {empty comm-mp}
      FOR EACH commission WHERE commission.commission EQ in-commi
                          NO-LOCK
                          BREAK BY commission.currency BY commission.min-value BY commission.period:
          IF FIRST-OF(commission.min-value) THEN DO:
             lPeriodBegDate = dat-commi + IF dat-commi EQ loan.open-date /* Начинаем отсчет сроков от даты открытия вклада */
                                          THEN 1
                                          ELSE 0. 
             lCoveredPeriod = 0.
          END.
          /* Определяем основную ставку для выбранного периода  */
          FIND LAST comm-rate WHERE comm-rate.commission =  commission.commission
                                AND comm-rate.currency   =  commission.currency
                                AND comm-rate.min-value  =  commission.min-value
                                AND comm-rate.period     =  commission.period
                                AND comm-rate.acct       =  acct.acct
                                AND comm-rate.since      <= dat-commi
                              NO-LOCK NO-ERROR.
          IF NOT AVAILABLE comm-rate THEN 
          FIND LAST comm-rate WHERE comm-rate.commission =  commission.commission
                                AND comm-rate.filial-id = shfilial
                                AND comm-rate.branch-id = ""
                                AND comm-rate.currency   =  commission.currency
                                AND comm-rate.min-value  =  commission.min-value
                                AND comm-rate.period     =  commission.period
                                AND comm-rate.acct       =  "0"
                                AND comm-rate.since      <= dat-commi
                              NO-LOCK NO-ERROR.
          CREATE comm-mp.
          IF NOT AVAILABLE comm-rate THEN DO:
            ASSIGN
               comm-mp.acct        = "0"
               comm-mp.commission  = commission.commission
               comm-mp.filial-id   = shfilial
               comm-mp.currency    = commission.currency
               comm-mp.kau         = ""
               comm-mp.min-value   = commission.min-value
               comm-mp.rate-comm   = 0
               comm-mp.rate-fixed  = no
               
               comm-mp.since       = lPeriodBegDate
               comm-mp.period      = 0
               comm-mp.cr-recid    = RECID(comm-rate)
               comm-mp.end-per     = lPeriodBegDate + commission.period - lCoveredPeriod - 1
               comm-mp.period-len  = commission.period - lCoveredPeriod
               comm-mp.comm-rate-id = comm-mp.comm-rate-id + 1
            .
          END.
          ELSE DO:
            BUFFER-COPY comm-rate EXCEPT comm-rate.since TO comm-mp NO-ERROR.  
            ASSIGN 
               comm-mp.since       = lPeriodBegDate
               comm-mp.filial-id   = shfilial
               comm-mp.period      = 0
               comm-mp.cr-recid    = RECID(comm-rate)
               comm-mp.end-per     = lPeriodBegDate + commission.period - lCoveredPeriod - 1
               comm-mp.period-len  = commission.period - lCoveredPeriod
               comm-mp.comm-rate-id = comm-mp.comm-rate-id + 1
            .
          END.
          
          lPeriodBegDate = lPeriodBegDate + commission.period - lCoveredPeriod.
          lCoveredPeriod = commission.period.
          
          IF LAST-OF(commission.min-value) THEN DO:
             CREATE comm-mp.
             ASSIGN
                comm-mp.acct        = "0"
                comm-mp.commission  = commission.commission
                comm-mp.filial-id   = shfilial
                comm-mp.currency    = commission.currency
                comm-mp.kau         = ""
                comm-mp.min-value   = commission.min-value
                comm-mp.rate-comm   = 0.0
                comm-mp.rate-fixed  = no
                
                comm-mp.since       = lPeriodBegDate
                comm-mp.period      = 0
                comm-mp.cr-recid    = RECID(comm-rate)
                comm-mp.end-per     = ?
                comm-mp.period-len  = ?
                comm-mp.comm-rate-id = comm-mp.comm-rate-id + ii
                ii = ii + 1 
             .
          END.
      END.
      
      {inter_pn.i
         &d-beg      = beg-date1
         &d-end      = end-date1
         &sum        = fost
         &since      = since
         &rcom       = in-commi
         &proc       = xresult
         &balance    = balance
         &comm-rate  = comm-mp         
         &dat-comm   = dat-commi
         &cr-recid   = YES            
         &offdef     = "/*"      
      }
   END.

END PROCEDURE.

/*****************************************************************************/                
PROCEDURE nach_bal.
    &UNDEFINE DefVarStat
    def input param rid1 as recid no-undo .
    def input param  in-commi like comm-rate.commi no-undo .
    def input param rid as recid no-undo .
    def input param beg as date no-undo .
    def input param end-date1  as date no-undo .
    def input param str-kau like kau.kau no-undo .
    def input param fl-print as logical no-undo .
    def input-output param xresult as decimal no-undo .
    def input-output param beg-date1 as date no-undo .
    def output param xresult-ref as decimal no-undo .

    def var month-day as logical no-undo.
    def var delay as INT64 init 1 no-undo  .
    def var dat-commi as date no-undo .
    def var in-surrogate as char no-undo .
    def var i as INT64 no-undo .
    def var in-status  like op.op-status  no-undo.

    def var actual_kind like loan.op-kind no-undo. /* Код действующей транзакции */
    def var curr_intvl  as char           no-undo. /* Длительность вклада */
    def var vPeriodInt  as INT64          no-undo. /* Реальная продолжительность вкалада */
    def var end-commi   as date           no-undo.
    DEF VAR mProcP      AS CHAR           NO-UNDO. /* имя процедуры определения штрафной ставки */
    DEF VAR mStavP      AS CHAR           NO-UNDO. /* Код штрафной ставки */


    /*def new global shared var  h_ref as handle no-undo .*/

    def buffer xop-entry  for op-entry.
    def buffer yop-templ  for op-templ.
    def buffer xkau-entry for kau-entry.
    {get_status.i}
    in-status = chr(251) .
    find acct where recid(acct) eq rid no-lock no-error .
    if not avail acct then return '{&next1}' .

    find interest-sch-line where recid(interest-sch-line) eq rid1 no-lock
    no-error .
    find loan where loan.contract eq entry(1,str-kau) and loan.cont-code eq entry(2,str-kau) no-lock no-error .
    find first loan-cond WHERE loan-cond.contract EQ loan.contract
                           AND loan-cond.cont-code EQ loan.cont-code
                                                    no-lock no-error.
    if not avail loan-cond then do:
       xresult = 0.
       RETURN '{&next1}'.
    end.
    /* Поиск метода для переопределения кода ставки */
    IF in-commi NE fGetSetting("ЦбРефПред", ?, "%ЦбРеф") THEN
       RUN Get_Last_Param in h_dpspc (RECID(loan),
                                      beg-date1,
                                      beg-date1,
                                      "МетодШтрСт",
                                      OUTPUT mProcP).
    IF     {assigned mProcP}
       AND mProcP NE "?"
    THEN DO:
       /* поиск внешней процедуры */
       IF SearchPFile(mProcP) THEN 
          RUN VALUE(mProcP + ".p") (INPUT RECID(loan),
                                    INPUT beg-date1, 
                                    INPUT end-date1,
                                    OUTPUT mStavP).
       ELSE
          RUN VALUE(mProcP)        (INPUT RECID(loan),
                                    INPUT beg-date1,
                                    INPUT end-date1,
                                    OUTPUT mStavP).
       IF {assigned mStavP} THEN in-commi = mStavP.
    END.

    {work_39.i beg-date1 end-date1 in-status  acct }
    /*Пересчет остатков по плановым датам*/

    IF vPlane_date  THEN
        RUN rclcfost (loan.contract,
                      loan.cont-code,
                      ?,
                      acct.acct,
                      acct.currency
                      ).
    beg-date1  = beg-date1 + 1.

    /* определение параметров лоя выбора комисии - даты, по которой учитывается изменение комиссии - это дата открытия/пролонгации вклада и
     продолжительности вклада , если вклад до востребования, то продолжительность берется = 0 */
    run Get_Date_Comm in h_dpspc (recid(loan),beg-date1,output dat-commi, output end-commi) .
    if end-commi = ? then vperiodint = 0 .
    else run depos-dep-period in h_dpspc (recid(loan),beg-date1, output vPeriodInt) .


/*
    IF  in-commi EQ fGetSetting("ЦбРефПред", ?, "%ЦбРеф") then 
        dat-commi = beg .
        
    {refin39.i "inter39.i" vPeriodInt}
   
*/
    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.

    { inter39n.i
         &d-beg=beg-date1
         &d-end=end-date1
         &comm-rate=comm-rate
         &sum=fost
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &since1=" le dat-commi "
         &dat-commi=dat-commi
         &in-bal=YES
         &vPeriodInt = vPeriodInt
         &half=YES
         &offdef="/*"
    }

END PROCEDURE.
                
PROCEDURE nach39.
    &UNDEFINE NoDel  
    &UNDEFINE DefVarStat
    def input param rid1 as recid no-undo .
    def input param  in-commi like comm-rate.commi no-undo .
    def input param rid as recid no-undo .
    def input param beg as date no-undo .
    def input param end-date1  as date no-undo .
    def input param str-kau like kau.kau no-undo .
    def input param fl-print as logical no-undo .
    def input-output param xresult as decimal no-undo .
    def input-output param beg-date1 as date no-undo .
    def output param xresult-ref as decimal no-undo .

    def var month-day as logical no-undo.
    def var delay as INT64 init 1 no-undo  .
    def var dat-commi as date no-undo .
    def var in-surrogate as char no-undo .
    def var i as INT64 no-undo .
    def var in-status  like op.op-status  no-undo.

    def var actual_kind like loan.op-kind no-undo. /* Код действующей транзакции */
    def var curr_intvl  as char           no-undo. /* Длительность вклада */
    def var vPeriodInt   as INT64           no-undo. /* Реальная продолжительность вкалада */
    def var end-commi as date no-undo .
    DEF VAR mProcP    AS CHAR   NO-UNDO.           /* имя процедуры определения штрафной ставки */
    DEF VAR mStavP    AS CHAR   NO-UNDO.           /* Код штрафной ставки */


    def buffer xop-entry  for op-entry.
    def buffer yop-templ  for op-templ.
    def buffer xkau-entry for kau-entry.
    {get_status.i}

    in-status = chr(251) .
    find acct where recid(acct) eq rid no-lock no-error .
    if not avail acct then return '{&next1}' .

    find interest-sch-line where recid(interest-sch-line) eq rid1 no-lock
    no-error .
    find loan where loan.contract eq entry(1,str-kau) and loan.cont-code eq entry(2,str-kau) no-lock no-error .
    find first loan-cond WHERE loan-cond.contract EQ loan.contract
                           AND loan-cond.cont-code EQ loan.cont-code
                                                    no-lock no-error.
    if not avail loan-cond then do:
       xresult = 0.
       RETURN '{&next1}'.
    end.
    
    /* Поиск метода для переопределения кода ставки */
    IF in-commi NE fGetSetting("ЦбРефПред", ?, "%ЦбРеф") THEN
       RUN Get_Last_Param in h_dpspc (RECID(loan),
                                      beg-date1,
                                      beg-date1,
                                      "МетодШтрСт",
                                      OUTPUT mProcP).
    IF     {assigned mProcP}
       AND mProcP NE "?"
    THEN DO:
       /* поиск внешней процедуры */
       IF SearchPFile(mProcP) THEN 
          RUN VALUE(mProcP + ".p") (INPUT RECID(loan),
                                    INPUT beg-date1, 
                                    INPUT end-date1,
                                    OUTPUT mStavP).
       ELSE
          RUN VALUE(mProcP)        (INPUT RECID(loan),
                                    INPUT beg-date1, 
                                    INPUT end-date1,
                                    OUTPUT mStavP).
       IF {assigned mStavP} THEN in-commi = mStavP.
    END.
    
    {work_39.i beg-date1 end-date1 in-status  acct }
    IF vPlane_date  THEN
        /*Пересчет остатков по плановым датам*/
        RUN rclcfost (loan.contract,
                      loan.cont-code,
                      ?,
                      acct.acct,
                      acct.currency
                      ).
    ASSIGN
        beg-date1  = beg-date1 + 1 .
    /* определение параметров лоя выбора комисии - даты, по которой учитывается изменение комиссии - это дата открытия/пролонгации вклада и
     продолжительности вклада , если вклад до востребования, то продолжительность берется = 0 */
    run Get_Date_Comm in h_dpspc (recid(loan),beg-date1,output dat-commi, output end-commi) .
    if end-commi = ? then vperiodint = 0 .
    else run depos-dep-period in h_dpspc (recid(loan),beg-date1, output vPeriodInt) .

    /*Продолжительность вклада*/
    if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф") then dat-commi = beg .
/*    {refin39.i "inter39.i"  vPeriodInt}*/

    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.

    {inter39n.i
         &d-beg=beg-date1
         &d-end=end-date1
         &comm-rate=comm-rate
         &sum=fost
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &since1=" le dat-commi "
         &dat-commi=dat-commi
         &vPeriodInt = vPeriodInt
         &half=YES
         &offdef="/*"
    }
END PROCEDURE.
                
PROCEDURE nach_pl.
    &UNDEFINE NoDel    
    &UNDEFINE DefVarStat 
    def input param rid1 as recid no-undo.
    def input param in-commi like comm-rate.commi no-undo.
    def input param rid as recid no-undo.
    def input param beg as date no-undo.
    def input param end-date1  as date no-undo.
    def input param str-kau like kau.kau no-undo.
    def input param fl-print as logical no-undo.
    def input-output param xresult as decimal no-undo.
    def input-output param beg-date1 as date no-undo.
    def output param xresult-ref as decimal no-undo.

    def var month-day as logical no-undo.
    def var delay as INT64 init 1 no-undo.
    def var in-status like op.op-status no-undo.
    def var dat-comm as date no-undo .    

    find first acct where recid(acct) eq rid no-lock no-error .
    if not avail acct then return '{&next1}' .

    find interest-sch-line where recid(interest-sch-line) eq rid1
                     no-lock no-error .

    find loan where loan.contract  eq entry(1,str-kau) and
            loan.cont-code eq entry(2,str-kau)
            no-lock no-error.
    {get_status.i}
    in-status = chr(251).

    {work_39.i beg-date1 end-date1 in-status  acct }
    IF vPlane_date  THEN
        /*Пересчет остатков по плановым датам*/
        RUN rclcfost (loan.contract,
                      loan.cont-code,
                      ?,
                      acct.acct,
                      acct.currency
                      ).

    dat-comm = beg .
    beg-date1 = beg-date1 + 1.
 /*   {refin39.i "inter_pl.i" }*/

    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.

    {intr_pln.i
         &d-beg=beg-date1
         &d-end=end-date1
         &sum=fost
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &comm-rate=comm-rate
         &dat-comm=dat-comm
         &offdef="/*"
    }
END PROCEDURE.


PROCEDURE nach5995.
    &UNDEFINE NoDel  
    &UNDEFINE DefVarStat
    def input        param rid1        as recid             no-undo.
    def input        param in-commi    like comm-rate.commi no-undo.
    def input        param rid         as recid             no-undo.
    def input        param beg         as date              no-undo.
    def input        param end-date1   as date              no-undo.
    def input        param str-kau     like kau.kau         no-undo.
    def input        param fl-print    as logical           no-undo.
    def input-output param xresult     as decimal           no-undo.
    def input-output param beg-date1   as date              no-undo.
    def output       param xresult-ref as decimal           no-undo.
    
    def var month-day    as logical        no-undo.
    def var delay        as INT64 init 1     no-undo.
    def var dat-commi    as date           no-undo.
    def var end-commi    as date           no-undo.
    def var in-surrogate as char           no-undo.
    def var i            as INT64            no-undo.
    def var in-status    like op.op-status no-undo.
    def var actual_kind  like loan.op-kind no-undo. /* Код действующей транзакции */
    def var curr_intvl   as char           no-undo. /* Длительность вклада */
    def var vPeriodInt   as INT64          no-undo. /* Реальная продолжительность вкалада */
    DEF VAR mProcP       AS CHAR           NO-UNDO. /* имя процедуры определения штрафной ставки */
    DEF VAR mStavP       AS CHAR           NO-UNDO. /* Код штрафной ставки */

    
    def buffer xop-entry  for op-entry.
    def buffer yop-templ  for op-templ.
    def buffer xkau-entry for kau-entry.
    {get_status.i}
    in-status = chr(251).
    
    FIND acct WHERE RECID(acct) EQ rid NO-LOCK NO-ERROR.
    IF NOT AVAIL acct THEN RETURN '{&next1}'.
    
    FIND interest-sch-line WHERE RECID(interest-sch-line) EQ rid1
    NO-LOCK NO-ERROR.
    
    FIND loan WHERE 
        loan.contract  eq ENTRY(1,str-kau) AND 
        loan.cont-code eq ENTRY(2,str-kau)
    NO-LOCK NO-ERROR. 
    
    FIND FIRST loan-cond WHERE 
        loan-cond.contract  EQ loan.contract AND
        loan-cond.cont-code EQ loan.cont-code
    NO-LOCK NO-ERROR.
    /* Поиск метода для переопределения кода ставки */
    IF in-commi NE fGetSetting("ЦбРефПред", ?, "%ЦбРеф") THEN
       RUN Get_Last_Param in h_dpspc (RECID(loan),
                                      beg-date1,
                                      beg-date1,
                                      "МетодШтрСт",
                                      OUTPUT mProcP).

    IF     {assigned mProcP}
       AND mProcP NE "?"
    THEN DO:
       /* поиск внешней процедуры */
       IF SearchPFile(mProcP) THEN 
          RUN VALUE(mProcP + ".p") (INPUT RECID(loan),
                                    INPUT beg-date1, 
                                    INPUT end-date1,
                                    OUTPUT mStavP).
       ELSE
          RUN VALUE(mProcP)        (INPUT RECID(loan),
                                    INPUT beg-date1,
                                    INPUT end-date1,
                                    OUTPUT mStavP).
       IF {assigned mStavP} THEN in-commi = mStavP.
    END.

    
    {work_39.i beg-date1 end-date1 in-status acct}
    
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
      RUN rclcfost (loan.contract,
                    loan.cont-code,
                    ?,
                    acct.acct,
                    acct.currency
                   ).
    /* Определение виртуальной даты начала вклада */
    RUN get-beg-date-prol in h_dpspc (RECID(loan),end-date1,OUTPUT dat-commi, OUTPUT end-commi).
    
    /*Получаем публикуемую плановую дату. Если из просмотра состояния - считаем глобальную*/
    IF DATE(GetSysConf("op-contract-date")) NE ?
      THEN ASSIGN end-commi = DATE(GetSysConf("op-contract-date")).
      ELSE ASSIGN end-commi = gend-date.
    
    if loan.prolong = 0 then dat-commi = loan.open-date.
    beg-date1  = beg-date1 + 1.

    /* Сколько реально отлежал вклад на дату операции */
    {period_comm.i}
    
    if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф")
    then dat-commi = beg.
    
    /*{refin39.i "inter39.i" vPeriodInt}*/

    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.
    
    {inter39n.i
        &d-beg      = beg-date1
        &d-end      = end-date1
        &comm-rate  = comm-rate
        &sum        = fost
        &since      = since
        &rcom       = in-commi
        &proc       = xresult
        &balance    = balance
        &since1     = " le dat-commi "
        &dat-commi  = dat-commi
        &vPeriodInt = vPeriodInt
        &offdef     = "/*"
    }
END PROCEDURE.
                         
PROCEDURE nch5995k.
    &UNDEFINE NoDel  
    &UNDEFINE DefVarStat
    def input        param rid1        as recid             no-undo.
    def input        param in-commi    like comm-rate.commi no-undo.
    def input        param rid         as recid             no-undo.
    def input        param beg         as date              no-undo.
    def input        param end-date1   as date              no-undo.
    def input        param str-kau     like kau.kau         no-undo.
    def input        param fl-print    as logical           no-undo.
    def input-output param xresult     as decimal           no-undo.
    def input-output param beg-date1   as date              no-undo.
    def output       param xresult-ref as decimal           no-undo.
    
    def var month-day    as logical        no-undo.
    def var delay        as INT64 init 1     no-undo.
    def var dat-commi    as date           no-undo.
    def var end-commi    as date           no-undo.
    def var in-surrogate as char           no-undo.
    def var i            as INT64            no-undo.
    def var in-status    like op.op-status no-undo.
    def var actual_kind  like loan.op-kind no-undo. /* Код действующей транзакции */
    def var curr_intvl   as char           no-undo. /* Длительность вклада */
    def var vPeriodInt   as INT64            no-undo. /* Реальная продолжительность вкалада */
    DEF VAR vNoDef       AS CHAR           NO-UNDO. /* комментарий, если не надо обьявлять 
                                                      переменные в инклюдах начисления процентов */
    
    def buffer xop-entry  for op-entry.
    def buffer yop-templ  for op-templ.
    def buffer xkau-entry for kau-entry.
    {get_status.i}
    in-status = chr(251).
    
    FIND acct WHERE RECID(acct) EQ rid NO-LOCK NO-ERROR.
    IF NOT AVAIL acct THEN RETURN '{&next1}'.
    
    FIND interest-sch-line WHERE RECID(interest-sch-line) EQ rid1
    NO-LOCK NO-ERROR.
    
    FIND loan WHERE 
        loan.contract  eq ENTRY(1,str-kau) AND 
        loan.cont-code eq ENTRY(2,str-kau)
    NO-LOCK NO-ERROR. 
    
    FIND FIRST loan-cond WHERE 
        loan-cond.contract  EQ loan.contract AND
        loan-cond.cont-code EQ loan.cont-code
    NO-LOCK NO-ERROR.
    
    {empty fost}
    /*Удаление лишнего */
    run del_kau_ost.
    /* Получение остатков по субаналитическим счетам */
    run cr_summ_ost(beg-date1,
                    end-date1 + 1,rid,
                    IF loan.end-date <> ? 
                        THEN 'ОстВклС' 
                        ELSE 'ОстВклВ', 
                    IF loan.end-date <> ? 
                        THEN 'НачПрС1' 
                        ELSE 'НачПрВ'
                    ).
    
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
      RUN rclcfost (loan.contract,
                    loan.cont-code,
                    ?,
                    acct.acct,
                    acct.currency
                   ).
    /* Определение виртуальной даты начала вклада */
    RUN get-beg-date-prol in h_dpspc (RECID(loan),end-date1,OUTPUT dat-commi, OUTPUT end-commi).
    
    /*Получаем публикуемую плановую дату. Если из просмотра состояния - считаем глобальную*/
    IF DATE(GetSysConf("op-contract-date")) NE ?
      THEN ASSIGN end-commi = DATE(GetSysConf("op-contract-date")).
      ELSE ASSIGN end-commi = gend-date.
    
    if loan.prolong = 0 then dat-commi = loan.open-date.
    beg-date1  = beg-date1 + 1.
    
    RUN correct_date IN h_dpspc (RECID(loan),INPUT-OUTPUT dat-commi).
    
    /* Сколько реально отлежал вклад на дату операции */
    {period_comm.i}
    
    if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф")
    then dat-commi = beg.
    
    /*{refin39.i "inter39.i" vPeriodInt}*/

    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.
    
    {inter39n.i
        &d-beg      = beg-date1
        &d-end      = end-date1
        &comm-rate  = comm-rate
        &sum        = fost
        &since      = since
        &rcom       = in-commi
        &proc       = xresult
        &balance    = balance
        &since1     = " le dat-commi "
        &dat-commi  = dat-commi
        &vPeriodInt = vPeriodInt
        &offdef     = "/*"
    }
END PROCEDURE.

PROCEDURE nach6606.
   &UNDEFINE DefVarStat
    def input        param rid1        as recid             no-undo. /*ук-тель на параметр схемы начисления процентов*/
    def input        param in-commi    like comm-rate.commi no-undo. /*код комиссии*/
    def input        param rid         as recid             no-undo. /*ук-тель на счет*/
    def input        param beg         as date              no-undo.
    def input        param end-date1   as date              no-undo.
    def input        param str-kau     like kau.kau         no-undo.
    def input        param fl-print    as logical           no-undo.
    def input-output param xresult     as decimal           no-undo.
    def input-output param beg-date1   as date              no-undo.
    def output       param xresult-ref as decimal           no-undo.

    def var month-day    as logical        no-undo.
    def var delay        as INT64 init 1     no-undo.
    def var dat-commi    as date           no-undo.
    def var end-commi    as date           no-undo.
    DEF VAR end-date_1   AS DATE           NO-UNDO.
    def var in-surrogate as char           no-undo.
    def var i            as INT64            no-undo.
    def var in-status    like op.op-status no-undo.
    def var actual_kind  like loan.op-kind no-undo. /* Код действующей транзакции */
    def var curr_intvl   as char           no-undo. /* Длительность вклада */
    def var vPeriodInt   as INT64            no-undo. /* Реальная продолжительность вкалада */

    DEF VAR sub-commi    like comm-rate.commi no-undo. /*код комиссии*/
    DEF VAR sub-commi-v  AS  DECIMAL  NO-UNDO.         /*процент базовой комиссии*/
    def VAR k            AS  DECIMAL  NO-UNDO INIT 0.
    DEF VAR vOsnStavka   AS RECID NO-UNDO.
    DEF VAR vOsnStavkaRate   AS DEC NO-UNDO.
    DEF VAR vNoDef       AS CHAR           NO-UNDO. /* комментарий, если не надо обьявлять 
                                                      переменные в инклюдах начисления процентов */

    def buffer xop-entry  for op-entry.
    def buffer yop-templ  for op-templ.
    def buffer xkau-entry for kau-entry.

    RUN Init-SysMes ("","","").
    {get_status.i}
    in-status = chr(251).

    find acct where
        recid(acct) eq rid
    no-lock no-error.

    if not avail acct
    then return '{&next1}'.

    /*Параметр схемы начисления процентов*/
    find interest-sch-line where
        recid(interest-sch-line) eq rid1
    no-lock no-error.

    find loan where
         loan.contract  eq entry(1,str-kau) and
         loan.cont-code eq entry(2,str-kau)
    no-lock no-error.

    find first loan-cond where
               loan-cond.contract  eq loan.contract and
               loan-cond.cont-code eq loan.cont-code
    no-lock no-error.


    {work_39.i beg-date1 end-date1 in-status acct}
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
      RUN rclcfost (loan.contract,
                      loan.cont-code,
                      ?,
                      acct.acct,
                      acct.currency
                     ).
    /* Определение виртуальной даты начала вклада */
    RUN get-beg-date-prol in h_dpspc (RECID(loan),end-date1,OUTPUT dat-commi, OUTPUT end-commi).

    if loan.prolong = 0 then dat-commi = loan.open-date.

    ASSIGN
        end-date_1 = IF loan.end-date <> ? AND loan.end-date > end-date1
                     THEN loan.end-date
                     ELSE end-date1
        beg-date1  = beg-date1 + 1
        vPeriodInt = cDay( interest-sch-line.interest-month,
                           dat-commi,
                           end-date_1)
    .

    /* Если %ЦБРеф, то ищем стандартно */
    if in-commi EQ fGetSetting("ЦбРефПред", ?, "%ЦбРеф") THEN DO:
       ASSIGN
          vPeriodInt = 0
          dat-commi = beg.
/*     {refin39.i "inter39.i"  vPeriodInt} */

       IF GetSysConf("OldRef") EQ "Да" THEN DO:
          {refin39n.i}
       END.

       { inter39n.i
            &d-beg=beg-date1
            &d-end=end-date1
            &comm-rate=comm-rate
            &sum=fost
            &since=since
            &rcom=in-commi
            &proc=xresult
            &balance=balance
            &since1=" le dat-commi "
            &dat-commi=dat-commi
            &vPeriodInt = vPeriodInt
            &offdef="/*"
       }

    END.
    ELSE DO:
       /*Ищем основную комиссию на дату начала договора*/
       { findcom1.i
           &dir       = last
           &rsum      = k
           &since1    = " <= dat-commi "
                  &rcom      = in-commi
                  &comm-rate = comm-rate
        }
        if NOT AVAILABLE comm-rate THEN DO:
           RUN Fill-SysMes ("",
                            "dps_n001",
                            "",
                            "").
           RETURN '{&next1}'.
        END.
        
        /*Сохраняем, т.к. иначе PUBLISH вернет нам базовую ставку, а не основную.*/
        ASSIGN vOsnStavka = RECID(comm-rate).

        /*ищем соответствующий вид комиссии */
        FIND FIRST commission WHERE
                   commission.commission = comm-rate.commission
               AND commission.currency   = comm-rate.currency
               AND commission.MIN-VALUE  = 0
               AND commission.period     = comm-rate.period NO-LOCK NO-ERROR.

        /*если не вида комиссии, то это ошибка - нельзя определить
          базовую комиссию */
       if NOT AVAILABLE commission THEN DO:
          RUN Fill-SysMes ("",
                           "dps_n002",
                           "",
                           "").
          RETURN '{&next1}'.
       END.


       ASSIGN
          sub-commi   = commission.base-comm
          sub-commi-v = comm-rate.rate-comm
          .
       if sub-commi = "" or sub-commi = ? then RETURN '{&next1}'.

       release comm-rate.

       IF GetSysConf("OldRef") EQ "Да" THEN DO:
          {refin39n.i 
             &offdef="/*"}
       END.

       {inter66n.i
           &offdef = "/*"
           &d-beg      = beg-date1
           &d-end      = end-date1
           &comm-rate  = comm-rate
           &sum        = fost
           &since      = since
           &rcom       = sub-commi
           &proc       = xresult
           &balance    = balance
           &dat-commi  = dat-commi
           &vPeriodInt = vPeriodInt  
       }
    END.
END PROCEDURE.
                
PROCEDURE nach-mp.
    &UNDEFINE NoDel  
    &UNDEFINE DefVarStat
    def input param rid1 as recid no-undo. 
    def input param in-commi like comm-rate.commi no-undo.
    def input param rid as recid no-undo.
    def input param beg as date no-undo.
    def input param end-date1  as date no-undo.
    def input param str-kau like kau.kau no-undo.
    def input param fl-print as logical no-undo.
    def input-output param xresult as decimal no-undo.
    def input-output param beg-date1 as date no-undo.
    def output param xresult-ref as decimal no-undo.
    
    def var month-day as logical no-undo.
    def var delay as INT64 init 1 no-undo.
    def var in-status like op.op-status no-undo.
    def var dat-comm as date no-undo .
    DEF VAR vop-date1 AS DATE NO-UNDO.
    DEF VAR cl-date1  AS DATE NO-UNDO.
    
    def var dat_start as date no-undo. /* Начало периода начисление процентов */
    def var i as INT64 no-undo .
    def var ii as INT64 no-undo .
    DEF VAR dd1 AS DATE NO-UNDO.

    {get_status.i}
    
    find acct where recid(acct) eq rid no-lock no-error .
    if not avail acct then return '{&next1}' .
    
    find interest-sch-line where recid(interest-sch-line) eq rid1
                  no-lock no-error .
    
    find loan where loan.contract  eq entry(1,str-kau) and
          loan.cont-code eq entry(2,str-kau)
          no-lock no-error.
    
    /******************* формирование temp-table вместо comm-rate ***********************************************/
    find last loan-cond where loan-cond.contract = loan.contract             
                          and loan-cond.cont-code = loan.cont-code
                           and loan-cond.since <= beg-date1 + 1  /*loan.open-date*/ no-lock no-error. /* дата начала отрезка начисления */
    
    /*  выражение beg-date1 заменено на beg-date1 + 1 - так как
       новое начисление идет с beg-date1 + 1  и именно относительно
       этой даты должна определяться дата переоформления вклада */
    RUN get-beg-date-prol in h_dpspc(RECID(loan),
                                             beg-date1 + 1 ,
                                             OUTPUT vop-date1,
                                             OUTPUT cl-date1).
    
    
    /* четыре % периода по вкладу: */
    /* первый % период: */
    {empty comm-mp}
    find LAST comm-rate WHERE comm-rate.commi eq in-commi and
                                comm-rate.acct eq acct.acct AND comm-rate.currency eq acct.currency and
                                comm-rate.since LE vop-date1                no-lock no-error.
    if not avail comm-rate THEN
    find LAST comm-rate WHERE comm-rate.commi eq in-commi and
                                comm-rate.filial-id = shfilial and
                                comm-rate.branch-id = "" and
                                comm-rate.acct eq "0" AND comm-rate.currency eq acct.currency and
                                comm-rate.since LE vop-date1                no-lock no-error.
    
    create comm-mp.
    assign comm-mp.commission = comm-rate.commission
           comm-mp.filial-id = comm-rate.filial-id
           comm-mp.currency = comm-rate.currency
           comm-mp.MIN-VALUE = comm-rate.MIN-VALUE
           comm-mp.acct = comm-rate.acct
           comm-mp.since = vop-date1                /* дата начала 1-го процентного периода */
           comm-mp.rate-comm = comm-rate.rate-comm
           comm-mp.rate-fixed = comm-rate.rate-fixed
           comm-mp.period = comm-rate.period
           comm-mp.kau = comm-rate.kau
           comm-mp.cr-recid = RECID(comm-rate)
           comm-mp.comm-rate-id = comm-rate.comm-rate-id
    .
    /* 2-й, 3-й, 4-й % периоды: */
    dd1 = vop-date1 + 1. 
    
    REPEAT ii = 2 TO 4:
        if avail loan-cond then do:
           def var isOK as LOGICAL INIT TRUE.
           /* вычисляем СРАЗУ реальную дату начисления %%
              // тут была процедура datenach.p которая теперь называется DateOfCharge и лежит в h_dpspc
              НЕ НАДО ее менять обратно на datenach - datenach больше НЕТУ!!!!!! Вообще. */
           RUN DateOfCharge in h_dpspc( dd1, recid(loan-cond), OUTPUT dat_start). /* dat_start - дата начисл % = дате оконч. %-ного периода */
           IF dat_start NE ? THEN DO:
              /*если есть проблемы с выходными (в эту дату нельзя начислять) */
              IF NOT chk_date (recid(loan-cond), dat_start) THEN DO:
                 isOK = FALSE.
                 repeat i = 0 to 30:
                    if chk_date(recid(loan-cond), dat_start + i ) then do:
                       isOK = yes.
                       leave.
                    end.
                    hide message no-pause .
                 end.
                 dat_start = dat_start + i.
              END.
           END.
    
           find LAST comm-rate where comm-rate.commi eq in-commi and
                                    comm-rate.acct eq acct.acct AND comm-rate.currency eq acct.currency and
                                    comm-rate.since LE dat_start + 1               no-lock no-error.
           if not avail comm-rate THEN
           find LAST comm-rate WHERE comm-rate.commi eq in-commi and
                                    comm-rate.filial-id = shfilial and
                                    comm-rate.branch-id = "" and
                                    comm-rate.acct eq "0" and comm-rate.currency eq acct.currency and
                                    comm-rate.since LE dat_start + 1               no-lock no-error.
           
    
           IF dat_start NE ? AND isOK THEN DO:
              IF NOT CAN-FIND (FIRST comm-mp WHERE
                      comm-mp.commission = comm-rate.commission AND
                      comm-mp.filial-id = comm-rate.filial-id AND
                      comm-mp.currency = comm-rate.currency AND
                      comm-mp.MIN-VALUE = comm-rate.MIN-VALUE AND
                      comm-mp.acct = comm-rate.acct AND
                      comm-mp.since = dat_start + 1 AND   /* дата начала i-го процентного периода */
                      comm-mp.rate-comm = comm-rate.rate-comm AND
                      comm-mp.rate-fixed = comm-rate.rate-fixed AND
                      comm-mp.period = comm-rate.period AND
                      comm-mp.kau = comm-rate.kau)
              THEN
                 create comm-mp.
                 assign  comm-mp.commission = comm-rate.commission
                         comm-mp.filial-id = comm-rate.filial-id
                         comm-mp.currency = comm-rate.currency
                         comm-mp.MIN-VALUE = comm-rate.MIN-VALUE
                         comm-mp.acct = comm-rate.acct
                         comm-mp.since = dat_start + 1    /* дата начала i-го процентного периода */
                         comm-mp.rate-comm = comm-rate.rate-comm
                         comm-mp.rate-fixed = comm-rate.rate-fixed
                         comm-mp.period = comm-rate.period
                         comm-mp.kau = comm-rate.kau
                         comm-mp.cr-recid = RECID(comm-rate)
                         comm-mp.comm-rate-id = comm-rate.comm-rate-id  + ii - 1  
                 .
           END.
        end.
        dd1 = dat_start + 1.
    END.
    /**************** конец ("формирование temp-table вместо comm-rate") **************************/

    in-status = chr(251).
    
    {work_39.i beg-date1 end-date1 in-status  acct }
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
      RUN rclcfost (loan.contract,
                      loan.cont-code,
                      ?,
                      acct.acct,
                      acct.currency
                     ).
    
    dat-comm = beg .
    beg-date1 = beg-date1 + 1.     
    
/*
    {refin39.i "inter_pl.i" }
*/     

    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.

    If in-commi <> fGetSetting("ЦбРефПред", ?, "%ЦбРеф")
    THEN DO :
    {intr_pln.i
         &d-beg=beg-date1
         &d-end=end-date1
         &sum=fost
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &comm-rate=comm-mp         /* вместо comm-rate */
         &dat-comm=dat-comm
         &cr-recid = YES
         &offdef="/*"
    }
    END.
    ELSE DO : 
    {intr_pln.i
         &d-beg=beg-date1
         &d-end=end-date1
         &sum=fost
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &comm-rate=comm-rate         
         &dat-comm=dat-comm
         &offdef="/*"
         }     
                  
    END. 

END PROCEDURE.
                
PROCEDURE nchmin_o.
    &UNDEFINE NoDel  
    &UNDEFINE DefVarStat
    def input param rid1 as recid no-undo .
    def input param  in-commi like comm-rate.commi no-undo .
    def input param rid as recid no-undo .
    def input param beg as date no-undo .
    def input param end-date1  as date no-undo .
    def input param str-kau like kau.kau no-undo .
    def input param fl-print as logical no-undo .
    def input-output param xresult as decimal no-undo .
    def input-output param beg-date1 as date no-undo .
    def output param xresult-ref as decimal no-undo .
    
    def var month-day as logical no-undo.
    def var delay as INT64 init 1 no-undo  .
    def var dat-commi as date no-undo .
    def var in-surrogate as char no-undo .
    def var i as INT64 no-undo .
    def var in-status  like op.op-status  no-undo.
    
    def var actual_kind like loan.op-kind no-undo. /* Код действующей транзакции */
    def var curr_intvl  as char           no-undo. /* Длительность вклада */
    def var vPeriodInt   as INT64            no-undo. /* Реальная продолжительность вкалада */
    def var end-commi as date no-undo .
    
    def buffer xop-entry  for op-entry.
    def buffer yop-templ  for op-templ.
    def buffer xkau-entry for kau-entry.

    {get_status.i}
    in-status = chr(251) .
    find acct where recid(acct) eq rid no-lock no-error .
    if not avail acct then return '{&next1}' .
    
    find interest-sch-line where recid(interest-sch-line) eq rid1 no-lock
    no-error .
    find loan where loan.contract eq entry(1,str-kau) and loan.cont-code eq entry(2,str-kau) no-lock no-error .
    find first loan-cond WHERE loan-cond.contract EQ loan.contract
                           AND loan-cond.cont-code EQ loan.cont-code
                                                    no-lock no-error.
    if not avail loan-cond then do:
       xresult = 0.
       RETURN '{&next1}'.
    end.
    
    {work_39.i beg-date1 end-date1 in-status  acct }
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
      RUN rclcfost (loan.contract,
                    loan.cont-code,
                    ?,
                    acct.acct,
                    acct.currency
                    ).
    beg-date1  = beg-date1 + 1.
    /* определение параметров лоя выбора комисии - даты, по которой учитывается изменение комиссии - это дата открытия/пролонгации вклада и
     продолжительности вклада , если вклад до востребования, то продолжительность берется = 0 */
    run get-beg-date-prol in h_dpspc (recid(loan),beg-date1,output dat-commi, output end-commi) .
    if end-commi = ? then vperiodint = 0 .
    else run depos-dep-period in h_dpspc (recid(loan),beg-date1, output vPeriodInt) .
    
    if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф") then dat-commi = beg .
/*    {refin39.i "inter39.i" vPeriodInt}*/
    
    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.

    { inter39n.i
         &d-beg=beg-date1
         &d-end=end-date1
         &comm-rate=comm-rate
         &sum=fost
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &since1=" le dat-commi "
         &dat-commi=dat-commi
         &vPeriodInt = vPeriodInt
         &min-ost  = YES
         &offdef="/*"
    }
END PROCEDURE.

PROCEDURE nachk39.
    &UNDEFINE DefVarStat
    def input param rid1 as recid no-undo .
    def input param  in-commi like comm-rate.commi no-undo .
    def input param rid as recid no-undo .
    def input param beg as date no-undo .
    def input param end-date1  as date no-undo .
    def input param str-kau like kau.kau no-undo .
    def input param fl-print as logical no-undo .
    def input-output param xresult as decimal no-undo .
    def input-output param beg-date1 as date no-undo .
    def output param xresult-ref as decimal no-undo .
    
    def var month-day as logical no-undo.
    def var delay as INT64 init 1 no-undo  .
    def var dat-commi as date no-undo .
    def var in-surrogate as char no-undo .
    def var i as INT64 no-undo .
    def var in-status  like op.op-status  no-undo.
    
    def var vPeriodInt   as INT64           no-undo. /* Реальная продолжительность вкалада */
    def var end-commi as date no-undo .
    DEF VAR vOst         AS CHAR           NO-UNDO. /* код субостатка вклада*/
    DEF VAR vNach        AS CHAR           NO-UNDO. /* код начисления % по субостатку*/
    
    def buffer xop-entry  for op-entry.
    def buffer yop-templ  for op-templ.
    def buffer xkau-entry for kau-entry.
    
    ASSIGN
      vOst  = ENTRY(3,str-kau)
      vNach = IF vOst = "ОстВклВ"
              THEN  "НачПрВ"
              ELSE  "НачПрС1".
    {get_status.i}
    in-status = chr(251) .
    find acct where recid(acct) eq rid no-lock no-error .
    if not avail acct then return '{&next1}' .
    
    find interest-sch-line where recid(interest-sch-line) eq rid1 no-lock
    no-error .
    find loan where loan.contract eq entry(1,str-kau) and loan.cont-code eq entry(2,str-kau) no-lock no-error .
    find first loan-cond WHERE loan-cond.contract EQ loan.contract
                           AND loan-cond.cont-code EQ loan.cont-code
                                                    no-lock no-error.
    if not avail loan-cond then do:
       xresult = 0.
       RETURN '{&next1}'.
    end.
    {empty fost}
    /*Удаление лишнего */
    run del_kau_ost.
    /* Получение остатков по субаналитическим счетам */
    run cr_summ_ost(beg-date1,
                    end-date1 + 1,
                    rid,
                    vOst,
                    vNach).
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
      RUN rclcfost (loan.contract,
                    loan.cont-code,
                    ?,
                    acct.acct,
                    acct.currency
                   ).
    beg-date1 = beg-date1 + 1 .
    /* определение параметров лоя выбора комисии - даты, по которой учитывается изменение комиссии - это дата открытия/пролонгации вклада и
     продолжительности вклада , если вклад до востребования, то продолжительность берется = 0 */
    run Get_Date_Comm in h_dpspc (recid(loan),beg-date1,output dat-commi, output end-commi) .
    if end-commi = ? then vperiodint = 0 .
    else run depos-dep-period in h_dpspc (recid(loan),beg-date1, output vPeriodInt) .
    
    if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф") then dat-commi = beg .
    /*{refin39.i "inter39.i" }*/

    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.

    { inter39n.i
         &d-beg=beg-date1
         &d-end=end-date1
         &comm-rate=comm-rate
         &sum=fost
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &since1=" le dat-commi "
         &dat-commi=dat-commi
         &vPeriodInt = vPeriodInt
         &half=YES
         &offdef="/*"
    }
END PROCEDURE.

PROCEDURE nach39_.
    &UNDEFINE DefVarStat
    def input param rid1 as recid no-undo .
    def input param  in-commi like comm-rate.commi no-undo .
    def input param rid as recid no-undo .
    def input param beg as date no-undo .
    def input param end-date1  as date no-undo .
    def input param str-kau like kau.kau no-undo .
    def input param fl-print as logical no-undo .
    def input-output param xresult as decimal no-undo .
    def input-output param beg-date1 as date no-undo .
    def output param xresult-ref as decimal no-undo .
    
    def var month-day as logical no-undo.
    def var delay as INT64 init 1 no-undo  .
    def var dat-commi as date no-undo .
    def var in-surrogate as char no-undo .
    def var i as INT64 no-undo .
    def var in-status  like op.op-status  no-undo.
    DEF VAR vdat-commi   AS DATE    NO-UNDO.
    DEF VAR vend-commi   AS DATE    NO-UNDO.

    def var actual_kind like loan.op-kind no-undo. /* Код действующей транзакции */
    def var curr_intvl  as char           no-undo. /* Длительность вклада */

    def buffer xop-entry  for op-entry.
    def buffer yop-templ  for op-templ.
    def buffer xkau-entry for kau-entry.
    {get_status.i}
    in-status = chr(251) .
    find acct where recid(acct) eq rid no-lock no-error .
    if not avail acct then return '{&next1}' .
    
    find interest-sch-line where recid(interest-sch-line) eq rid1 no-lock
    no-error .
    find loan where loan.contract eq entry(1,str-kau) and loan.cont-code eq entry(2,str-kau) no-lock no-error .
    find first loan-cond WHERE loan-cond.contract EQ loan.contract
                           AND loan-cond.cont-code EQ loan.cont-code
                                                    no-lock no-error.
    if not avail loan-cond then do:
       xresult = 0.
       RETURN '{&next1}'.
    end.

    RUN get-beg-date-prol IN h_dpspc  (RECID(loan),end-date1, OUTPUT vdat-commi, OUTPUT vend-commi).

    {empty fost}
    /*Удаление лишнего */
    run del_kau_ost.
    /* Получение остатков по субаналитическим счетам */
    run cr_summ_ost(beg-date1,
                    end-date1 + 1,
                    rid,
                    IF vend-commi <> ? 
                            THEN 'ОстВклС' 
                        ELSE 'ОстВклВ', 
                    IF vend-commi <> ? 
                        THEN 'НачПрС1' 
                        ELSE 'НачПрВ'
                    ).


    
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
      RUN rclcfost (loan.contract,
                    loan.cont-code,
                    ?,
                    acct.acct,
                    acct.currency
                   ).
    
    dat-commi = gend-date.
    
    beg-date1 = beg-date1 + 1 .
    if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф") then dat-commi = beg .
    /*{refin39.i "inter39.i" }*/

    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.

    { inter39n.i
         &d-beg=beg-date1
         &d-end=end-date1
         &comm-rate=comm-rate
         &sum=fost
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &since1=" le dat-commi "
         &dat-commi=dat-commi
         &offdef="/*"
    }
END PROCEDURE.

PROCEDURE nach_ybl.
    &UNDEFINE DefVarStat
    def input param rid1 as recid no-undo.
    def input param in-commi like comm-rate.commi no-undo.
    def input param rid as recid no-undo.
    def input param beg as date no-undo.
    def input param end-date1  as date no-undo.
    def input param str-kau like kau.kau no-undo.
    def input param fl-print as logical no-undo.
    def input-output param xresult as decimal no-undo.
    def input-output param beg-date1 as date no-undo.
    def output param xresult-ref as decimal no-undo.
    
    def var dat-commi as date no-undo .
    def var end-commi as date no-undo .
    def var in-surrogate as char no-undo .
    def var i as INT64 no-undo .
    def var in-status like op.op-status no-undo.
    
    def var actual_kind like loan.op-kind no-undo. /* Код действующей транзакции */
    def var curr_intvl  as char           no-undo. /* Длительность вклада */
    
    def buffer yop-templ for op-templ .
    def buffer xkau-entry for kau-entry .
    DEF VAR stav_take AS DEC NO-UNDO.
    DEF VAR char_stav AS CHAR NO-UNDO.
    DEF VAR tmp_commi AS CHAR NO-UNDO.

    tmp_commi = in-commi.
    find acct where recid(acct) eq rid no-lock no-error.
    if not avail acct then return '{&next1}'.
    
    find interest-sch-line where recid(interest-sch-line) eq rid1
                     no-lock no-error.
    
    find loan where loan.contract  eq entry(1,str-kau) and
            loan.cont-code eq entry(2,str-kau)
            no-lock no-error.
    find first loan-cond WHERE loan-cond.contract EQ loan.contract
                           AND loan-cond.cont-code EQ loan.cont-code
                                                    no-lock no-error.
    if not avail loan-cond then do:
       xresult = 0.
       RETURN '{&next1}'.
    end.
    {get_status.i}
    in-status = chr(251).
    /* Получение остатков по субаналитическим счетам */
    {work_kau.i beg-date1 end-date1}
    
    
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
      RUN rclcfost  (loan.contract,
                     loan.cont-code,
                     IF NUM-ENTRIES(str-kau) GE 3 THEN ENTRY(3,str-kau) ELSE ?,
                     acct.acct,
                     acct.currency
                     ).
      
    beg-date1 = beg-date1 + 1. /* Дата начала периода начисления */
    
    /*Определение виртуальной даты начала вклада*/
    run get-beg-date-prol in h_dpspc (recid(loan),beg-date1,output dat-commi, output end-commi) .
    
    if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф") then dat-commi = beg .
    
    
   
    /*Если вклад не пролонгирован на "до востребования" */
    IF end-commi NE ? AND in-commi NE fGetSetting("ЦбРефПред", ?, "%ЦбРеф") THEN 
           run get_last_param in h_dpspc (recid(loan), beg-date1, beg-date1,'ИзъятСтавка', output char_stav).
      
    
/*    {refin39.i "inter39.i" }*/

    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.

    {intr_ybn.i
         &d-beg=beg-date1
         &d-end=end-date1
         &comm-rate=comm-rate
         &sum=fost
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &since1=" le dat-commi "
         &dat-commi=dat-commi
         &offdef="/*"
    }
END PROCEDURE.
/*
PROCEDURE nach_tr.
    DEF INPUT PARAM rid1      AS RECID             NO-UNDO .
    DEF INPUT PARAM  in-commi LIKE comm-rate.commi NO-UNDO .
    DEF INPUT PARAM rid       AS RECID             NO-UNDO .
    DEF INPUT PARAM beg       AS DATE              NO-UNDO .
    DEF INPUT PARAM end-date1 AS DATE              NO-UNDO .
    DEF INPUT PARAM str-kau   LIKE kau.kau         NO-UNDO .
    DEF INPUT PARAM fl-print  AS LOGICAL           NO-UNDO .
    
    DEF INPUT-OUTPUT PARAM xresult   AS DECIMAL NO-UNDO .
    DEF INPUT-OUTPUT PARAM beg-date1 AS DATE    NO-UNDO .
    DEF OUTPUT PARAM xresult-ref     AS DECIMAL NO-UNDO .
    
    DEF BUFFER xop-entry FOR op-entry .
    
    DEF VAR month-day  AS LOGICAL    NO-UNDO.
    DEF VAR delay      AS INT64 INIT 1 NO-UNDO  .
    DEF VAR do-loan    AS LOGICAL    NO-UNDO .
    DEF VAR start-date AS DATE       NO-UNDO .
    DEF VAR stop-date  AS DATE       NO-UNDO .
    DEF VAR dat-commi  AS DATE       NO-UNDO .
    DEF VAR per-dat    AS INT64        NO-UNDO .
    DEF VAR end-commi  AS DATE       NO-UNDO.
    DEF VAR entry3     AS CHAR       NO-UNDO.
    
    /*
    {get_date.i}
    {f_for_t.i}
    {def-ret.i}
    */
    
    FIND acct WHERE RECID(acct) EQ rid 
       NO-LOCK NO-ERROR .
    
    IF NOT AVAIL acct THEN RETURN '{&next1}' .
    
    FIND interest-sch-line WHERE RECID(interest-sch-line) EQ rid1 
       NO-LOCK NO-ERROR .
    
    
    {ch_kau_l.i &str-kau=str-kau
                &suf_proc="_work_ost"
                &proc-par="(str-kau,beg-date1,end-date1,'П')"
    
    }
    RUN dps_start(str-kau,
                  beg,
                  OUTPUT dat-commi,
                  OUTPUT per-dat).
    
    RUN get-beg-date-prol IN h_dpspc 
       (RECID(loan),
        beg-date1,
        OUTPUT dat-commi, 
        OUTPUT end-commi) .
    /*sap - для поиска ставки использовать дату виртуального открытия вклада*/
    
    IF in-commi EQ fGetSetting("ЦбРефПред", ?, "%ЦбРеф")
       THEN ASSIGN  
               dat-commi = beg + 1
               per-dat   = 0.
    
    beg-date1 = beg-date1 + 1 .
    
    /*{refint.i "inter_tr.i" }*/
    
    { intr_trn.i
         &d-beg=beg-date1
         &d-end=end-date1
         &comm-rate=comm-rate
         &sum=fost
         &per="le per-dat "
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &since1=" le dat-commi "
         &dat-commi=dat-commi
    }

END PROCEDURE.
*/

PROCEDURE nach_kpl.
    &UNDEFINE DefVarStat
    def input param rid1 as recid no-undo.
    def input param in-commi like comm-rate.commi no-undo.
    def input param rid as recid no-undo.
    def input param beg as date no-undo.
    def input param end-date1  as date no-undo.
    def input param str-kau like kau.kau no-undo.
    def input param fl-print as logical no-undo.
    def input-output param xresult as decimal no-undo.
    def input-output param beg-date1 as date no-undo.
    def output param xresult-ref as decimal no-undo.
    
    def var month-day as logical no-undo.
    def var delay as INT64 init 1 no-undo.
    def var in-status like op.op-status no-undo.
    def var dat-comm as date no-undo .
    DEF VAR vOst         AS CHAR           NO-UNDO. /* код субостатка вклада*/
    DEF VAR vNach        AS CHAR           NO-UNDO. /* код начисления % по субостатку*/
    
    find acct where recid(acct) eq rid no-lock no-error .
    if not avail acct then return '{&next1}' .
    
    find interest-sch-line where recid(interest-sch-line) eq rid1
                 no-lock no-error .
    
    find loan where loan.contract  eq entry(1,str-kau) and
         loan.cont-code eq entry(2,str-kau)
         no-lock no-error.
    ASSIGN
      vOst  = ENTRY(3,str-kau)
      vNach = IF vOst = "ОстВклВ"
              THEN  "НачПрВ"
              ELSE  "НачПрС1".
    {get_status.i}
    in-status = chr(251).
    {empty fost}
     /*Удаление лишнего */
    run del_kau_ost.
    /* Получение остатков по субаналитическим счетам */
    run cr_summ_ost(beg-date1,
                    end-date1 + 1,
                    rid,
                    vOst,
                    vNach).
    
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
      RUN rclcfost (loan.contract,
                    loan.cont-code,
                    ?,
                    acct.acct,
                    acct.currency
                   ).
    
    dat-comm = beg .
    beg-date1 = beg-date1 + 1.
/*    {refin39.i "inter_pl.i" }*/

    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.

    {intr_pln.i
         &d-beg=beg-date1
         &d-end=end-date1
         &sum=fost
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &comm-rate=comm-rate
         &dat-comm=dat-comm
         &offdef="/*"
    }
END PROCEDURE.

PROCEDURE n_kauful.
    &UNDEFINE DefVarStat
    def input param rid1 as recid no-undo .
    def input param  in-commi like comm-rate.commi no-undo .
    def input param rid as recid no-undo .
    def input param beg as date no-undo .
    def input param end-date1  as date no-undo .
    def input param str-kau like kau.kau no-undo .
    def input param fl-print as logical no-undo .
    def input-output param xresult as decimal no-undo .
    def input-output param beg-date1 as date no-undo .
    def output param xresult-ref as decimal no-undo .
    
    def var month-day as logical no-undo.
    def var delay as INT64 init 1 no-undo  .
    def var dat-commi as date no-undo .
    def var in-surrogate as char no-undo .
    def var i as INT64 no-undo .
    def var in-status  like op.op-status  no-undo.
    
    def var actual_kind like loan.op-kind no-undo. /* Код действующей транзакции */
    def var curr_intvl  as char           no-undo. /* Длительность вклада */
    def var vPeriodInt   as INT64            no-undo. /* Реальная продолжительность вкалада */
    def var end-commi as date no-undo .
    DEF VAR vOst         AS CHAR           NO-UNDO. /* код субостатка вклада*/
    DEF VAR vNach        AS CHAR           NO-UNDO. /* код начисления % по субостатку*/
    
    def buffer xop-entry  for op-entry.
    def buffer yop-templ  for op-templ.
    def buffer xkau-entry for kau-entry.
    /*определение кодов субостатков в зависимости от str-kau переданная строка КАУ*/
    ASSIGN
      vOst  = ENTRY(3,str-kau)
      vNach = IF vOst = "ОстВклВ"
              THEN  "НачПрВ"
              ELSE  "НачПрС1".
    {get_status.i}
    
    find acct where recid(acct) eq rid no-lock no-error.
    if not avail acct then return '{&next1}'.
    
    find interest-sch-line where recid(interest-sch-line) eq rid1
                     no-lock no-error.
    
    find loan where loan.contract  eq entry(1,str-kau) and
            loan.cont-code eq entry(2,str-kau)
            no-lock no-error.
    find first loan-cond WHERE loan-cond.contract EQ loan.contract
                           AND loan-cond.cont-code EQ loan.cont-code
                                                    no-lock no-error.
    if not avail loan-cond then do:
       xresult = 0.
       RETURN '{&next1}'.
    end.
    {empty fost}
    /*Удаление лишнего */
    run del_kau_ost.
    /* Получение остатков по субаналитическим счетам */
    run cr_summ_ost(beg-date1,
                    end-date1 + 1,
                    rid,
                    vOst,
                    vNach).
    
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
      RUN rclcfost (loan.contract,
                    loan.cont-code,
                    ?,
                    acct.acct,
                    acct.currency
                   ).
    beg-date1 = beg-date1 + 1. /* Дата начала периода начисления */
    /* определение параметров лоя выбора комисии - даты, по которой учитывается изменение комиссии - это дата открытия/пролонгации вклада и
     продолжительности вклада , если вклад до востребования, то продолжительность берется = 0 */
    run Get_Date_Comm in h_dpspc (recid(loan),beg-date1,output dat-commi, output end-commi) .
    if end-commi = ? then vperiodint = 0 .
    else run depos-dep-period in h_dpspc (recid(loan),beg-date1, output vPeriodInt) .
    
    if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф") then dat-commi = beg .
    /*{refin39.i "inter39.i" }*/

    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.

    { inter39n.i
         &d-beg      = beg-date1
         &d-end      = end-date1
         &comm-rate  = comm-rate
         &SUM        = fost
         &since      = since
         &rcom       = in-commi
         &proc       = xresult
         &balance    = balance
         &since1     = " le dat-commi "
         &dat-commi  = dat-commi
         &in-bal     = YES
         &vPeriodInt = vPeriodInt
         &half       = YES
         &offdef     = "/*"
    }
END PROCEDURE.

PROCEDURE n_kaucon.
    &UNDEFINE DefVarStat
    def input param rid1 as recid no-undo.
    def input param in-commi like comm-rate.commi no-undo.
    def input param rid as recid no-undo.
    def input param beg as date no-undo.
    def input param end-date1  as date no-undo.
    def input param str-kau like kau.kau no-undo.
    def input param fl-print as logical no-undo.
    def input-output param xresult as decimal no-undo.
    def input-output param beg-date1 as date no-undo.
    def output param xresult-ref as decimal no-undo.
    def var dat-commi as date no-undo .
    def var in-surrogate as char no-undo .
    def var i as INT64 no-undo .
    def var in-status like op.op-status no-undo.
    
    def var actual_kind like loan.op-kind no-undo. /* Код действующей транзакции */
    def var curr_intvl  as char           no-undo. /* Длительность вклада */
    def var vPeriodInt   as INT64            no-undo. /* Реальная продолжительность вкалада */
    def var end-commi as date no-undo .
    
    def buffer yop-templ for op-templ .
    def buffer xkau-entry for kau-entry .
  
    find acct where recid(acct) eq rid no-lock no-error.
    if not avail acct then return '{&next1}'.
    
    find interest-sch-line where recid(interest-sch-line) eq rid1
                     no-lock no-error.
    
    find loan where loan.contract  eq entry(1,str-kau) and
            loan.cont-code eq entry(2,str-kau)
            no-lock no-error.
    find first loan-cond WHERE loan-cond.contract EQ loan.contract
                           AND loan-cond.cont-code EQ loan.cont-code
                                                    no-lock no-error.
    if not avail loan-cond then do:
       xresult = 0.
       RETURN '{&next1}'.
    end.
    {get_status.i}
    in-status = chr(251).
    /* Получение остатков по субаналитическим счетам */
    {work_kau.i beg-date1 end-date1}
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
      RUN rclcfost  (loan.contract,
                     loan.cont-code,
                     IF NUM-ENTRIES(str-kau) GE 3 THEN ENTRY(3,str-kau) ELSE ?,
                     acct.acct,
                     acct.currency
                     ).
    beg-date1  = beg-date1 + 1.
    /* определение параметров лоя выбора комисии - даты, по которой учитывается изменение комиссии - это дата открытия/пролонгации вклада и
     продолжительности вклада , если вклад до востребования, то продолжительность берется = 0 */
    run get-beg-date-prol in h_dpspc (recid(loan),beg-date1,output dat-commi, output end-commi) .
    if end-commi = ? then vperiodint = 0 .
    else run depos-dep-period in h_dpspc (recid(loan),beg-date1, output vPeriodInt) .
    if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф") then dat-commi = beg .
    /*{refin39.i "inter39.i"  vPeriodInt }*/

    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.

    { inter39n.i
         &d-beg=beg-date1
         &d-end=end-date1
         &comm-rate=comm-rate
         &sum=fost
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &since1=" le dat-commi "
         &dat-commi=dat-commi
         &vPeriodInt = vPeriodInt
         &offdef="/*"
    }

END PROCEDURE.

PROCEDURE n_kau_pl.
    &UNDEFINE DefVarStat
    def input param rid1 as recid no-undo.
    def input param in-commi like comm-rate.commi no-undo.
    def input param rid as recid no-undo.
    def input param beg as date no-undo.
    def input param end-date1  as date no-undo.
    def input param str-kau like kau.kau no-undo.
    def input param fl-print as logical no-undo.
    def input-output param xresult as decimal no-undo.
    def input-output param beg-date1 as date no-undo.
    def output param xresult-ref as decimal no-undo.
    def var in-status like op.op-status no-undo.
    def var dat-comm as date no-undo .
    
    find acct where recid(acct) eq rid no-lock no-error .
    if not avail acct then return '{&next1}' .
    
    find interest-sch-line where recid(interest-sch-line) eq rid1
                 no-lock no-error .
    
    find loan where loan.contract  eq entry(1,str-kau) and
         loan.cont-code eq entry(2,str-kau)
         no-lock no-error.
    {get_status.i}
    in-status = chr(251).
    /* Получение остатков по субаналитическим счетам */
    {empty fost}
    {work_kau.i beg-date1 end-date1}
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
      RUN rclcfost (loan.contract,
                    loan.cont-code,
                    IF NUM-ENTRIES(str-kau) GE 3 THEN ENTRY(3,str-kau) ELSE ?,
                    acct.acct,
                    acct.currency
                    ).
    
    beg-date1 = beg-date1 + 1.
    dat-comm = beg .
    /*{refin39.i "inter_pl.i" }*/

    IF GetSysConf("OldRef") EQ "Да" THEN DO:
       {refin39n.i}
    END.

    {intr_pln.i
         &d-beg=beg-date1
         &d-end=end-date1
         &sum=fost
         &since=since
         &rcom=in-commi
         &proc=xresult
         &balance=balance
         &comm-rate=comm-rate
         &comm-rate=comm-rate
         &dat-comm=dat-comm
         &offdef="/*"
    }

END PROCEDURE.

PROCEDURE nach_dav.
    &UNDEFINE NoDel 
    &UNDEFINE DefVarStat
    def input param rid1 as recid no-undo .
    def input param  in-commi like comm-rate.commi no-undo .
    def input param rid as recid no-undo .
    def input param beg as date no-undo .
    def input param end-date1  as date no-undo .
    def input param str-kau like kau.kau no-undo .
    def input param fl-print as logical no-undo .
    def input-output param xresult as decimal no-undo .
    def input-output param beg-date1 as date no-undo .
    def output param xresult-ref as decimal no-undo .
    
    
    DEF VAR xresult-base AS DEC NO-UNDO. 
    DEF VAR xresult-ext AS DEC NO-UNDO. 
    DEF VAR vTmp-beg-date1 AS DATE NO-UNDO.
    DEF VAR vTmp-end-date1 AS DATE NO-UNDO.
    DEF VAR vTmp-char AS CHAR NO-UNDO.

    def var month-day as logical no-undo.
    def var delay as INT64 init 1 no-undo  .
    def var dat-commi as date no-undo .
    def var in-surrogate as char no-undo .
    def var i as INT64 no-undo .
    def var in-status  like op.op-status  no-undo.

    def var actual_kind like loan.op-kind no-undo. /* Код действующей транзакции */
    def var curr_intvl  as char           no-undo. /* Длительность вклада */
    def var vPeriodInt   as INT64            no-undo. /* Реальная продолжительность вкалада */
    def var end-commi as date no-undo .



    def buffer xop-entry  for op-entry.
    def buffer yop-templ  for op-templ.
    def buffer xkau-entry for kau-entry.
    DEF VAR sub-commi    like comm-rate.commi no-undo. /*код комиссии*/
    DEF VAR sub-commi-v  AS  DECIMAL  NO-UNDO.         /*процент базовой комиссии*/

    DEF VAR vOsnStavka   AS RECID NO-UNDO.
    DEF VAR vOsnStavkaRate   AS DEC NO-UNDO.

    /*DEF VAR vNew-comm LIKE comm-rate.rate-comm NO-UNDO.*/
    DEF VAR  vNalog AS CHAR NO-UNDO.
    {get_status.i}
    in-status = chr(251) .
    find acct where recid(acct) eq rid no-lock no-error .
    if not avail acct then return '{&next1}' .

    find interest-sch-line where recid(interest-sch-line) eq rid1 no-lock
    no-error .
    find loan where loan.contract eq entry(1,str-kau) and loan.cont-code eq entry(2,str-kau) no-lock no-error .
    find first loan-cond WHERE loan-cond.contract EQ loan.contract
                           AND loan-cond.cont-code EQ loan.cont-code
                                                    no-lock no-error.
    if not avail loan-cond then do:
       xresult = 0.
       RETURN '{&next1}'.
    end.

    {work_39.i beg-date1 end-date1 in-status  acct }
    {empty fost-base}
    {empty fost-ext}
    
    /*Пересчет остатков по плановым датам*/

        RUN rclcfost(loan.contract,
                     loan.cont-code,
                      ?,
                      acct.acct,
                      acct.currency
                     ).


    /* определение параметров лоя выбора комисии - даты, по которой учитывается изменение комиссии - это дата открытия/пролонгации вклада и
     продолжительности вклада , если вклад до востребования, то продолжительность берется = 0 */
    run Get_Date_Comm in h_dpspc (recid(loan),beg-date1,output dat-commi, output end-commi) .
    if end-commi = ? then vperiodint = 0 .
    else run depos-dep-period in h_dpspc (recid(loan),beg-date1, output vPeriodInt) .
    
    if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф") THEN DO: 
        vNalog = fGetSetting("ЦбРефПред", ?, "%ЦбРеф").
        dat-commi = beg .
    END.
    beg-date1  = beg-date1 + 1.
    
    /*Определение минимального сотатка за весь период начисления*/
    IF GetSysConf("Davos_min_ost") = ? THEN DO:


        /*
        FOR EACH fost:
            MESSAGE fost.since SKIP fost.balance SKIP beg-date1 VIEW-AS ALERT-BOX.
        END.
        */
        /*%% причисленные в день начисления нужно учесть как основная сумма*/
        FIND FIRST fost WHERE fost.since = beg-date1  NO-ERROR. 
        IF NOT AVAILABLE fost THEN
            /*если причисления не было, исходим из того то что было до дня начисления */
            FIND FIRST fost WHERE fost.since = beg-date1 - 1  NO-ERROR. 
        IF AVAILABLE fost THEN DO:
            ASSIGN vFostMin = ABS(fost.balance)
                   vFostSince = fost.since.
        END.
        
        /*поиск минимального остатка*/
        FOR EACH fost WHERE fost.since > vFostSince:
            IF ABS(fost.balance) < vFostMin THEN vFostMin = ABS(fost.balance).
            /*MESSAGE fost.since SKIP fost.balance SKIP beg-date1 SKIP vFostMin VIEW-AS ALERT-BOX.*/
        END.
        RUN SetSysConf IN h_base ("Davos_min_ost", STRING(vFostMin)).
        /*MESSAGE "Установленный" vFostMin view-as ALERT-BOX.*/
    END.

    ELSE vFostMin = DEC(GetSysConf("Davos_min_ost")).
    run get_last_min_ost (RECID(loan),
                          dat-commi,
                          dat-commi,
                          output vMinOst).

    /*MESSAGE vMinOst SKIP vFostMin VIEW-AS ALERT-BOX.*/

    /*если хоть раз сумма вклада была меньше минимального остатка - считаем все по штрафной ставке*/

    IF vFostMin < vMinOst THEN DO: 
    /*RUN pen-fost.*/
    /***********************************************/
        RUN Get_Last_Param in h_dpspc (recid(Loan),
                                       beg-date1,
                                       beg-date1,
                                       "pen-commi",
                                       OUTPUT in-commi).
      release comm-rate.

      dat-commi = IF DATE(GetSysConf("op-contract-date")) NE ?
              THEN DATE(GetSysConf("op-contract-date"))
              ELSE gend-date.


          {inter39n.i
               &d-beg=beg-date1
               &d-end=end-date1
               &comm-rate=comm-rate
               &sum=fost
               &since=since
               &rcom=in-commi
               &proc=xresult
               &balance=balance
               &dat-commi = dat-commi
               &since1=" le dat-commi "
          }

    /***********************************************/
    END. 

    ELSE DO: /*RUN base-fost.*/
        /***********************************************/
        ASSIGN
            vTmp-beg-date1 = beg-date1
            vTmp-end-date1 = end-date1.

        FOR EACH fost:
                CREATE fost-base. 
                ASSIGN
                    fost-base.balance = 0 - vFostMin
                    fost-base.since = fost.Since.  
                
                 /*MESSAGE "Базовый остаток " SKIP GetSysConf("pars-id") SKIP  fost-base.balance
                                                                             fost-base.since  VIEW-AS ALERT-BOX.
                  */                                                           
                                            
            END.
            /*    MESSAGE "base-fost! Комиссия = " in-commi VIEW-AS ALERT-BOX.*/

            IF vNalog = fGetSetting("ЦбРефПред", ?, "%ЦбРеф") THEN DO:
                 ASSIGN
                      vPeriodInt = 0
                      dat-commi = beg.

                 {inter39n.i
                     &offdef = "/*"
                     &d-beg=beg-date1
                     &d-end=end-date1
                     &comm-rate=comm-rate
                     &sum=fost-base
                     &since=since
                     &rcom=vNalog
                     &proc=xresult-base
                     &balance=balance
                     &since1=" le dat-commi "
                     &dat-commi=dat-commi
                     &vPeriodInt = vPeriodInt
                 }
            END.
            ELSE DO:
                /*Ищем основную комиссию на дату начала договора*/
                { findcom1.i
                    &dir       = last
                    &rsum      = 0
                    &since1    = " <= dat-commi "
                           &rcom      = in-commi
                           &comm-rate = comm-rate
                 }


                 if NOT AVAILABLE comm-rate THEN DO:
                    RUN Fill-SysMes ("",
                                     "dps_n001",
                                     "",
                                     "").
                    RETURN '{&next1}'.
                 END.

                 ASSIGN vOsnStavka = RECID(comm-rate).

                 /*ищем соответствующий вид комиссии */
                 FIND FIRST commission WHERE
                            commission.commission = comm-rate.commission
                        AND commission.currency   = comm-rate.currency
                        AND commission.MIN-VALUE  = 0
                        AND commission.period     = comm-rate.period NO-LOCK NO-ERROR.
                 /*если не вида комиссии, то это ошибка - нельзя определить
                   базовую комиссию */
                if NOT AVAILABLE commission THEN DO:
                   RUN Fill-SysMes ("",
                                    "dps_n002",
                                    "",
                                    "").
                   RETURN '{&next1}'.
                END.
                /*
                MESSAGE commission.commission VIEW-AS ALERT-BOX.
                */
                ASSIGN
                   sub-commi   = commission.base-comm
                   sub-commi-v = comm-rate.rate-comm
                   .
                /*
                MESSAGE sub-commi   SKIP
                        sub-commi-v     VIEW-AS alert-box.
               */
                if sub-commi = "" or sub-commi = ? then RETURN '{&next1}'.
                release comm-rate.


                {inter66n.i
                    &offdef = "/*"
                    &refdef = "/*" /*Не нужно умножать на %Реф  когда ставка зависит от %ЦбРеф*/
                    &d-beg      = beg-date1
                    &d-end      = end-date1
                    &comm-rate  = comm-rate
                    &sum        = fost-base
                    &since      = since
                    &rcom       = sub-commi
                    &proc       = xresult-base
                    &balance    = balance
                    &dat-commi  = dat-commi
                }
            END.

        /***********************************************/

            vTmp-char = RETURN-VALUE.

       /* RUN ext-fost.*/
       /**********************************************************/
            /*Для начисления по ставке д/в за периоды превышения над минимальным остатком*/
            FOR EACH fost:
                FIND FIRST fost-base WHERE fost-base.since = fost.since NO-ERROR.
                IF AVAILABLE fost-base THEN DO:
                    CREATE fost-ext. 
                    ASSIGN
                        fost-ext.balance = 0 - (ABS(fost.balance) - ABS(fost-base.balance)).
                        fost-ext.since = fost.Since.  
                                                       

               END.
            END.
            IF vNalog = fGetSetting("ЦбРефПред", ?, "%ЦбРеф") THEN DO:
                ASSIGN
                      vPeriodInt = 0
                      dat-commi = beg.
                {inter39n.i
                     &offdef = "/*"
                     &d-beg = vTmp-beg-date1 
                     &d-end = beg-date1
                     &comm-rate=comm-rate
                     &sum=fost-ext
                     &since=since
                     &rcom=vNalog
                     &proc=xresult-ext
                     &balance=balance
                     &since1=" le dat-commi "
                     &dat-commi=dat-commi
                     &vPeriodInt = vPeriodInt
                 }
            END.
            ELSE DO:
                RUN Get_Last_Param in h_dpspc (recid(Loan),
                                                 vTmp-beg-date1,
                                                 vTmp-beg-date1,
                                                 "pen-commi",
                                                 OUTPUT in-commi).
                
                release comm-rate.

                dat-commi = IF DATE(GetSysConf("op-contract-date")) NE ?
                        THEN DATE(GetSysConf("op-contract-date"))
                        ELSE gend-date.

                {inter39n.i
                     &offdef = "/*"
                     &d-beg = vTmp-beg-date1 
                     &d-end = beg-date1
                     &sum=fost-ext
                     &since=since
                     &rcom=in-commi
                     &proc=xresult-ext
                     &balance=balance
                     &comm-rate=comm-rate
                     &dat-commi = dat-commi
                     &since1=" le dat-commi "
                }
            END.
         /**********************************************************/
         vTmp-char = vTmp-char + CHR(1) + RETURN-VALUE.
         xresult = xresult-base + xresult-ext.

    END.
    /*Попытка расчитать вклад по ставке довостребования за периоды превыжения 
    сбила правильные значекния публикуемых ставок - возвращаем реальное значение ставки*/
    PUBLISH "publish-comm" (vOsnStavka,vOsnStavkaRate).

END PROCEDURE.


PROCEDURE nach_inc.
    &UNDEFINE DefVarStat
    def input param rid1               as recid             no-undo. 
    def input param in-commi           like comm-rate.commi no-undo.
    def input param rid                as recid             no-undo.
    def input param beg                as date              no-undo.
    def input param end-date1          as date              no-undo.
    def input param str-kau            like kau.kau         no-undo.
    def input param fl-print           as logical           no-undo.
    def input-output param xresult     as decimal           no-undo.
    def input-output param beg-date1   as date              no-undo.
    def output param xresult-ref       as decimal           no-undo.

    DEF VAR mSince      AS DATE           NO-UNDO.
    DEF VAR mPer        AS CHAR           NO-UNDO.
    DEF VAR dat-commi   AS DATE           NO-UNDO.
    DEF VAR end-commi   AS DATE           NO-UNDO.
    DEF VAR in-status   LIKE op.op-status NO-UNDO.
    
    DEF BUFFER bcomm-rate FOR comm-rate.
    {get_status.i}
    in-status = chr(251).
    
    FIND acct WHERE RECID(acct) EQ rid NO-LOCK NO-ERROR.
    IF NOT AVAIL acct THEN 
       RETURN '{&next1}'.
    
    FIND FIRST interest-sch-line WHERE RECID(interest-sch-line) EQ rid1
       NO-LOCK NO-ERROR.
    
    FIND FIRST loan WHERE loan.contract  eq ENTRY(1,str-kau) 
                      AND loan.cont-code eq ENTRY(2,str-kau)
       NO-LOCK NO-ERROR. 
    
    FIND FIRST loan-cond WHERE loan-cond.contract  EQ loan.contract 
                           AND loan-cond.cont-code EQ loan.cont-code
       NO-LOCK NO-ERROR.
    
    {empty fost}
    /*Удаление лишнего */
    run del_kau_ost.
    /* Получение остатков по субаналитическим счетам */
    run cr_summ_ost(beg-date1,
                    end-date1 + 1,
                    rid,
                    IF loan.end-date <> ? THEN 'ОстВклС' 
                                          ELSE 'ОстВклВ', 
                    IF loan.end-date <> ? THEN 'НачПрС1' 
                                          ELSE 'НачПрВ').
    
    /*Пересчет остатков по плановым датам*/
    IF vPlane_date  THEN
       RUN rclcfost (loan.contract,
                     loan.cont-code,
                     ?,
                     acct.acct,
                     acct.currency).

    beg-date1 = beg-date1 + 1.

    /* определение параметров лоя выбора комисии - даты, по которой учитывается изменение комиссии - это дата открытия/пролонгации вклада и
    продолжительности вклада , если вклад до востребования, то продолжительность берется = 0 */
    RUN Get_Date_Comm in h_dpspc (RECID(loan),
                                  beg-date1,
                                  OUTPUT dat-commi, 
                                  OUTPUT end-commi).

    if in-commi eq fGetSetting("ЦбРефПред", ?, "%ЦбРеф") then 
       dat-commi = beg.
    
    IF GetSysConf("OldRef") EQ "Да" THEN 
    DO:
       {refin39n.i}
    END.

    IF  in-commi = fGetSetting("ЦбРефПред", ?, "%ЦБреф") THEN 
    DO: 
       {intr_pln.i
           &d-beg      = beg-date1
           &d-end      = end-date1
           &sum        = fost
           &since      = since
           &rcom       = in-commi
           &proc       = xresult
           &balance    = balance
           &comm-rate  = comm-rate         
           &dat-comm   = dat-commi
           &offdef     = "/*"
       }    
    END.
    ELSE 
    DO:
       {empty comm-mp}
       RUN Get_Last_Param in h_dpspc (RECID(loan),
                                      end-date1,
                                      end-date1,
                                      "ПериодСтавки",
                                      OUTPUT mPer).
       comm:
       FOR EACH comm-rate WHERE comm-rate.commission EQ in-commi  
                            AND comm-rate.filial-id = shfilial
                            AND comm-rate.branch-id = ""
                            AND comm-rate.since      LE dat-commi 
          NO-LOCK:

          /*создаем новые записи только для тех комиссий, которые действуют на дату*/
          IF CAN-FIND(FIRST bcomm-rate WHERE bcomm-rate.commission EQ comm-rate.commission  
                                         AND bcomm-rate.filial-id = shfilial
                                         AND bcomm-rate.branch-id = ""
                                         AND bcomm-rate.currency   EQ comm-rate.currency      
                                         AND bcomm-rate.MIN-VALUE  EQ comm-rate.MIN-VALUE    
                                         AND bcomm-rate.acct       EQ comm-rate.acct              
                                         AND bcomm-rate.period     EQ comm-rate.period          
                                         AND bcomm-rate.since      LE dat-commi                 
                                         AND bcomm-rate.since      GT comm-rate.since) THEN 
             NEXT comm.

          CASE mPer:
              WHEN "М" THEN 
                 mSince = GoMonth(dat-commi + 1,comm-rate.period - 1). /*-1 чтобы не заставлять вводить ставки с 0 месяца*/
              OTHERWISE 
                 mSince = dat-commi + comm-rate.period.
          END CASE.

          FIND FIRST comm-mp WHERE comm-mp.commission EQ comm-rate.commission  
                               AND comm-mp.currency   EQ comm-rate.currency      
                               AND comm-mp.MIN-VALUE  EQ comm-rate.MIN-VALUE    
                               AND comm-mp.acct       EQ comm-rate.acct              
                               AND comm-mp.since      EQ mSince                     
                               AND comm-mp.period     EQ 0
             NO-LOCK NO-ERROR.       
          IF NOT AVAILABLE comm-mp THEN 
              CREATE comm-mp.

          BUFFER-COPY comm-rate EXCEPT comm-rate.since TO comm-mp NO-ERROR.  
          ASSIGN 
              comm-mp.since = mSince
              comm-mp.period = 0
              comm-mp.cr-recid = RECID(comm-rate)
              .

       END.

       {intr_pnn.i
           &d-beg      = beg-date1
           &d-end      = end-date1
           &sum        = fost
           &since      = since
           &rcom       = in-commi
           &proc       = xresult
           &balance    = balance
           &comm-rate  = comm-mp         
           &dat-comm   = dat-commi
           &cr-recid   = YES    
           &offdef     ="/*"
       }
    END.

END PROCEDURE. /* nach-inc */

PROCEDURE nach_hsn.
   &UNDEFINE DefVarStat
   DEF INPUT        PARAM rid1        AS RECID             NO-UNDO.
   DEF INPUT        PARAM in-commi    LIKE comm-rate.commi NO-UNDO.
   DEF INPUT        PARAM rid         AS RECID             NO-UNDO.
   DEF INPUT        PARAM beg         AS DATE              NO-UNDO.
   DEF INPUT        PARAM end-date1   AS DATE              NO-UNDO.
   DEF INPUT        PARAM str-kau     LIKE kau.kau         NO-UNDO.
   DEF INPUT        PARAM fl-print    AS LOGICAL           NO-UNDO.
   DEF INPUT-OUTPUT PARAM xresult     AS DECIMAL           NO-UNDO.
   DEF INPUT-OUTPUT PARAM beg-date1   AS DATE              NO-UNDO.
   DEF OUTPUT       PARAM xresult-ref AS DECIMAL           NO-UNDO.

   DEF VAR month-day as logical no-undo.
   DEF VAR delay as INT64 init 1 no-undo.
   DEF VAR in-status like op.op-status no-undo.
   DEF VAR dat-comm as date no-undo .
   DEF VAR vOst         AS CHAR           NO-UNDO. /* код субостатка вклада*/
   DEF VAR vNach        AS CHAR           NO-UNDO. /* код начисления % по субостатку*/   
   DEF VAR comm-ost     like acct-pos.balance   no-undo.
   DEFINE VARIABLE mTotSumm AS DECIMAL     NO-UNDO.
   DEFINE VARIABLE mPenComm AS CHARACTER   NO-UNDO.
   DEFINE VARIABLE mLoanOst AS DECIMAL     NO-UNDO.   
   DEF VAR end-commi    AS DATE            NO-UNDO.
   DEF VAR dat-commi    AS DATE            NO-UNDO.

   DEF BUFFER btt-MinAmmSumm FOR tt-MinAmmSumm.
   DEF BUFFER btt-MinAmm     FOR tt-MinAmm.
   {get_status.i}

   FIND FIRST acct WHERE RECID(acct) EQ rid 
      NO-LOCK NO-ERROR.
   IF NOT AVAIL acct THEN 
      RETURN '{&next1}'.
   
   FIND FIRST interest-sch-line WHERE RECID(interest-sch-line) EQ rid1
      NO-LOCK NO-ERROR.
   IF NOT AVAIL interest-sch-line THEN 
      RETURN '{&next1}'.
   
   FIND FIRST loan WHERE loan.contract  EQ ENTRY(1,str-kau) 
                     AND loan.cont-code EQ ENTRY(2,str-kau) 
      NO-LOCK NO-ERROR.
   IF NOT AVAIL loan THEN 
      RETURN '{&next1}'.
   
   FIND FIRST loan-cond WHERE loan-cond.contract  EQ loan.contract
                          AND loan-cond.cont-code EQ loan.cont-code
      NO-LOCK NO-ERROR.
   IF NOT AVAIL loan-cond THEN 
   DO:
      xresult = 0.
      RETURN '{&next1}'.
   END.
   
   in-status = CHR(251).
   ASSIGN
     vOst  = IF loan.end-date EQ ? THEN "ОстВклС"
                                   ELSE "ОстВклВ"
     .
   
   {work_kau.i beg-date1 end-date1}
    
   /*Пересчет остатков по плановым датам*/
   IF vPlane_date THEN
     RUN rclcfost  (loan.contract,
                    loan.cont-code,
                    IF NUM-ENTRIES(str-kau) GE 3 THEN ENTRY(3,str-kau) ELSE ?,
                    acct.acct,
                    acct.currency).
   
   dat-comm = beg.
   beg-date1 = beg-date1 + 1.

   RUN get-beg-date-prol IN h_dpspc (RECID(loan),
                                     beg-date1,
                                     OUTPUT dat-commi,
                                     OUTPUT end-commi).
   
   IF GetSysConf("OldRef") EQ "Да" THEN 
   DO:   
      {refin39n.i}
   END.

   IF in-commi EQ fGetSetting("ЦбРефПред", ?, "%ЦБреф") THEN 
   DO: 
      {intr_pln.i
          &d-beg      = beg-date1
          &d-end      = end-date1
          &sum        = fost
          &since      = since
          &rcom       = in-commi
          &proc       = xresult
          &balance    = balance
          &comm-rate  = comm-rate         
          &dat-comm   = dat-commi
          &offdef     = "/*"          
      }    
   END.
   ELSE
   DO:
      {empty tt-commrate}
   
      FOR EACH comm-rate WHERE comm-rate.commi     EQ in-commi 
                           AND comm-rate.acct      EQ acct.acct 
                           AND comm-rate.currency  EQ acct.currency 
                           AND comm-rate.since     LE beg-date1 - 1 
         NO-LOCK:
      
         CREATE tt-commrate.
         BUFFER-COPY comm-rate TO tt-commrate.
         tt-commrate.real-date = dat-commi + tt-commrate.period.
         tt-commrate.cr-recid  = RECID(comm-rate).
      END.
      FOR EACH comm-rate WHERE comm-rate.commi     EQ in-commi 
                           AND comm-rate.filial-id = shfilial
                           AND comm-rate.branch-id = ""
                           AND comm-rate.acct      EQ "0" 
                           AND comm-rate.currency  EQ acct.currency 
                           AND comm-rate.since     LE beg-date1 - 1
         NO-LOCK:
      
         IF NOT CAN-FIND (FIRST tt-commrate WHERE comm-rate.commission  EQ tt-commrate.commission
                                              AND tt-commrate.acct      NE "0"
                                              AND tt-commrate.period    EQ comm-rate.period
                                              AND tt-commrate.min-value EQ comm-rate.min-value) THEN
         DO:
            CREATE tt-commrate.
            BUFFER-COPY comm-rate TO tt-commrate.
            tt-commrate.real-date = dat-commi + tt-commrate.period.
            tt-commrate.cr-recid  = RECID(comm-rate).
         END.   
      END.
      
      mTotSumm = DEC(GetXAttrValue("loan",
                                   loan.contract + "," + loan.cont-code,
                                   "ОбщСумма")) NO-ERROR.  

      RUN HousingTable (beg-date1,
                        "СрокМинОст",
                        OUTPUT TABLE tt-MinAmm).
      
      {empty tt-MinAmmSumm}

      FOR EACH tt-MinAmm:
         ASSIGN
            tt-MinAmm.real-summ = mTotSumm * tt-MinAmm.summ / 100
            tt-MinAmm.real-date = GoMonth(dat-commi, tt-MinAmm.srok)
            .

         FIND LAST tt-commrate WHERE tt-commrate.commission EQ in-commi
                                 AND tt-commrate.real-date  LE tt-MinAmm.real-date
               NO-LOCK NO-ERROR.
         IF NOT CAN-FIND(FIRST tt-MinAmmSumm WHERE tt-MinAmmSumm.commission EQ in-commi
                                               AND tt-MinAmmSumm.since      EQ tt-MinAmm.real-date
                                               AND tt-MinAmmSumm.real-summ  EQ tt-MinAmm.real-summ
                                               AND tt-MinAmmSumm.rate-comm  EQ tt-commrate.rate-comm) THEN
         DO:              
            CREATE tt-MinAmmSumm.   
            ASSIGN
               tt-MinAmmSumm.filial-id   = shfilial
               tt-MinAmmSumm.branch-id   = ""
               tt-MinAmmSumm.since       = tt-MinAmm.real-date
               tt-MinAmmSumm.real-date   = tt-MinAmm.real-date
               tt-MinAmmSumm.real-summ   = tt-MinAmm.real-summ
               tt-MinAmmSumm.rate-comm   = tt-commrate.rate-comm
               tt-MinAmmSumm.commission  = in-commi
               tt-MinAmmSumm.acct        = "0"
               tt-MinAmmSumm.currency    = acct.currency
               tt-MinAmmSumm.cr-recid    = tt-commrate.cr-recid
               .
            RELEASE tt-MinAmmSumm.
         END.
      END.

      /* Сливаем данные из comm-rate и СрокМинОст в одну общую таблицу */
      FOR EACH tt-commrate BY tt-commrate.since DESCENDING:

         IF NOT CAN-FIND (FIRST tt-MinAmmSumm WHERE tt-MinAmmSumm.since EQ tt-commrate.real-date) THEN
         DO:
            CREATE tt-MinAmmSumm.
            BUFFER-COPY tt-commrate TO tt-MinAmmSumm NO-ERROR.
            tt-MinAmmSumm.since = tt-commrate.real-date.
   
            FIND LAST btt-MinAmm WHERE btt-MinAmm.real-date LT tt-commrate.real-date
               NO-LOCK NO-ERROR.
            IF AVAIL btt-MinAmm THEN
               tt-MinAmmSumm.real-summ = btt-MinAmm.real-summ.
         END.
      END.

      {empty comm-mp}      

      /* На основе получившейся таблицы создаем comm-mp */
      FOR EACH tt-MinAmmSumm:
         RUN kau-pos.p (acct.acct,
                        acct.currency,
                        beg-date1 - 1,
                        IF beg-date1 GE tt-MinAmmSumm.since THEN beg-date1
                                                            ELSE tt-MinAmmSumm.since,
                        gop-status,
                        loan.contract + "," + loan.cont-code + ",ОстВклС").
         mLoanOst = IF acct.currency EQ "" THEN ABS(ksh-bal)
                                           ELSE ABS(ksh-val).
      
         /* Отсекаем получившиеся записи с одинаковыми ставками */
         FIND LAST btt-MinAmmSumm WHERE btt-MinAmmSumm.since        LT tt-MinAmmSumm.since
                                    AND btt-MinAmmSumm.commission   EQ in-commi
                                    AND btt-MinAmmSumm.real-summ    EQ tt-MinAmmSumm.min-value                               
            NO-LOCK NO-ERROR.      
         IF    (    AVAIL btt-MinAmmSumm 
                AND btt-MinAmmSumm.rate-comm NE tt-MinAmmSumm.rate-comm)
            OR (NOT AVAIL btt-MinAmmSumm) THEN
         DO:
            IF mLoanOst GT tt-MinAmmSumm.real-summ THEN
            DO:
               CREATE comm-mp.               
               BUFFER-COPY tt-MinAmmSumm EXCEPT real-date since TO comm-mp NO-ERROR.
               comm-mp.since = tt-MinAmmSumm.real-date.         
               RELEASE comm-mp.
            END.
            ELSE
            DO:
               RUN Get_Last_Pen-Commi IN h_dpspc (RECID(loan),
                                                  end-date1,
                                                  end-date1,
                                                  OUTPUT mPenComm).
               IF {assigned mPenComm} THEN
               DO:
                  {findcom1.i
                     &dir       = LAST
                     &comm-rate = comm-rate
                     &rcom      = mPenComm
                     &rsum      = mTotSumm
                     &since1    = " LE tt-MinAmmSumm.real-date"
                  }

                  CREATE comm-mp.
                  BUFFER-COPY tt-MinAmmSumm EXCEPT real-date rate-comm since TO comm-mp NO-ERROR.
                  ASSIGN
                     comm-mp.rate-comm = IF AVAIL comm-rate THEN comm-rate.rate-comm
                                                            ELSE 0
                     comm-mp.since     = tt-MinAmmSumm.real-date
                     .  
                  RELEASE comm-mp.
               END.
            END.
         END.
      END.     

      FOSTS:
      FOR EACH fost,
          LAST tt-MinAmmSumm WHERE tt-MinAmmSumm.since LE fost.since:
   
         IF CAN-FIND (FIRST comm-mp WHERE comm-mp.since EQ fost.since) THEN
            NEXT FOSTS.
   
         CREATE comm-mp.
         BUFFER-COPY tt-MinAmmSumm EXCEPT real-date rate-comm since TO comm-mp NO-ERROR.
         ASSIGN comm-mp.since     = fost.since.        
   
         RUN kau-pos.p (acct.acct,
                        acct.currency,
                        beg-date1 - 1,
                        IF beg-date1 GE fost.since THEN beg-date1
                                                   ELSE fost.since,
                        gop-status,
                        loan.contract + "," + loan.cont-code + ",ОстВклС").
         mLoanOst = IF acct.currency EQ "" THEN ABS(ksh-bal)
                                           ELSE ABS(ksh-val).
   
         IF mLoanOst LT tt-MinAmmSumm.real-summ THEN
         DO:         
            RUN Get_Last_Pen-Commi IN h_dpspc (RECID(loan),
                                               end-date1,
                                               end-date1,
                                               OUTPUT mPenComm).
            IF {assigned mPenComm} THEN
            DO:
               {findcom1.i
                  &dir       = LAST
                  &comm-rate = comm-rate
                  &rcom      = mPenComm
                  &rsum      = mTotSumm
                  &since1    = " LE fost.since"
               }
            END.
   
            comm-mp.rate-comm = IF AVAIL comm-rate THEN comm-rate.rate-comm
                                                   ELSE 0.
         END.
         ELSE      
            comm-mp.rate-comm = tt-MinAmmSumm.rate-comm.         
   
         RELEASE comm-mp.
      END.

      {intr_pln.i
         &d-beg      = beg-date1
         &d-end      = end-date1
         &sum        = fost
         &since      = since
         &rcom       = in-commi
         &proc       = xresult
         &balance    = balance
         &comm-rate  = comm-mp         
         &dat-comm   = dat-commi
         &cr-recid   = YES             
         &offdef     = "/*"              
      }
   END.
   
END PROCEDURE.



/*****************************************************************************/                
/*****************************************************************************/                
/*******************Здесь кончаются схемы начисления**************************/                
/*****************************************************************************/                
/*****************************************************************************/                

PROCEDURE rclcfost.
    DEFINE INPUT PARAMETER ipContract  AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER ipContCode  AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER ipCodOst    AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER ipAcct      AS CHARACTER NO-UNDO.
    DEFINE INPUT PARAMETER ipCurr      AS CHARACTER NO-UNDO.

    DEFINE VAR vBegDate                AS DATE      NO-UNDO.
    DEFINE VAR vEndDate                AS DATE      NO-UNDO.

    
    FIND FIRST fost NO-ERROR.

    vBegDate = IF AVAIL fost THEN fost.since
                             ELSE ?.
    FIND LAST  fost NO-ERROR.
    vEndDate = IF AVAIL fost THEN fost.since
                             ELSE ?.
    vEndDate = vEndDate + 10.
    vBegDate = vBegDate - 10.
    IF vBegDate EQ ? OR vEndDate EQ ? THEN
       RETURN.

    IF ipCodOst NE ? THEN
       FOR EACH kau-entry  WHERE kau-entry.acct     EQ ipAcct
                             AND kau-entry.currency EQ ipCurr
                             AND kau-entry.op-date  GE vBegDate
                             AND kau-entry.op-date  LE vEndDate
                             AND kau-entry.kau      EQ ipContract  + ',' +
                                                       ipContCode  + ',' +
                                                       ipCodOst
                           NO-LOCK,
                FIRST op FIELDS(op-date op-status contract-date) OF kau-entry NO-LOCK:
          RUN CalcFost.
       END.
    ELSE
       FOR EACH kau-entry  WHERE kau-entry.acct     EQ ipAcct
                             AND kau-entry.currency EQ ipCurr
                             AND kau-entry.op-date  GE vBegDate
                             AND kau-entry.op-date  LE vEndDate
                             AND kau-entry.kau      BEGINS ipContract  + ',' +
                                                           ipContCode  + ','
                           NO-LOCK,
                FIRST op FIELDS(op-date op-status contract-date) OF kau-entry NO-LOCK:
          RUN CalcFost.
       END.

    FOR EACH fost:
       FIND LAST xfost WHERE xfost.since LT fost.since NO-LOCK NO-ERROR.
       IF AVAIL xfost AND xfost.balance EQ fost.balance THEN
          DELETE fost.
    END.
END.
PROCEDURE CalcFost.
   &UNDEFINE DefVarStat
   {get_status.i}
   IF op.contract-date LT kau-entry.op-date AND
      op.op-status     GE (IF massignStatus  THEN mGetSysStatus
                                             ELSE CHR(251)) THEN
      RUN InPast.
   ELSE IF op.contract-date GT kau-entry.op-date THEN
      RUN InFuture.
END PROCEDURE.

PROCEDURE InFuture:
   DEFINE VARIABLE vSignInt AS INT64 NO-UNDO.
   vSignInt = IF kau-entry.debit THEN (-1)
                                 ELSE (1).
   FOR EACH fost WHERE fost.since GT op.op-date
                   AND fost.since LE op.contract-date:
      ASSIGN fost.balance = fost.balance +
                           (vSignInt) *
                           (IF kau-entry.currency EQ '' THEN kau-entry.amt-rub
                                                        ELSE kau-entry.amt-cur).
   END.
   FIND fost WHERE fost.since EQ op.contract-date + 1 NO-ERROR.
   IF NOT AVAIL fost THEN DO:
      CREATE fost .
      fost.since = op.contract-date + 1.
      FIND LAST xfost WHERE xfost.since LT fost.since NO-ERROR.
      ASSIGN
         fost.balance = IF AVAIL xfost THEN xfost.balance
                                       ELSE 0
         fost.balance = fost.balance -
                        (vSignInt) *
                        (IF kau-entry.currency EQ '' THEN kau-entry.amt-rub
                                                     ELSE kau-entry.amt-cur)
      .
   END.
END PROCEDURE.

PROCEDURE InPast:
   DEFINE VARIABLE vSignInt AS INT64 NO-UNDO.
   vSignInt = IF kau-entry.debit THEN (-1)
                                 ELSE (1).
   FIND LAST fost WHERE fost.since EQ op.contract-date + 1 NO-ERROR.
   IF NOT AVAIL fost THEN DO:
      CREATE fost.
      fost.since = op.contract-date + 1.
      FIND LAST xfost WHERE xfost.since LT fost.since NO-ERROR.
      fost.balance = IF AVAIL xfost THEN xfost.balance
                                    ELSE 0.
   END.
   fost.balance = fost.balance -
                  (vSignInt) *
                  (IF kau-entry.currency EQ '' THEN kau-entry.amt-rub
                                               ELSE kau-entry.amt-cur).
   FOR EACH fost WHERE fost.since GT (op.contract-date + 1)
                   AND fost.since LT op.op-date:
      ASSIGN
         fost.balance = fost.balance -
                        (vSignInt) *
                        (IF kau-entry.currency EQ '' THEN kau-entry.amt-rub
                                                     ELSE kau-entry.amt-cur)
      .
   END.
END PROCEDURE.

PROCEDURE Get_Ref_nal.
 DEF INPUT  PARAM iDate AS DATE NO-UNDO.
 DEF OUTPUT PARAM oStav LIKE comm-rate.rate-comm INIT 1 NO-UNDO.
 DEF BUFFER ref-comm-rate FOR comm-rate.
    {findcom1.i
     &dir=last
     &rsum=0
     &since1=" le iDate "
     &comm-rate=ref-comm-rate
     &rcom="'%Реф'"
    }
    if avail ref-comm-rate then oStav = ref-comm-rate.rate-comm / 100 .
    release ref-comm-rate .
 end procedure .
