/*
               Банковская интегрированная система БИСквит
    Copyright: (C) 1992-2001 ТОО "Банковские информационные системы"
     Filename: LOANOP.I
      Comment:
   Parameters:
         Uses:
      Used by:
      Created:
     Modified:
     Modified:
     Modified: 18.12.2002 17:48 SEMA     по заявке 0012531 изменен вызов инструмента parssign
     Modified: 30/07/2004  Om Создание аннулированного документа.
*/

form "~n@(#) loanop.p 1.0 Om 06/03/00 Om 26/04/00"
with frame sccs-id stream-io width 250.

&GLOB  RoleOver  "for g-currv1.i"
&GLOB  BYrole    "for g-currv1.i"
&GLOB  New-Check "перед Check-Op-Entry"

DEF VAR in-op-date AS DATE NO-UNDO.

{g-docnum.def}     /* Для схем автонумерации. */
{flt_var.def}      /* Определение Shared переменных */
{all_note.def}     /* Определение таблицы с выборкой по loan */
{aux_var.def}      /* Определение таблиц расчетов, ведомостей */
{def-wf.i new}     /* Определение wop */
{g-defs.i}         /* Определение вспомогательных переменных */
{defframe.i new}   /* Необходим для parssen.p */
{intrface.get instrum}      /* инструменты перевода сумм из одной валюты в другую*/
{intrface.get ovl} /* интерфейс работы с овердрафтом*/
{intrface.get xclass}
{intrface.get terr}

def var main-first  as logical init Yes no-undo. /* Для g-acctv1.i */
def var dval        as date    no-undo. /* Необходимо для parssen.p */
def var total_value as INT64     no-undo. /* Для progress bar */
def var fler        as logical no-undo. /* Для расчетов */

def var in-contract  like loan.contract  no-undo. /* Для g-acctv1.i */
def var in-cont-code like loan.cont-code no-undo. /* Для g-acctv1.i */

DEF VAR mChkTemplate      AS CHAR   NO-UNDO.    /*процедура проврки шаблонов на
                                              корректность*/
DEF VAR mErrorTempl       AS CHAR   NO-UNDO.    /*список кривых шаблонов*/
DEF VAR mAutoRecalc       AS LOG    NO-UNDO.    /* автоматический пересчет договоров */
DEF VAR mAutoRecalcClose  AS LOG    NO-UNDO.    /* Пропускать закрытые договора */
DEF VAR proc-name         AS CHAR   NO-UNDO.
DEF VAR mParams           AS CHAR   NO-UNDO.
DEF VAR vOverEr           AS LOG INIT NO NO-UNDO.
DEF VAR mMethodAfter      AS CHAR   NO-UNDO.

DEF VAR vAutoNum          AS LOG  NO-UNDO. /* Использовать автонумерацию документов - значение
                                              ДР DocNumSch NE "2" */
DEF VAR result            AS INT64  NO-UNDO. /* для bef-tran.i - процедуры дошаблонной обработки */
                          
DEF VAR mLibHandle        AS HANDLE NO-UNDO.    /*указатель на библиотеку с
                                                  процедурами установки значений в
                                                  sysconf для обработки процедурой
                                                  логгирования */
DEF VAR mLibProc          AS CHAR   NO-UNDO.    /* Это сама библиотека*/
DEF VAR vTrList           AS CHAR   NO-UNDO. /* Список классов овердрафтов с траншами */
DEF VAR vMList            AS CHAR   NO-UNDO. /* Список классов траншей овердрафтов */


/*переменныне для сохранения параметров проводки до op-entry.upd, т.к
там могло что-нибудь измениться, например, поставили на картотеку*/
DEF VAR mOldOp       LIKE op-entry.op       NO-UNDO. /*суррогат документа*/
DEF VAR mOldOpEntry  LIKE op-entry.op-entry NO-UNDO. /*номер проводки*/
DEF VAR mOldSumRub   LIKE op-entry.amt-rub  NO-UNDO. /*Сумма проводки руб.*/
DEF VAR mOldSumCur   LIKE op-entry.amt-cur  NO-UNDO. /*Сумма проводки вал.*/
DEF VAR mOldCurrency LIKE op-entry.currency NO-UNDO. /*Валюта проводки*/
DEF VAR vRef AS CHAR NO-UNDO .
DEF VAR vEmptyOk      AS LOG  NO-UNDO.
DEFINE VARIABLE mNumFilters LIKE flt-setup.flt-num INITIAL 0               NO-UNDO.
DEFINE VARIABLE mBarMessage AS   CHARACTER         INITIAL "Секундочку..." NO-UNDO.

def var ph                   as handle no-undo.
def var parssen-library-proc as handle no-undo.

def buffer xwop for wop. /* для g-currv1.i */
DEF BUFFER bLoan FOR loan.

DEF NEW SHARED STREAM err.

DEF TEMP-TABLE DelRec NO-UNDO
    FIELD recid1 AS RECID
    INDEX recid1 IS UNIQUE recid1
    .
/* Для сохранения параметров предыдущего шаблона при нулевой сумме проводки */
define temp-table save_wop no-undo like wop.

DEFINE VARIABLE mTerrCheck AS LOGICAL     NO-UNDO. /* проверять на терроризм? */
/* что писать в ДР LegTerr
   NO  = писать "NO"
   YES = ничего не писать */
DEFINE VARIABLE mLegTerr   AS LOGICAL     NO-UNDO INITIAL YES.
DEFINE VARIABLE mCustName  AS CHARACTER   NO-UNDO EXTENT 3.
/* для сохранения уже проверенных на терроризм клиентов */
DEFINE TEMP-TABLE tt-terrchk NO-UNDO
   FIELD cust-cat AS CHARACTER
   FIELD cust-id  AS INT64
   FIELD terr     AS LOGICAL
   INDEX cust-cat-id IS UNIQUE PRIMARY cust-cat cust-id
.

{g-currv1.i &BYrole = "Yes" }    /* Поиск валюты  использует xwop */
{currency.def}                  /* проводки */
{details.def}                   /* разбор формулы "содержание"*/

ASSIGN
    in-op-date    = in_op_date
    cur-op-date   = in-op-date
    vContractDate = svPlanDate  /* Для корректировки плановой даты документа */
.

/*инициализируем дату*/
SetOpDate(vContractDate).

FIND FIRST op-kind WHERE RECID(op-kind) EQ op_rid NO-LOCK NO-ERROR.
IF NOT AVAIL op-kind THEN DO:
    {intrface.del}
    RETURN "-1".
END.

/*
  Если не задано особое соответствие фильтров и шаблонов, создаем
  стандартное: одна настройка фильтра, используемая для всех шаблонов
*/
IF mFltNum = ? OR mFltNum = 0 THEN DO:
    mFltNum = 1.
    {empty flt-setup}
    CREATE flt-setup.
    ASSIGN
        flt-setup.flt-num   = mFltNum
        flt-setup.user-id   = all_settings.flt_user
        flt-setup.proc-name = all_settings.flt_proc
        flt-setup.sub-code  = all_settings.flt_module
        flt-setup.descr     = all_settings.flt_name
    .
    {empty flt-template}
    FOR EACH op-template OF op-kind NO-LOCK:
        CREATE flt-template.
        ASSIGN
            flt-template.flt-num     = mFltNum
            flt-template.op-kind     = op-template.op-kind
            flt-template.op-template = op-template.op-template
        .
    END.
END.

ASSIGN
  DebugParser = INT64(GetXattrValueEx("op-kind", op-kind.op-kind, "DebugParser", "0"))
  mLibProc    = GetXattrValue("op-kind",op-kind.op-kind,"parslib")
  .

/* если указана процедура установки параметров обработки ошибок,
   то пытаемся запустить ее */
IF mLibProc <> "" THEN
DO:
   IF SearchPFile(mLibProc) THEN
   DO:
      RUN VALUE(mLibProc + '.p') PERSISTENT SET mLibHandle .
   END.
   ELSE mLibProc = ?.
END.


FIND LAST all_recids NO-ERROR.

IF NOT AVAIL all_recids THEN
DO:
   {intrface.del}
   RETURN "-2".
END.
ELSE
    total_value = all_recids.count.

RUN "a-yes.p"   PERSISTENT SET ph.                   /*пустышка*/
RUN "g-lolib.p" PERSISTENT SET parssen-library-proc. /*овердрафтные парсерные ф-ции*/

ASSIGN
   mChkTemplate = GetXattrValueEx("op-kind", op-kind.op-kind, "ChkTempl", ?)
   /* пересчитывать автоматически договора на дату опер.дня */
   mAutoRecalc      = GetXattrValueEx("op-kind",op-kind.op-kind,"auto-recalc"      , ?) = "Да"
   mAutoRecalcClose = GetXattrValueEx("op-kind",op-kind.op-kind,"auto-recalc-close", ?) = "Да"
   mTerrCheck       = GetXattrValueEx("op-kind",op-kind.op-kind,"loan-terrcheck"  , ?) EQ "Да"
   .

IF mChkTemplate <> ? THEN
DO:
   IF NOT SearchPFile(mChkTemplate) THEN
   DO:
      mChkTemplate = ?.
      MESSAGE "Ошибка в определении процедуры проверки шаблонов!" SKIP
             "Проверка производиться не будет."
         VIEW-AS ALERT-BOX INFO BUTTONS OK.
   END.
END.

vAutoNum = GetXAttrValueEx ("op-kind", op-kind.op-kind, "DocNumSch", "") NE "2".

FOR EACH flt-setup NO-LOCK BY flt-setup.flt-num DESCENDING:
    mNumFilters = flt-setup.flt-num.
    LEAVE.
END.
IF mNumFilters > 1 THEN
    mBarMessage = "Фильтр " + STRING(mFltNum) + "/" + STRING(mNumFilters) + ". " +
                  mBarMessage.

{init-bar.i """ + mBarMessage + """}

{setdest.i &stream = "stream err"}

   /* Кеширование парсерных функций */
IF GetXAttrValueEx ("op-kind", op-kind.op-kind, "ВклПарсКеш", "") EQ "ДА" THEN
   RUN FlgLnCache IN h_oldpr (TRUE).

NEXT_LOAN:
FOR EACH all_recids  TRANSACTION ON ERROR UNDO, NEXT ON ENDKEY UNDO, LEAVE:
   FIND loan WHERE RECID(loan) = all_recids.rid NO-LOCK NO-ERROR .
   IF NOT AVAIL loan
   THEN NEXT NEXT_LOAN .
       /* Очистка кеша под новый договор */
   RUN EmptyLnCache IN h_oldpr.

   vRef = loan.doc-ref .
   ASSIGN
       vOverEr = NO.

   &IF DEFINED(over) <> 0
   &THEN
      /*ентот &GLOB определен в loanop1.p - для группового погашения
        овердрафтных  договоров необходимо запускать не все шаблоны транзакции
        (в зависимости от класса договора ) */
      FIND FIRST overdr-debt WHERE
                 overdr-debt.rid1 = RECID(all_recids) NO-LOCK NO-ERROR.
      IF NOT AVAILABLE overdr-debt THEN NEXT.
      chpar1 = STRING(overdr-debt.rpmt-amt).
   &ENDIF

   IF GetXAttrValueEx("op-kind",op-kind.op-kind,"ТранзОтСч","") NE "" THEN
      RUN SetSysConf IN h_base ("ТранзОткрСч",GetXAttrValueEx("op-kind",op-kind.op-kind,"ТранзОтСч","")).

   /* пересчет договоров */
   FOR EACH bLoan WHERE (    bLoan.contract  EQ loan.contract                 /* для транш. и охват.договоров пересчитываем ВСЕ */
                         AND bLoan.cont-code EQ ENTRY(1, loan.cont-code, " ") /* (сначала траншевые, потом охватывающий)        */
                        )
                      OR
                        (    bLoan.contract  EQ loan.contract
                         AND bLoan.cont-code BEGINS ENTRY(1, loan.cont-code, " ") + " "
/*                         AND NUM-ENTRIES(bLoan.cont-code, " ") EQ 2 */
                        )
                        NO-LOCK
                        BY NUM-ENTRIES(bLoan.cont-code, " ") DESCENDING: 

      IF              bLoan.cont-code  NE loan.cont-code
         AND (        bLoan.open-date  GT svPlanDate
              OR (    bLoan.close-date NE ?
                  AND (    mAutoRecalcClose
                       OR  bLoan.close-date LE svPlanDate)
                 )
             )
      THEN
         NEXT. 

      IF bLoan.since <> svPlanDate THEN
      DO:
         IF mAutoRecalc THEN
         DO:

            /* получим процедуру, реализующую пересчет (метод Calc) */
            {get_meth.i 'Calc' 'loanclc'}

            RUN VALUE(proc-name + ".p") (bLoan.contract,bLoan.cont-code,svPlanDate).

            IF bLoan.since <> svPlanDate THEN
            DO:
               CREATE loan_err.
               ASSIGN
                  loan_err.cont-code = vRef
                  loan_err.template  = ?
                  loan_err.error     = "Ошибка при пересчете договора " + bLoan.doc-ref +
                                       " Договор не пересчитан на плановую дату операции."
                  .
               IF all_recids.overtr EQ YES THEN DO: /* если транш создан этой транзакцией,
                                                       то убиваем его, т.к. все равно данный
                                                       договор пропускается */
                  CREATE DelRec.
                  ASSIGN
                     DelRec.recid1 = RECID(loan).
               END.
               NEXT NEXT_LOAN.
            END.
         END. /* IF mAutoRecalc */
         ELSE DO:
            /* не пересчитывать */
            CREATE loan_err.
            ASSIGN
               loan_err.cont-code = vRef
               loan_err.template  = ?
               loan_err.error     = "Договор " + bLoan.doc-ref +
                                    " не пересчитан на плановую дату операции."
               .
            IF all_recids.overtr EQ YES THEN DO: /* если транш создан этой транзакцией,
                                                    то убиваем его, т.к. все равно данный
                                                    договор пропускается */
               CREATE DelRec.
               ASSIGN
                  DelRec.recid1 = RECID(loan).
            END.
            NEXT NEXT_LOAN.
         END.
      END.
   END. /* FOR EACH bLoan... */
   ASSIGN
      in-contract     = loan.contract
      in-cont-code    = loan.cont-code
      ph:PRIVATE-DATA = loan.contract + "," + loan.cont-code + ",loan_flt"
      .

   /*неодходимо для овердрафта (ничему другому не повредит*/
   set_loan(loan.contract,loan.cont-code).

   FOR EACH save_wop:
     DELETE save_wop.
   END.
   FOR EACH wop:
     DELETE wop.
   END.

   /* проверка клиента договора на терроризм */
   IF mTerrCheck THEN
   DO:
      FIND FIRST tt-terrchk WHERE tt-terrchk.cust-cat EQ loan.cust-cat
                              AND tt-terrchk.cust-id  EQ loan.cust-id
      NO-LOCK NO-ERROR.
      IF AVAILABLE tt-terrchk THEN
      DO:
         /* этот клиент уже проверен */
         mLegTerr = tt-terrchk.terr.
      END.
      ELSE
      DO:
         RUN GetCustName IN h_base (loan.cust-cat, loan.cust-id, ?,
                                    OUTPUT mCustName[1],
                                    OUTPUT mCustName[2],
                                    INPUT-OUTPUT mCustName[3]).
         CREATE tt-terrchk.
         ASSIGN
            tt-terrchk.cust-cat = loan.cust-cat
            tt-terrchk.cust-id  = loan.cust-id
            tt-terrchk.terr     = CompareName(mCustName[2], "plat")
            mLegTerr            = tt-terrchk.terr
         .
      END.
   END.

   GEN:
   FOR EACH flt-template WHERE
       flt-template.flt-num = mFltNum
   NO-LOCK,
   FIRST op-template WHERE
       op-template.op-kind     = flt-template.op-kind AND
       op-template.op-template = flt-template.op-template
   NO-LOCK
      ON ERROR  UNDO gen, NEXT gen
      ON ENDKEY UNDO gen, LEAVE gen:

         /* Вызов процедуры дошаблонной обработки */
      {bef-tran.i &BEF-UNDO = "UNDO gen, NEXT gen. " }

      /* Восстанавливаем предыдущие wop'ы */
      IF CAN-FIND (FIRST save_wop)
      THEN DO:
         FOR EACH save_wop:
            CREATE wop.
            BUFFER-COPY save_wop to wop.
         END.
      END.

      /*если есть процедура проверки то вызываем*/
      IF mChkTemplate <> ? THEN
      DO:
         RUN VALUE(mChkTemplate + '.p') (RECID(loan),
                                         RECID(op-template),
                                         OUTPUT mErrorTempl) NO-ERROR.
         IF ERROR-STATUS:ERROR THEN mErrorTempl = "".

      END.

      &IF DEFINED(over) <> 0
      &THEN
         /* Получаем список классов охватывающих договоров и классов траншей */
         vMList = FGetSetting("ОверКлассТранз","КлОхватТранш","").
         IF NUM-ENTRIES(vMList,"|") GT 1 THEN
            ASSIGN
               vTrList = ENTRY(2,vMList,"|")
               vMList  = ENTRY(1,vMList,"|").
         /* Проверка соответствия настройки списков */
         IF NUM-ENTRIES(vTrList) NE NUM-ENTRIES(vMList) THEN 
         do:
            CREATE loan_err.
            ASSIGN
               loan_err.cont-code = loan.doc-ref
               loan_err.template  = op-template.op-template
               loan_err.error       = "Некорректная настройка НП КлОхватТранш. Несовпадение кол-ва классов списков".
            IF NOT({assignex mChkTemplate}) THEN
            FOR EACH loan_ved WHERE
                     loan_ved.cont-code = loan.cont-code:
                DELETE loan_ved.
            END.

            IF {assignex mChkTemplate}
            THEN DO:
               RUN Save_Post.
               UNDO GEN, NEXT GEN.
            END.
            ELSE DO:
               /* если транш создан этой транзакцией, то убиваем его, 
               т.к. все равно данный договор пропускается */
               IF all_recids.overtr EQ YES THEN 
               DO: 
                  CREATE DelRec.  
                  ASSIGN
                     DelRec.recid1 = RECID(loan).
               END.
               UNDO NEXT_LOAN, NEXT NEXT_LOAN.
            END.
         end.
         
         chose-templ = GetXattrValueEx(
                       "op-template",
                       op-kind.op-kind + "," + STRING(op-template.op-template),
                       "Тип_Шаблона", "").

         IF CAN-DO(vMList, loan.class-code)          AND
            overdr-debt.debt-kind = "BAD__DEBT"      AND
            chose-templ           <> "1"             THEN
            NEXT.

         IF CAN-DO(vMList, loan.class-code)          AND
            overdr-debt.debt-kind = "GOOD_DEBT"      AND
            chose-templ           <> "2"             THEN
            NEXT.

         IF CAN-DO(vTrList, loan.class-code)        AND
            overdr-debt.debt-kind = "BAD__DEBT"     AND
            chose-templ           <> "3"            THEN
            NEXT.

         IF CAN-DO(vTrList, loan.class-code)        AND
            overdr-debt.debt-kind = "GOOD_DEBT"     AND
            chose-templ           <> "4"            THEN
            NEXT.
      &ENDIF

      {move-bar.i "all_recids.count" total_value}

      /*еслит шаблон кривой, то пропускаем*/

      IF CAN-DO(mErrorTempl,STRING(op-template.op-template))
      THEN DO:
         FIND FIRST wop WHERE wop.op-templ EQ op-template.op-template.
         
         /* если шаблон пропускается и документ не создаётся, то обнуляем расчитанную сумму, дабы потом она по ошибке не использовалась */
         wop.amt-cur = 0.
     
         RUN Save_Post.
         DELETE wop.
         
         FIND FIRST xattr WHERE 
                    xattr.class-code EQ op-kind.class-code 
                AND xattr.Xattr-Code EQ "NoUndo"
         NO-LOCK NO-ERROR.
         
         IF  AVAILABLE xattr 
         AND xattr.Data-Type EQ "logical" 
         AND GetXattrValue("op-kind",
                           op-kind.op-kind,
                           "NoUndo") EQ ENTRY(1,xattr.Data-Format,"/") THEN
            NEXT GEN.
         ELSE
            UNDO GEN, NEXT GEN.
      END.

      /*Технологический кусок. */

      FOR EACH wop WHERE
               wop.op-templ GE op-template.op-template:
         DELETE wop.
      END.

      CREATE wop.
      {asswop.i}

      ASSIGN
         wop.con-date = svPlanDate
         tacct-cr     = op-template.acct-cr
         tacct-db     = op-template.acct-db
         .

      /* Поиск счетов по стандартным функциям */
      {g-acctv1.i
         &vacct  = tacct
         &BYrole = YES }

      ASSIGN
         wop.acct-db = tacct-db
         wop.acct-cr = tacct-cr
         .

      /* Определение валюты проводки */
      RUN cur_def (RECID(wop)).
      IF RETURN-VALUE NE "" THEN
      DO:
         CREATE loan_err.
         ASSIGN
            loan_err.cont-code = loan.doc-ref
            loan_err.template  = op-template.op-template
            loan_err.error     = RETURN-VALUE
            .
         IF NOT({assignex mChkTemplate}) THEN
         FOR EACH loan_ved WHERE
                  loan_ved.cont-code = loan.cont-code:
             DELETE loan_ved.
         END.

         IF {assignex mChkTemplate}
         THEN DO:
            RUN Save_Post.
            UNDO GEN, NEXT GEN.
         END.
         ELSE DO:
            IF all_recids.overtr EQ YES THEN DO: /* если транш создан этой транзакцией,
                                                    то убиваем его, т.к. все равно данный
                                                    договор пропускается */
                CREATE DelRec.
                ASSIGN
                    DelRec.recid1 = RECID(loan).
            END.
            UNDO NEXT_LOAN, NEXT NEXT_LOAN.
         END.
      END.
      wop.currency = GetCurr(op-templ.currency).

      RUN parssen.p (RECID(wop),in-op-date,OUTPUT fler).
      IF fler THEN
      DO:
         CREATE loan_err.
         ASSIGN
            loan_err.cont-code = loan.doc-ref
            loan_err.template  = op-template.op-template
            loan_err.error       = "Ошибка при расчете суммы"
            .
         IF NOT({assignex mChkTemplate}) THEN 
         FOR EACH loan_ved WHERE
                  loan_ved.cont-code  = loan.doc-ref:
            DELETE loan_ved.
         END.

         /*UNDO NEXT_LOAN, NEXT NEXT_LOAN.*/
         IF {assignex mChkTemplate}
         THEN DO:
            RUN Save_Post.
            UNDO GEN, NEXT GEN.
         END.
         ELSE DO:
           IF all_recids.overtr EQ YES THEN DO: /* если транш создна этой транзакцией,
                                                   то убиваем его, т.к. все равно данный договор
                                                   пропускается */
               CREATE DelRec.
               ASSIGN
                   DelRec.recid1 = RECID(loan).
           END.
           UNDO NEXT_LOAN, NEXT NEXT_LOAN.
         END.


      END.
      IF wop.amt-rub  EQ     0                         OR
        (wop.amt-sign BEGINS ">" AND wop.amt-rub <= 0) OR
        (wop.amt-sign BEGINS "<" AND wop.amt-rub >= 0) THEN
      DO:
         /*IF mChkTemplate = ? THEN
         DO:*/
            CREATE loan_err.
            ASSIGN
               loan_err.cont-code = loan.doc-ref
               loan_err.template  = op-template.op-template
               loan_err.error     = "Нулевая сумма проводки"
              .
         /*END.*/

         RUN Save_Post.
         UNDO GEN, NEXT GEN.
      END.
      /*если надо создавать документ*/
      IF all_settings.do_op  THEN
      DO:

        /* Требует op(sess).cr */
        cur-op-date = if op-template.op-status eq "А"
                      then ?
                      else in-op-date.

         CREATE op.      /* Создается операция. */
         {op(sess).cr}   /* Заполнение */
&GLOB opreq-OP-DOC-NUM-USE-AUTO-COUNTER vAutoNum
         {g-op.ass}      /* таблицы OP */
&UNDEFINE opreq-OP-DOC-NUM-USE-AUTO-COUNTER
         IF NOT vAutoNum THEN
            ASSIGN
               op.doc-num = STRING(all_settings.flt_first_num).
         /* Создание обязательных ДР на документе */
         RUN grsigns.p (RECID(op)).

         IF NUM-ENTRIES(session:parameter) GE 7 THEN
            UpdateSigns(op.Class-Code, STRING(op.op), "СоздалПоток",
                        ENTRY(7,session:parameter) + "|" + ENTRY(3,session:parameter),?).

         /* Создание ДР, задающихся на шаблоне транзакции. */
         RUN parssign2.p ("PARSSEN_",
                          in-op-date,    /* Дата ОД. */
                          "op-template", /* Наименование таблицы с формулой. */

                                       /* Идентификатор формулы. */
                          op-templ.op-kind + "," + string(op-templ.op-templ),
                          op-templ.class-code,
                          "op",          /* Наименование таблицы объекта. */
                          STRING(op.op), /* Указатель на объек для создания ДР.*/
                          op.class-code,
                          RECID(wop)).   /* Указатель на WOP для парсера. */

         /* если клиент по договору не террорист - устанавливаем ДР LegTerr
            (если проверка не включена, то mLegTerr всегда = YES) */
         IF mLegTerr EQ NO THEN
            UpdateSigns(op.Class-Code, STRING(op.op), "LegTerr", "NO", ?).

         CREATE op-entry.
         /* Заполнение op-entry */
         {g-en.ass}

         /*содержание*/
         RUN ProcessDetails (RECID(wop), INPUT-OUTPUT wop.details).

         ASSIGN
            op-entry.acct-db  = wop.acct-db
            op-entry.acct-cr  = wop.acct-cr
            op-entry.currency = wop.currency
            op.details        = wop.details
            op-entry.amt-cur  = IF wop.currency EQ "" THEN 0 ELSE wop.amt-cur
            op-entry.amt-rub  = wop.amt-rub
            mOldOp            = op-entry.op
            mOldOpEntry       = op-entry.op-entry
            mOldSumRub        = op-entry.amt-rub
            mOldSumCur        = op-entry.amt-cur
            mOldCurrency      = op-entry.currency
            all_settings.flt_first_num = all_settings.flt_first_num + 1 WHEN vAutoNum
            .

         CREATE loan_err.
         ASSIGN
            loan_err.cont-code = loan.doc-ref
            loan_err.template  = op-template.op-template
            loan_err.error     = "Неизвестная ошибка"
          .

         /* Создание операции производится на плановую дату. */
         RUN op_kau.p (RECID(op-entry),
                       RECID(op-template),
                       RECID(loan),
                       svPlanDate).

         if entry(2,return-value,'|') ne '0'
         then do:
            CREATE loan_err.
            ASSIGN
              loan_err.cont-code = loan.doc-ref
              loan_err.template  = op-template.op-template
              loan_err.error     = entry(3,return-value,'|')
            .
            Undo Gen, leave Gen.
         end.

         {op-entry.upd
            &Offopupd  = "/*"
            &Ofnext    = "/*"
            &open-undo = "undo GEN, leave GEN"
            &open-undo-trans = "mVL_Except = STRING(op.op-transaction). UNDO GEN,LEAVE NEXT_LOAN"
         }

         /*постановкой на картотеку могли снести проводку*/
         IF AVAIL op-entry THEN DO:
            UpdateSigns (op-entry.class-code,
                         STRING(op-entry.op) + "," + STRING(op-entry.op-entry),
                         "НомДог",
                         loan.contract + "," + loan.cont-code,
                         ?).
                          
               /* Установка реквизитов на проводку */
            RUN "parssign2.p" ("PARSSEN_ENTRY_",
                               in-op-date,
                               "op-template",
                               op-kind.op-kind + "," + STRING(op-templ.op-templ),
                               op-templ.class-code,
                               "op-entry",
                               STRING(op-entry.op) + "," + STRING(op-entry.op-entry),
                               op-entry.class-code,
                               RECID(wop)).
            /* Если сумма изменена то, корректируем loan-int*/
            IF op-entry.amt-rub <> mOldSumRub  OR
              (op-entry.amt-cur <> mOldSumCur) THEN

               FOR EACH loan-int WHERE
                        loan-int.contract  = loan.contract
                    AND loan-int.cont-code = loan.cont-code
                    AND loan-int.op        = mOldOp
                    AND loan-int.op-entry  = mOldOpEntry
               EXCLUSIVE-LOCK:
                  /*надо будет сделать проверку на захват*/
                  ASSIGN
                     loan-int.amt = IF op-entry.currency EQ "" AND
                                       mOldCurrency      EQ "" THEN
                                       op-entry.amt-rub
                                     ELSE
                                     IF op-entry.currency = mOldCurrency THEN
                                        op-entry.amt-cur
                                     ELSE
                                        CurFromBase("Учетный",
                                                    mOldCurrency,
                                                    op-entry.op-date,
                                                    op-entry.amt-rub).
               END. /*FOR EACH loan-int*/

            /* Если надо создать переброску средств без аналитики
            ** по договорам, то удаляем созданный в проводке признак. */
            RUN op_kau.p (RECID(op-entry),
                          RECID(op-template),
                          RECID(loan),
                          svPlanDate).

            /* Для ведомости прошедших документов */
            CREATE loan_ved.
            ASSIGN
               loan_ved.cont-code = loan.cont-code
               loan_ved.l_currenc = loan.currency
               loan_ved.op        = op.op
               loan_ved.op-entry  = op-entry.op-entry
               loan_ved.doc-type  = op.doc-type
               loan_ved.doc-num   = op.doc-num
               loan_ved.acct-db   = op-entry.acct-db
               loan_ved.acct-cr   = op-entry.acct-cr
               loan_ved.currency  = op-entry.currency
               loan_ved.amt-cur   = op-entry.amt-cur
               loan_ved.amt-rub   = op-entry.amt-rub
               .
         mMethodAfter = GetXAttrValueEx("op-template", 
                                         op-kind.op-kind + "," 
                                            + STRING(op-template.op-template),
                                        "RunAfterCreate", "").
         
         IF mMethodAfter NE "" THEN
         DO:
         
            IF SearchPFile(mMethodAfter) THEN
            DO:
               RUN VALUE(mMethodAfter + ".p") (RECID(op-entry)).
       
            END.
         END.
  
         END.
         /*если проводка удалена, то сносим loan-int*/
         ELSE DO:
            FOR EACH loan-int WHERE
                     loan-int.contract  = loan.contract
                 AND loan-int.cont-code = loan.cont-code
                 AND loan-int.op        = mOldOp
                 AND loan-int.op-entry  = mOldOpEntry
            EXCLUSIVE-LOCK:
               /*надо будет сделать проверку на захват*/
               DELETE loan-int.
            END.
         END.

         DELETE loan_err.

      END. /*if all_settings.do_op*/
      {init-bar.i """ + mBarMessage + """}
      {move-bar.i "all_recids.count" total_value}
      /*Технологический кусок.*/

   END. /*GEN*/

   /* Проверка - если ни один шаблон не отработал
      без ошибок и транш был создан автоматически
      этой же транзакцией, то удаляем транш */

   FOR EACH flt-template WHERE
       flt-template.flt-num = mFltNum
   NO-LOCK,
   FIRST op-template WHERE
       op-template.op-kind     = flt-template.op-kind AND
       op-template.op-template = flt-template.op-template
   NO-LOCK:
       FIND FIRST save_wop WHERE save_wop.op-templ EQ op-template.op-template NO-LOCK NO-ERROR.
       IF NOT AVAIL save_wop THEN
           vOverEr = YES. /* хотя бы один шаблон правильно отработал */
   END.
   IF all_recids.overtr EQ YES AND vOverEr EQ NO THEN DO: /* если создан этой транзакцией, и возникли ошибки, то сносим транш */
      FIND FIRST over_error WHERE over_error.cont-code BEGINS ENTRY(1,loan.cont-code," ") NO-ERROR.
      IF AVAIL over_error THEN
         DELETE over_error.
      FIND CURRENT loan EXCLUSIVE-LOCK NO-ERROR.
      IF AVAIL loan THEN
         DELETE loan.
   END.
      /* нумерация по договорам */
   IF NOT vAutoNum AND vOverEr THEN
      all_settings.flt_first_num = all_settings.flt_first_num + 1.
END. /*NEXT_LOAN*/
RUN DeleteOldDataProtocol IN h_base ("ТранзОткрСч").
   /* Очищаем кеш и отключаем кеширование парсерных функций */
RUN EmptyLnCache IN h_oldpr.
RUN FlgLnCache IN h_oldpr (FALSE).

/* Удаляем loan если ошибки возникли в cur_def,
   а также убиваем сообщение о создании нового течения -
   т.к. оно в самом деле - не создалось !*/

FOR EACH DelRec NO-LOCK:
    FIND FIRST loan WHERE RECID(loan) EQ delrec.recid1 EXCLUSIVE-LOCK NO-ERROR.
    IF AVAIL loan THEN
    DO:
       FIND FIRST over_error WHERE over_error.cont-code BEGINS ENTRY(1,loan.cont-code," ") NO-ERROR.
       DELETE over_error.
       DELETE loan.
    END.
END.

PUBLISH 'done'.

IF VALID-HANDLE(ph) THEN
   DELETE PROCEDURE (ph). /* Удаление мусора из памяти. */

IF VALID-HANDLE(parssen-library-proc)
THEN DO:
   RUN EmptyLPResult (OUTPUT vEmptyOk).
   DELETE PROCEDURE parssen-library-proc.
END.


IF VALID-HANDLE(mLibHandle) THEN
DO:
   DELETE PROCEDURE mLibHandle.
END.


{intrface.del}
{del-bar.i}
IF flager = 9 THEN
   RETURN 'AvtReqUndo' + ',' + mVL_Except.

/* Сохранение параметров предыдущего шаблона при нулевой сумме проводки */
PROCEDURE save_post:
   CREATE save_wop.
   BUFFER-COPY wop TO save_wop.
END PROCEDURE.
/* $LINTENV ='1ut' */
/* $LINTVSS ='$/ws2-tst/bq/' */
/* $LINTDATE='17/11/2015 10:36:12.548+04:00' */
/* $LINTUSER='lakd' */
/* $LINTMODE='1' */
/* $LINTFILE='loanop.i' */
/*prosign8ACqgV7O3P1g94EtQLO5jQ*/