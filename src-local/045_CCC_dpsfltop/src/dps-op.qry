{stdwhere.fun}

DEF VAR mOEWhere AS CHAR   NO-UNDO.
DEF VAR mOEIndex AS CHAR   NO-UNDO.

DEF BUFFER op-entry-cond FOR op-entry.

DEFINE VARIABLE mClassAvail  AS CHARACTER NO-UNDO. /* Перечень доступных классов */
DEFINE VARIABLE mAllClsAvail AS LOGICAL   NO-UNDO. /* Перечень доступных классов */
         /* Получение списка доступных классов */
mClassAvail  = GetRightClasses ("op","R").
mAllClsAvail = mClassAvail EQ ls-class("op").


FUNCTION PREPARE-WHERE RETURN CHAR (INPUT iTable AS CHAR,
                                    INPUT iWhere AS CHAR
                                    ):
   DEFINE VAR vWherePart1 AS CHAR NO-UNDO.
   DEFINE VAR vWherePart2 AS CHAR NO-UNDO.
   DEFINE VAR vWherePart3 AS CHAR NO-UNDO.
   DEFINE VAR vWhereEnd   AS CHAR NO-UNDO.
   DEFINE VAR vWhereRepl  AS CHAR NO-UNDO.
   
   CASE iTable:
      WHEN "op-entry" THEN
         IF    IsBookMarkChange(8)
            OR IsBookMarkChange(10)
            OR IsBookMarkChange(11)
            OR IsBookMarkChange(16) THEN
            iWhere = REPLACE(iWhere,"first","each").
      WHEN "cstrlopentry" THEN 
         IF GetFltVal("avail_cstrlopentry") EQ "YES" THEN
            iWhere = "FIRST cstrlopentry OUTER-JOIN WHERE cstrlopentry.file-name EQ ""op-entry"" AND cstrlopentry.surrogate EQ (STRING(op-entry.op) + "","" + STRING(op-entry.op-entry)) NO-LOCK, ".
      WHEN "PackObject" THEN 
         IF GetFltVal("avail_seance") EQ "YES" OR GetFltVal("avail_packet") EQ "YES" THEN DO:
            IF INDEX(iWhere,"OUTER-JOIN ") = 0
               THEN iWhere = REPLACE(iWhere,"WHERE ","OUTER-JOIN WHERE ").
         END.        
      WHEN "op" THEN DO:
         IF  n-frm = 14
         AND (   (    {assigned mDpr-id}
                  AND mDpr-id <> "*")
              OR (    GetFltVal("op-date1") <> ?
                  AND GetFltVal("op-date1") <> ""
                  AND GetFltVal("op-date2") <> ?
                  AND GetFltVal("op-date2") <> ""
                  AND GetFltVal("op-date1") = GetFltVal("op-date2")))
         THEN DO:

            IF  INDEX(iWhere,"USE-INDEX") > 0
            AND (   INDEX(iWhere,"NO-LOCK") = 0
                 OR INDEX(iWhere,"NO-LOCK") > INDEX(iWhere,"USE-INDEX"))
            THEN vWhereEnd = SUBSTR(iWhere,INDEX(iWhere,"USE-INDEX")).
            IF  INDEX(iWhere,"NO-LOCK") > 0
            AND (   INDEX(iWhere,"USE-INDEX") = 0
                 OR INDEX(iWhere,"USE-INDEX") > INDEX(iWhere,"NO-LOCK"))
            THEN vWhereEnd = SUBSTR(iWhere,INDEX(iWhere,"NO-LOCK")).

            vWherePart1 = SUBSTRING(iWhere,INDEX(iWhere,"WHERE") + 5).
            IF INDEX(vWherePart1,"USE-INDEX") > 0
            THEN vWherePart1 = SUBSTRING(vWherePart1,1,INDEX(vWherePart1,"USE-INDEX") - 1).
            IF INDEX(vWherePart1,"NO-LOCK") > 0
            THEN vWherePart1 = SUBSTRING(vWherePart1,1,INDEX(vWherePart1,"NO-LOCK") - 1).

            vWherePart2 = vWherePart1.

            FIND FIRST flt-attr WHERE flt-attr.attr-code = "op-status" NO-LOCK NO-ERROR.
            IF AVAIL flt-attr THEN DO:
               RUN MyFormWhere (BUFFER flt-attr,OUTPUT vWhereRepl).
               vWherePart2 = REPLACE(vWherePart2,vWhereRepl,"op.op-status = 'АС'").
            END.
            FIND FIRST flt-attr WHERE flt-attr.attr-code = "op-date1" NO-LOCK NO-ERROR.
            IF AVAIL flt-attr THEN DO:
               RUN MyFormWhere (BUFFER flt-attr,OUTPUT vWhereRepl).
               vWherePart2 = REPLACE(vWherePart2,vWhereRepl,"op.due-date = " + GetFltVal("op-date1")).
            END.

            vWherePart3 = vWherePart1.

            FIND FIRST flt-attr WHERE flt-attr.attr-code = "op-status" NO-LOCK NO-ERROR.
            IF AVAIL flt-attr THEN DO:
               RUN MyFormWhere (BUFFER flt-attr,OUTPUT vWhereRepl).
               vWherePart3 = REPLACE(vWherePart3,vWhereRepl,"op.op-status = 'А'").
            END.
            FIND FIRST flt-attr WHERE flt-attr.attr-code = "op-date1" NO-LOCK NO-ERROR.
            IF AVAIL flt-attr THEN DO:
               RUN MyFormWhere (BUFFER flt-attr,OUTPUT vWhereRepl).
               vWherePart3 = REPLACE(vWherePart3,vWhereRepl,"op.due-date = " + GetFltVal("op-date1")).
            END.

            iWhere = SUBSTR(iWhere,1,INDEX(iWhere,"WHERE") + 5) + "(" + vWherePart1 + ") OR (" + vWherePart2 + ") OR (" + vWherePart3 + ") " + vWhereEnd.
         END.
      END.   
      WHEN "Packet" THEN DO:
         IF GetFltVal("avail_packet") EQ "YES" THEN DO:

            FIND FIRST flt-attr WHERE flt-attr.attr-code = "kind"  
                   AND flt-attr.attr-table      EQ "Packet"
                   AND flt-attr.attr-code-value NE "*"
                       NO-LOCK NO-ERROR.
            IF AVAIL(flt-attr) THEN
            iWhere = SUBSTRING(iWhere,1,INDEX(iWhere,"NO-LOCK") - 1) + " AND " +  
                                        StdWhere(recid(flt-attr),YES)  + " NO-LOCK, ".
            FIND FIRST flt-attr WHERE flt-attr.attr-code = "mail-format" 
                   AND flt-attr.attr-table      EQ "Packet"
                   AND flt-attr.attr-code-value NE "*"
                       NO-LOCK NO-ERROR.
            IF AVAIL(flt-attr) THEN
            iWhere = SUBSTRING(iWhere,1,INDEX(iWhere,"NO-LOCK") - 1) + " AND " +  
                                        StdWhere(recid(flt-attr),YES)  + " NO-LOCK, ".
              
         END. 
      END. 
   END CASE.
   IF iTable EQ "op-entry" THEN
      mOEWhere = iWhere.

   RETURN iWhere.
END FUNCTION.

FUNCTION DelSlash RETURNS CHAR(INPUT iStr     AS CHARACTER):

   DEFINE VARIABLE oStr AS CHARACTER   NO-UNDO INIT "".

   /* Сначала меняем двойные слеши на нечитаемый код */
   oStr = REPLACE (iStr , "~\~\"   , CHR(1) ).     
   /* потом одинарные слеши убераем */
   oStr = REPLACE (oStr , "~\"    , ""     ).     
   /* потом двойные слеши воостанавливаем в виде одного слеша */
   oStr = REPLACE (oStr , CHR(1) , "~\"    ).     

   RETURN oStr.
END FUNCTION.


FUNCTION Use-Outer-Join-op-reference RETURN LOGICAL.
  RETURN NOT IsFieldChange ("op-reference").
END FUNCTION.

FUNCTION Use-Outer-Join-bank-reference RETURN LOGICAL.
   RETURN NOT IsFieldChange ("bank-reference").
END FUNCTION.

FUNCTION Use-Outer-Join-links RETURN LOGICAL.
   RETURN NOT IsBookmarkChange(17).
END FUNCTION.

/* Возвращет WHERE выражение, полностью заменяющее сформированное. */
FUNCTION SET-WHERE RETURN CHAR (
   INPUT iQryNum  AS INT64,  /* Номер запроса. */
   INPUT iBufName AS CHAR  /* Название буффера. */
):
   DEF VAR vWhere    AS CHAR   NO-UNDO.
   DEF VAR vBufWhere AS CHAR   NO-UNDO.

   IF iBufName EQ "op-entry-cond" THEN
   ASSIGN
      vBufWhere = SUBSTRING (mOEWhere, INDEX (mOEWhere, "WHERE"))
      vBufWhere = REPLACE (vBufWhere, "op-entry.", "op-entry-cond.")
      vBufWhere = REPLACE (vBufWhere, " _&&" + "op-entry" + "&&_ AND ", " ")
      vBufWhere = REPLACE (vBufWhere, " _&&" + "op-entry" + "&&_ ",     " ")
      vBufWhere = REPLACE (vBufWhere, " NO-LOCK,"," ")
      vBufWhere = REPLACE (vBufWhere, " USE-INDEX " + mOEIndex," ")
      vBufWhere = vBufWhere + " AND op-entry-cond.op EQ op-entry.op USE-INDEX op-entry "
   .

   RETURN vBufWhere.
END FUNCTION.

FUNCTION PREPARE-FIXED-WHERE RETURN CHAR
   (INPUT iTable AS CHAR,INPUT iFixedWhere AS CHAR):
   
   DEFINE VARIABLE vClassAvail AS CHARACTER NO-UNDO. /* Перечень доступных классов */
   DEFINE VARIABLE vCond       AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vModifDate1    AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vModifDate2    AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vModifTime1    AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vModifTime2    AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vModifTime1Int AS INT64   NO-UNDO.
   DEFINE VARIABLE vModifTime2Int AS INT64   NO-UNDO.
   DEFINE VARIABLE vOpRef         AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vBankRef       AS CHARACTER NO-UNDO.
   DEFINE VARIABLE vLinkId        AS INT64     NO-UNDO.   /* идентификатор связи */
   DEFINE VARIABLE vLinkCode      AS CHAR      NO-UNDO.   /* *** значения */
   DEFINE VARIABLE vSourceId      AS CHAR      NO-UNDO.   /* *** соответствующих */
   DEFINE VARIABLE vTargetId      AS CHAR      NO-UNDO.   /* *** полей фильтра */
   DEFINE VARIABLE vLinkDirection AS CHAR      NO-UNDO.
   DEFINE VARIABLE vLinkObjectId  AS CHAR      NO-UNDO.
   DEFINE VARIABLE vClassList     AS CHAR      NO-UNDO.   /* список классов */
   DEFINE VARIABLE vi             AS INT64     NO-UNDO. /* счетчик цикла */
   DEFINE VARIABLE vClassBrowse   AS CHAR      NO-UNDO.   /* класс браузера */

   RUN SetSysConf IN h_base ("op-date1", GetFltVal("op-date1")).
   RUN SetSysConf IN h_base ("op-date2", GetFltVal("op-date2")).

   CASE iTable:
      WHEN "op" THEN DO:
         /* Получение списка доступных классов */
         vClassAvail  = GetRightClasses ("op","R").

         IF mAllClsAvail THEN.
         ELSE IF NUM-ENTRIES(mClassAvail) EQ 1
              THEN vCond = 'op.class-code EQ "' + mClassAvail + '"'.
              ELSE vCond = 'CAN-DO("' + mClassAvail + '",op.class-code)'.

         IF vCond NE ""   
          THEN iFixedWhere = iFixedWhere + (IF INDEX (iFixedWhere, "WHERE") EQ 0
                                              THEN " WHERE "
                                              ELSE " AND ") + vCond
          .
      END.
      WHEN "history" THEN DO:
         ASSIGN
            vModifDate1 = GetFltVal("modif-date1")
            vModifDate2 = GetFltVal("modif-date2")
            vModifTime1 = GetFltVal("modif-time1")
            vModifTime2 = GetFltVal("modif-time2")
         .
         IF GetFltVal("modif-merge") = "yes" THEN DO:
            IF {assigned vModifDate1} AND vModifDate1 <> "?" THEN DO:
               IF NOT ({assigned vModifTime1} AND vModifTime1 <> "?")
                  THEN vModifTime1 = "00:00:00".
               iFixedWhere = iFixedWhere + " AND ( ( history.modif-date = " + vModifDate1 + " AND history.modif-time >= " + STRING({str2time.i "REPLACE(vModifTime1,':','')"}) + " ) OR ( history.modif-date > " + vModifDate1 + " ) )".
            END.
            IF  {assigned vModifDate2} AND vModifDate2 <> "?" THEN DO:
               IF NOT ({assigned vModifTime2} AND vModifTime2 <> "?")
                  THEN vModifTime2 = "23:59:59".
               iFixedWhere = iFixedWhere + " AND ( ( history.modif-date = " + vModifDate2 + " AND history.modif-time <= " + STRING({str2time.i "REPLACE(vModifTime2,':','')"}) + " ) OR ( history.modif-date < " + vModifDate2 + " ) )".
            END.
         END.
         ELSE DO:
            /* Дата */
            IF {assigned vModifDate1} AND vModifDate1 <> "?"
               THEN iFixedWhere = iFixedWhere + " AND history.modif-date " + IsAttrFld("modif-date1","operation") + " " + vModifDate1.
            IF {assigned vModifDate2} AND vModifDate2 <> "?"
               THEN iFixedWhere = iFixedWhere + " AND history.modif-date " + IsAttrFld("modif-date2","operation") + " " + vModifDate2.
            /* Время */
            IF {assigned vModifTime1} AND vModifTime1 <> "?"
            THEN vModifTime1Int = {str2time.i "REPLACE(vModifTime1,':','')"}.
            ELSE vModifTime1Int = 0.
            IF {assigned vModifTime2} AND vModifTime2 <> "?"
            THEN vModifTime2Int = {str2time.i "REPLACE(vModifTime2,':','')"}.
            ELSE vModifTime2Int = 24 * 60 * 60 - 1.
            IF NOT (vModifTime1Int = 0 AND vModifTime2Int = 0) THEN DO:
               IF vModifTime1Int <> ? THEN iFixedWhere = iFixedWhere + " AND history.modif-time " + IsAttrFld("modif-time1","operation") + " " + STRING(vModifTime1Int).
               IF vModifTime2Int <> ? THEN iFixedWhere = iFixedWhere + " AND history.modif-time " + IsAttrFld("modif-time2","operation") + " " + STRING(vModifTime2Int).
            END.
         END.
      END.
      WHEN "kau" THEN DO:
         iFixedWhere = REPLACE(iFixedWhere,"mDpr-id",'"' + STRING(mDpr-id) + '"').
      END.
      WHEN "sss" THEN DO:
         iFixedWhere = iFixedWhere + " AND sss.dec-value NE " + mDpr-id .
      END.
      WHEN "op-impexp" THEN DO:
         ASSIGN    
            vOpRef    = GetFltVal("op-reference")     
            vBankRef  = GetFltVal("bank-reference").

         IF NOT Use-Outer-Join-op-reference() THEN
         DO:
            IF INDEX(vOpRef,"~\") > 0 THEN
            DO:
               vOpRef = DelSlash( vOpRef ).
               vOpRef = REPLACE( vOpRef , "~\", "~~~\" ).
               iFixedWhere = iFixedWhere + ' AND op-impexp.op-reference = "' + vOpRef  + '"'.
            END.
            ELSE
               iFixedWhere = iFixedWhere + ' AND CAN-DO("' + vOpRef + '", TRIM(op-impexp.op-reference))'.
         END.

         IF NOT Use-Outer-Join-bank-reference() THEN
         DO:
            IF INDEX(vBankRef,"~\") > 0 THEN
            DO:
               vBankRef = DelSlash( vBankRef ).
               vBankRef = REPLACE( vBankRef , "~\", "~~~\" ).
               iFixedWhere = iFixedWhere + ' AND op-impexp.bank-reference = "' + vBankRef  + '"'.
            END.
            ELSE
               iFixedWhere = iFixedWhere + ' AND CAN-DO("' + vBankRef + '", TRIM(op-impexp.bank-reference))'.
         END.

      END.
      WHEN "xlink" THEN
      DO:
         IF mVygprInd THEN iFixedWhere = iFixedWhere + " xlink.class-code EQ '" 
                                                     + mVygprRole 
                                                     + "' AND xlink.link-code EQ '"
                                                     + mLinkCode
                                                     + "' AND xlink.link-direction EQ 'ST'". 
      END.
      WHEN "links"
      THEN DO:
         ASSIGN
            vLinkCode      = GetFltVal("link-code")
            vLinkObjectId  = GetFltVal("link-object-id")
            vLinkDirection = GetFltVal("link-direction")
            vClassBrowse   = GetFltVal ("mClassBrowse") /* класс, от которого запущен браузер */
         NO-ERROR.
         
         vClassList     = LS-Class (vClassBrowse).     /* список потомков класса */
         
         IF mVygprInd THEN iFixedWhere = iFixedWhere + "   AND links.source-id EQ '"
                                                     + GetFltVal("cust-role-id")
                                                     + "'  AND links.beg-date LE DATE('" + STRING(gend-date) 
                                                     + "') AND (links.end-date EQ ? 
                                                            OR links.end-date GE DATE('" + STRING(gend-date) + "'))". 

         /* поиск xlink'а в списке классов по коду связи */
         BLK:
         DO vi = 1 TO NUM-ENTRIES(vClassList):
            FIND FIRST xlink WHERE xlink.link-code  EQ vLinkCode
                               AND xlink.class-code EQ ENTRY(vi,vClassList)
            NO-LOCK NO-ERROR.
            IF AVAIL xlink THEN
            DO:
               vLinkId = xlink.link-id.
               LEAVE BLK.
            END.
         END.
   
         IF     CAN-DO("S,?",vLinkDirection)
            AND (vLinkCode     NE "*"
              OR vLinkObjectId NE "*")
         THEN
            iFixedWhere = iFixedWhere + (IF vLinkCode      NE "*" THEN " (links.link-id EQ " + STRING(vLinkId) + " AND "
                                                                  ELSE " ( ")
                                      + (IF vLinkObjectId  NE "*" THEN DYNAMIC-FUNCTION("GetDynWhr" IN h_dynqr, iTable, "source-id", vLinkObjectId + CHR (1) + (IF NUM-ENTRIES(vLinkObjectId) = 2 THEN "EQ" ELSE "") + CHR (1), "CHARACTER") + " AND "
                                                                  ELSE " ")
                                      + " links.target-id EQ STRING(op.op) " + " )".
   
         IF     CAN-DO("T,?",vLinkDirection)
            AND (vLinkCode     NE "*"
              OR vLinkObjectId NE "*")
         THEN
            iFixedWhere = iFixedWhere + (IF vLinkDirection EQ "?" THEN " OR " ELSE " ")
                                      + (IF vLinkCode      NE "*" THEN " (links.link-id EQ " + STRING(vLinkId) + " AND "
                                                                  ELSE " ( ")
                                      + (IF vLinkObjectId  NE "*" THEN DYNAMIC-FUNCTION("GetDynWhr" IN h_dynqr, iTable, "target-id", vLinkObjectId + CHR (1) + (IF NUM-ENTRIES(vLinkObjectId) = 2 THEN "EQ" ELSE "") + CHR (1), "CHARACTER") + " AND "
                                                                  ELSE " ")
                                      + " links.source-id EQ STRING(op.op) " + " )".
      END.
   END CASE.
   RETURN iFixedWhere.
END FUNCTION.



FUNCTION Use-Outer-Join-PackObject RETURN LOGICAL.
   RETURN NOT (   IsBookMarkChange(8)
               OR IsBookMarkChange(10)
               OR IsBookMarkChange(11)
               OR IsBookMarkChange(16)
              ) .
END FUNCTION.

FUNCTION Use-Outer-Join-op-entry RETURN LOGICAL.
   RETURN NOT (  IsBookMarkChange(2)
              OR IsBookMarkChange(8)
              OR IsBookMarkChange(10)
              OR IsBookMarkChange(11)
              OR IsBookMarkChange(13)
              OR IsBookMarkChange(16)
              ). 
END FUNCTION.

FUNCTION Use-Outer-Join-cust-role RETURN LOGICAL.
   RETURN NOT IsBookmarkChange(12).
END FUNCTION.

FUNCTION Use-Outer-Join-ttRights RETURN LOGICAL.
   RETURN IsFieldChange ("sv-10").
END FUNCTION.

FUNCTION Use-Outer-Join-tt_OpEntryByAcct    RETURN LOGICAL.
                        /* Исключаем буфер tt_OpEntryByAcct из выборки если,
                        ** поля acct-db и acct-cr не заданы по F1 */
   RETURN ((GetFltVal ("acct-db") NE "Список") AND (GetFltVal ("acct-cr") NE "Список")).
END FUNCTION.


def buffer sss for signs.

{qrdef.i
   &buff-list       = "kau kau-entry op sss ttRights bkau-entry CondBuf"
   &need-buff-list  = "kau,kau-entry,op,sss,ttRights,bkau-entry,CondBuf"
   &Outer-Join-Buff = "ttRights"
   &Join-list       = "each,each,first,first,first,first,first"
   &fixed-where     = "'WHERE (((        kau.kau-id       BEGINS ""ПартияЦМ""
                                      OR kau.kau-id       BEGINS ""ФутлярЦМ"")
                                     AND (NUM-ENTRIES(kau.kau) > 1
                                     AND ENTRY(2,kau.kau) EQ     mDpr-id))
                                 OR (    kau.kau-id       BEGINS ""КодСмены""
                                     AND kau.kau          EQ     mDpr-id)
                                    )
                        |OF kau 
                        |OF kau-entry
                        |WHERE sss.file-name EQ ""op"" AND sss.surrogate EQ STRING(op.op) AND sss.code eq ""dpr-id""
                        |WHERE ttRights.user-id EQ op.user-id AND ttRights.freading
                        |OUTER-JOIN WHERE bkau-entry.op     EQ kau-entry.op
                                      AND bkau-entry.debit  EQ kau-entry.debit
                                      AND bkau-entry.kau-entry < kau-entry.kau-entry
                                      AND CAN-DO(""ПартияЦМ*,ФутлярЦМ*,КодСмены*"",bkau-entry.kau-id)
                        |WHERE NOT AVAIL bkau-entry
   '"
   &condition       = "mSearchVokKauEntry"
}

{qrdef.i
   &buff-list        = "xlink links op ttRights op-entry op-bank history op-impexp PackObject Packet Seance Reference cust-role cstrlopentry tt_OpEntryByAcct"
   &need-buff-list   = "xlink,links,op,ttRights,op-entry,op-bank,history,op-impexp,PackObject,Packet,Seance,Reference,cust-role,cstrlopentry,tt_OpEntryByAcct"
   &Join-list        = "EACH,EACH,EACH,FIRST,FIRST,FIRST,FIRST,FIRST,EACH,FIRST,FIRST,EACH,FIRST,FIRST,FIRST"
   &Outer-join-buff  = "ttRights,op-entry,op-bank,op-impexp,history,PackObject,Packet,Seance,Reference,cust-role,cstrlopentry,tt_OpEntryByAcct"
   &fixed-where      = "'WHERE  
                         |WHERE links.link-id EQ xlink.link-id
                         |WHERE op.op EQ INT64(links.target-id)
                         |WHERE ttRights.user-id EQ op.user-id AND ttRights.freading
                         |OF op 
                         |OF op
                         |WHERE history.file-name EQ ""op"" AND history.field-ref = string(op.op)
                         |OF op WHERE TRUE
                         |WHERE ((PackObject.file-name EQ ""op-entry"" AND PackObject.Surrogate EQ STRING(op-entry.op) + "","" + STRING(op-entry.op-entry)) OR (PackObject.file-name EQ ""op"" AND PackObject.Surrogate EQ STRING(op.op)))
                         |WHERE Packet.PacketID EQ PackObject.PacketID 
                         |WHERE Seance.SeanceID    EQ PackObject.SeanceID
                         |WHERE Reference.PacketID EQ PackObject.PacketID 
                         |WHERE cust-role.file-name EQ ""op""
                            AND cust-role.surrogate EQ STRING(op.op)   
                         |WHERE cstrlopentry.file-name  EQ ""op-entry""
                            AND cstrlopentry.surrogate  EQ STRING(op-entry.op) + "","" + STRING(op-entry.op-entry)
                         |WHERE tt_OpEntryByAcct.op = op.op
                        '"
   &Fields-Mandatory = "op-date op-status user-id,,op-entry"
   &Fields-Manual    = "op-date user-id op-status op-error,,acct-db*acct-cr kau-cr*kau-db op-entry"
   &Fields-Ignore    = ",,,,modif-date modif-time,op-reference bank-reference"
   &Use-Index        = ",,,,,op-bank"
   &condition        = "mVygprInd"
}

{qrdef.i
   &buff-list        = "tt-obj op ttRights op-entry op-bank history op-impexp links PackObject Packet Seance Reference cust-role cstrlopentry tt_OpEntryByAcct"
   &need-buff-list   = "tt-obj,op,ttRights,op-entry,op-bank,history,op-impexp,links PackObject,Packet,Seance,Reference,cust-role,cstrlopentry,tt_OpEntryByAcct"
   &Join-list        = "EACH,EACH,FIRST,FIRST,FIRST,FIRST,FIRST,FIRST,EACH,FIRST,FIRST,EACH,FIRST,FIRST"
   &Outer-join-buff  = "ttRights,op-entry,op-bank,op-impexp,history,PackObject,Packet,Seance,Reference,cust-role,cstrlopentry,tt_OpEntryByAcct,links"
   &fixed-where      = "'|WHERE op.op EQ tt-obj.op
                         |WHERE ttRights.user-id EQ op.user-id AND ttRights.freading
                         |OF op
                         |OF op
                         |WHERE history.file-name EQ ""op"" AND history.field-ref = string(op.op)
                         |OF op WHERE TRUE
                         | WHERE
                         |WHERE ((PackObject.file-name EQ ""op-entry"" AND PackObject.Surrogate EQ STRING(op-entry.op) + "","" + STRING(op-entry.op-entry)) OR (PackObject.file-name EQ ""op"" AND PackObject.Surrogate EQ STRING(op.op)))
                         |WHERE Packet.PacketID EQ PackObject.PacketID 
                         |WHERE Seance.SeanceID    EQ PackObject.SeanceID
                         |WHERE Reference.PacketID EQ PackObject.PacketID 
                         |WHERE cust-role.file-name EQ ""op""
                            AND cust-role.surrogate EQ STRING(op.op) 
                         |WHERE cstrlopentry.file-name  EQ ""op-entry""
                           AND cstrlopentry.surrogate  EQ STRING(op-entry.op) + "","" + STRING(op-entry.op-entry)
                         |WHERE tt_OpEntryByAcct.op = op.op
                       '"
   &Fields-Mandatory = ",op-date op-status user-id,,op-entry"
   &Fields-Manual    = ",op-date user-id op-status op-error,,acct-db*acct-cr kau-cr*kau-db op-entry"
   &Fields-Ignore    = ",,,,,modif-date modif-time,op-reference bank-reference"
   &Use-Index        = ",,,,op-bank"
   &condition       = "(   IsFieldChange ('file-name')
                        OR IsFieldChange ('surrogate'))"
}

{qrdef.i
   &buff-list        = "op-entry op-entry-cond op ttRights op-bank history op-impexp links PackObject Packet Seance Reference cust-role cstrlopentry tt_OpEntryByAcct CondBuf"
   &need-buff-list   = "op-entry,op-entry-cond,op,ttRights,op-bank,history,op-impexp,links,PackObject,Packet,Seance,Reference,cust-role,cstrlopentry,tt_OpEntryByAcct,CondBuf"
   &Join-list        = "each,first,first,first,first,first,first,FIRST,each,first,first,each,first,first,first,first"
   &Outer-join-buff  = "ttRights,op-bank,op-impexp,history,PackObject,Packet,Seance,Reference,cust-role,cstrlopentry,tt_OpEntryByAcct,links"
   &fixed-where      = "'WHERE op-entry.acct-cat begins ''''
                         |
                         |OF op-entry
                         |WHERE ttRights.user-id EQ op.user-id AND ttRights.freading
                         |OF op 
                         |WHERE history.file-name EQ ""op"" AND history.field-ref = string(op.op)
                         |OF op WHERE TRUE
                         | WHERE 
                         |WHERE (PackObject.file-name EQ ""op-entry"" AND PackObject.Surrogate EQ STRING(op-entry.op) + "","" + STRING(op-entry.op-entry)) OR (PackObject.file-name EQ ""op"" AND PackObject.Surrogate EQ STRING(op.op))
                         |WHERE Packet.PacketID EQ PackObject.PacketID 
                         |WHERE Seance.SeanceID    EQ PackObject.SeanceID
                         |WHERE Reference.PacketID EQ PackObject.PacketID 
                         |WHERE cust-role.file-name EQ ""op""
                            AND cust-role.surrogate EQ STRING(op.op) 
                         |WHERE cstrlopentry.file-name  EQ ""op-entry""
                            AND cstrlopentry.surrogate  EQ STRING(op-entry.op) + "","" + STRING(op-entry.op-entry)
                         |WHERE tt_OpEntryByAcct.op = op.op
                         |WHERE ROWID (op-entry) EQ ROWID (op-entry-cond)
                        '"
   &Fields-Mandatory = "op-date op-status user-id,,op-date op-status user-id"
   &Fields-Manual    = "acct-db*acct-cr kau-cr*kau-db op-entry op-date user-id op-status,,op-date user-id op-status op-error"
   &Fields-Ignore    = ",,,,,modif-date modif-time,op-reference bank-reference"
   &Use-Index        = ",,,,op-bank"
   &condition        = "IsBookmarkChangeEx (2,'acct-flt-new') AND GetFltValEx ('acct-flt-new','NO') EQ 'YES' AND GetFltValEx ('FilterTable','*') EQ '*' AND GetFltValEx ('UseTmpObjInQuery','*') EQ '*'"
}

{qrdef.i
   &buff-list        = "op ttRights op-entry op-bank history op-impexp links PackObject Packet Seance Reference cust-role cstrlopentry tt_OpEntryByAcct"
   &need-buff-list   = "op,ttRights,op-entry,op-bank,history,op-impexp,links,PackObject,Packet,Seance,Reference,cust-role,cstrlopentry,tt_OpEntryByAcct"
   &Join-list        = "EACH,FIRST,FIRST,FIRST,FIRST,FIRST,FIRST,EACH,FIRST,FIRST,EACH,FIRST,FIRST,FIRST"
   &Outer-join-buff  = "ttRights,op-entry,op-bank,op-impexp,history,PackObject,Packet,Seance,Reference,cust-role,cstrlopentry,tt_OpEntryByAcct,links"
   &fixed-where      = "'|WHERE ttRights.user-id EQ op.user-id AND ttRights.freading
                         |OF op 
                         |OF op
                         |WHERE history.file-name EQ ""op"" AND history.field-ref = string(op.op)
                         |OF op WHERE TRUE
                         | WHERE 
                         |WHERE ((PackObject.file-name EQ ""op-entry"" AND PackObject.Surrogate EQ STRING(op-entry.op) + "","" + STRING(op-entry.op-entry)) OR (PackObject.file-name EQ ""op"" AND PackObject.Surrogate EQ STRING(op.op)))
                         |WHERE Packet.PacketID EQ PackObject.PacketID 
                         |WHERE Seance.SeanceID    EQ PackObject.SeanceID
                         |WHERE Reference.PacketID EQ PackObject.PacketID 
                         |WHERE cust-role.file-name EQ ""op""
                            AND cust-role.surrogate EQ STRING(op.op) 
                         |WHERE cstrlopentry.file-name  EQ ""op-entry""
                            AND cstrlopentry.surrogate  EQ STRING(op-entry.op) + "","" + STRING(op-entry.op-entry)
                         |WHERE tt_OpEntryByAcct.op = op.op
                        '"
   &Fields-Mandatory = "op-date op-status user-id,,op-entry"
   &Fields-Manual    = "op-date user-id op-status op-error,,acct-db*acct-cr kau-cr*kau-db op-entry"
   &Fields-Ignore    = ",,,,modif-date modif-time,op-reference bank-reference"
   &Use-Index        = ",,,op-bank"
   &condition        = "YES"
}


PROCEDURE PostSelectQuery:
                        /* Список полей, таблица которых меняется с op на op-entry
                        ** и наоборот в зависимости от необходимости фильтрации по проводкам */
   DEF VAR vFldTblList     AS CHAR   NO-UNDO INIT "op-date1,op-date2,op-status,acct-cat,user-id,op".
   DEF VAR vFldSortOffList AS CHAR   NO-UNDO INIT "".      /* op-date1,op-date2,op-status,user-id,op*/
   DEF VAR vi              AS INT64  NO-UNDO.
   DEF VAR vOEFl           AS LOG    NO-UNDO.

   DEF BUFFER bflt-attr FOR flt-attr.
   DEF BUFFER bdynqr    FOR dynqr.

   vOEFl =      IsBookmarkChangeEx (2,"acct-flt-new")
            AND GetFltValEx ("acct-flt-new","NO")    EQ "YES"
            AND GetFltValEx ('FilterTable','*')      EQ '*'
            AND GetFltValEx ('UseTmpObjInQuery','*') EQ '*'.

   DO vi = 1 TO NUM-ENTRIES (vFldTblList):
      FIND FIRST bflt-attr WHERE bflt-attr.attr-code EQ ENTRY (vi, vFldTblList) NO-ERROR.
      IF AVAIL bflt-attr THEN
         bflt-attr.attr-table = IF vOEFl THEN "op-entry" ELSE "op".
   END.
   DO vi = 1 TO NUM-ENTRIES (vFldSortOffList):
      FIND FIRST bflt-attr WHERE bflt-attr.attr-code EQ ENTRY (vi, vFldSortOffList) NO-ERROR.
      IF AVAIL bflt-attr THEN
         bflt-attr.attr-sort = IF vOEFl THEN NO ELSE YES.
   END.
                        /* условие по filial-id переносим либо в op-entry, либо в op */
   FOR EACH bdynqr:
      bdynqr.PermBuf = IF vOEFl THEN "op-entry" ELSE "op".
   END.

   /* Процедура установления переменных для
   ** ускорения фильтрации по вычисляемым полям. */
   ASSIGN
      mIsSv-1  = IsFieldChange ("sv-1")
      mIsSv-2  = IsFieldChange ("sv-2")
      mIsSv-3  = IsFieldChange ("sv-3")
      mIsSv-4  = IsFieldChange ("sv-4")
      mIsSv-7  = IsFieldChange ("sv-7")
      mIsSv-8  = IsFieldChange ("sv-8")
      mIsSv-10 = IsFieldChange ("sv-10")
   .

   /* Сбор проводок по транзакции. */
   IF    IsFieldChange ("file-name")
      OR IsFieldChange ("surrogate")
   THEN RUN FillTTObj.

   /* Устранение дублирования */
   mIsExDblPO = (    (Use-Outer-Join-PackObject() = NO)
                 AND (   GetFltVal("avail_seance")  <> "YES" 
                      OR GetFltVal("avail_packet")  = "YES")).
   RUN SetFltFieldList ("mExDblPO", STRING(mIsExDblPO)).
   RUN SetFltField     ("mExDblPO", STRING(mIsExDblPO)).
   {empty ttExDblPO}

   RUN FrameSetting.
                        /* Включены ли ограничения на чтение групп счетов */
   mAcctGrOn = UserAcctGroupLimitsEnabled ('r', USERID("bisquit")).
                              /* Фильтрация по группам только для админов */
/*   IF IsUserAdm(USERID("bisquit")) THEN*/
      RUN FillttOpGroupAcct.
END PROCEDURE.

/* Заполнение временной таблицы ROWID'ов документов при фильтрации по группам доступа */
PROCEDURE FillttOpGroupAcct PRIVATE.
   DEF VAR vHQry         AS HANDLE NO-UNDO.
   DEF VAR vHBufLinks    AS HANDLE NO-UNDO.
   DEF VAR vHBuf         AS HANDLE NO-UNDO.
   DEF VAR vHBufOp       AS HANDLE NO-UNDO.
   DEF VAR vFltGroupList AS CHAR   NO-UNDO.
   DEF VAR vFltGroupType AS CHAR   NO-UNDO.
   DEF VAR vGroupList    AS CHAR   NO-UNDO.
   DEF VAR vi            AS INT64  NO-UNDO.
   DEF VAR vOK           AS LOG    NO-UNDO.

   DEF BUFFER flt-attr FOR flt-attr.

   EMPTY TEMP-TABLE ttOpGroupAcct.
   EMPTY TEMP-TABLE LocalTmpObj.
                        /* Восстанавливаем фильтрацию про временной таблице, заданную 
                        ** при запуске браузера, или сбрасываем ее вообще если при запуске ее не было */
   RUN SetFltField ("UseTmpObjInQuery",STRING (mHTmpObj)).
                        /* Если заданы группы для фильтрации */
   IF GetFltVal ("GroupList") NE "*" THEN
   DO:
      ASSIGN
         vFltGroupList = GetFltVal("GroupList")     /* список групп счетов */
         vFltGroupType = GetFltVal("GroupFltType"). /* способ фильтрации по группам */

      CREATE QUERY vHQry.
      CREATE BUFFER vHBufLinks FOR TABLE "links".
      CREATE BUFFER vHBuf      FOR TABLE "op-entry".
      CREATE BUFFER vHBufOp    FOR TABLE "op".
      vHQry:SET-BUFFERS(vHBufLinks, vHBuf, vHBufOp).

      vHQry:QUERY-PREPARE(" FOR EACH links WHERE links.link-id   EQ "  + STRING(GetXLinkID("acct","acct-group")) +
                          " AND " + DYNAMIC-FUNCTION ("GetDynWhr" IN h_dynqr, "",
                          " links.target-id",
                            GetFltVal ("GroupList") + CHR (1) + CHR (1), "CHARACTER") +
                          " NO-LOCK," +
                          " EACH op-entry WHERE op-entry.op-date GE " + GetFltVal('op-date1') +
                          " AND op-entry.op-date LE " + GetFltVal('op-date2') +
                          " AND op-entry.acct-db EQ ENTRY(1,links.source-id) " +
                          " OR op-entry.op-date GE " + GetFltVal('op-date1') +
                          " AND op-entry.op-date LE " + GetFltVal('op-date2') +
                          " AND op-entry.acct-cr EQ ENTRY(1,links.source-id) " +
                          " NO-LOCK," +
                          " FIRST op OF op-entry NO-LOCK"
                          ).
                          
/*      vHQry:QUERY-PREPARE("FOR EACH links WHERE links.link-id   EQ "  + STRING(GetXLinkID("acct","acct-group")) +*/
/*                                          " AND " + DYNAMIC-FUNCTION ("GetDynWhr" IN h_dynqr, "",                */
/*                                                    "links.target-id",                                           */
/*                                                    GetFltVal ("GroupList") + CHR (1) + CHR (1), "CHARACTER")   +*/
/*                          "NO-LOCK," +                                                                           */
/*                          "EACH op-entry WHERE op-entry.acct-db     EQ ENTRY (1,links.source-id) " +             */
/*                                          " OR op-entry.acct-cr     EQ ENTRY (1,links.source-id) " +             */
/*                          "NO-LOCK," +                                                                           */
/*                          "FIRST op OF op-entry NO-LOCK"                                                         */
/*                          ).                                                                                     */

/*MESSAGE vHQry:PREPARE-STRING*/
/*VIEW-AS ALERT-BOX.          */

      vHQry:QUERY-OPEN().
      vHQry:GET-FIRST().
      DO WHILE NOT vHQry:QUERY-OFF-END:
         IF NOT CAN-FIND (FIRST ttOpGroupAcct WHERE ttOpGroupAcct.id EQ vHBufOp:RECID) THEN
         DO:
                              /* "Отбирать счета принадлежащие: (X)Только указанным группам" -
                              ** Все группы счета принадлежат списку */
            IF vFltGroupType EQ "all" THEN
            DO:
               vGroupList = GetLinks ("acct",vHBufLinks::source-id,"S","acct-group",",",?).
               GRLST:
               DO vi = 1 TO NUM-ENTRIES(vGroupList):
                  IF NOT CAN-DO(vFltGroupList, ENTRY (vi,vGroupList)) THEN
                  DO:
                     vGroupList = ?.
                     LEAVE GRLST.
                  END.
               END.
            END.

            IF    vGroupList    NE ?
               OR vFltGroupType NE "all"
            THEN DO:
               CREATE ttOpGroupAcct.
               ASSIGN ttOpGroupAcct.id = vHBufOp:RECID.
            END.
         END.
         vHQry:GET-NEXT().
      END.
      vHQry:QUERY-CLOSE().
      DELETE OBJECT vHQry      NO-ERROR.
      DELETE OBJECT vHBufLinks NO-ERROR.
      DELETE OBJECT vHBuf      NO-ERROR.
      DELETE OBJECT vHBufOp    NO-ERROR.

      IF mFltTmpObj THEN
         vHBuf = mHTmpObj:DEFAULT-BUFFER-HANDLE.
                        /* Перекладываем идентификаторы записей в локальную временную 
                        ** таблицу LocalTmpObj, по которой будем осуществлять фильтрацию,
                        ** с учетом того, что уже может быть включена фильтрация по TmpObj извне */
      FOR EACH ttOpGroupAcct:
                        /* Если фильтрация по TmpObj включена при запуске браузера,
                        ** то собираем только записи из ttOpGroupAcct, которые есть в TmpObj,
                        ** т.е. пересечение ttOpGroupAcct и TmpObj */
         IF mFltTmpObj THEN
            vOK = vHBuf:FIND-FIRST ("WHERE " + mHTmpObj:NAME + ".rid EQ " + STRING (ttOpGroupAcct.id), NO-LOCK) NO-ERROR.
         ELSE vOK = YES.
         IF NOT vOK THEN NEXT.

         CREATE LocalTmpObj.
         ASSIGN LocalTmpObj.rid = ttOpGroupAcct.id.
      END.
      DELETE OBJECT vHBuf NO-ERROR.

                        /* Устанавливаем фильтрацию по временной таблице LocalTmpObj */
      FIND FIRST flt-attr WHERE
         flt-attr.attr-code EQ "UseTmpObjInQuery"
      NO-ERROR.
      IF NOT AVAIL flt-attr THEN
      DO:
         CREATE flt-attr.
         ASSIGN
            flt-attr.attr-code      = "UseTmpObjInQuery"
            flt-attr.attr-hidden    = YES
            flt-attr.attr-sensitive = NO
            flt-attr.attr-initial   = "*"
         .
      END.
      flt-attr.attr-code-value = STRING (mLocalTmpObjHand).
   END.
   RETURN.
END PROCEDURE.

/* Заполнение полей фильтра из сохраненной настройки UserConf  */
PROCEDURE FillUserConfFltr.
   DEFINE INPUT PARAMETER iUserConf AS CHARACTER NO-UNDO.

   DEFINE VARIABLE list-class     AS CHARACTER  NO-UNDO. /* Необходимо для flt-file.end. */
   DEFINE VARIABLE num-class      AS INT64      NO-UNDO.

   RUN LdUsrCnfId (iUserConf) NO-ERROR.
   {flt-file.end}

   RETURN. 
END PROCEDURE.
/* $LINTENV ='1ut' */
/* $LINTVSS ='$/ws2-tst/bq/' */
/* $LINTDATE='18/08/2015 16:14:56.493+04:00' */
/* $LINTUSER='ariz' */
/* $LINTMODE='1' */
/* $LINTFILE='dps-op.qry' */
/*prosignQz0JR0zmXVBEOjOTuog9bg*/